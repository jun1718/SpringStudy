21.02.03.1회차
===============================================================================
*maven, spring모듈추가, bean객체, DI(의존성주입)
===============================================================================


##############################################################################
1)Spring 환경구축 및 모듈 추가

1-1)매이븐 프로젝트 만들기
project : maven project
	-만들때 create a simple project해야 기본설정이 들어옴 
group id : com.spring 
Artifact id : basicReivew
		-생각해보니이거 basic해도 됨 workspace 이름만다르면되고 내부에서 artifat id group id 동일해도 상관없음.. 

	*메이븐 프로젝트 만드는 이유
		-필요한 라이브러리(모듈, API)에 관한 정보를 특정문서(pom.xml)에 정의해 놓으면 네트워크를 통해서
		 라이브러리들을 자동으로 설치해준다. 직접 수동으로 설치해서 집어넣을수도 있지만 메이븐프로젝트는 이렇게
		 자동설치의 이점이 있기에 사용한다.
	*메이븐 자동설치 전제조건
		-maven repository 사이트에서 라이브러리에 관한 정보가 정의된 것을 복사해와야함
			-maven repository : 메이븐 프로젝트에서 자동으로 모듈들 검색하여 설치할수있도록 관련 정보들을 모아놓은 사이트

1-2)프로젝트 기본 환경구축
encoding하여 web언어들이나 workspace, xml등 모두 utf-8인 유니코드로 변경
						-기존의 Korean, EUC로하면 ㄱ ㄴ ㄷ 을 못읽음
화면 블랙

1-3)설정추가(pom.xml)
	-설정추가는 앞으로 나올 dependencies 즉 의존성때문에 설치해야하는 모듈들을 묶어놓은 그룹 아래에 작성한다.
build 설정추가 : build안하고 모듈추가 즉 메이븐프로젝트의 기능을 사용가능한지 확인해바라
	-maven도 자바라이브러리중 하나이고 java와 본인간에 호환성을 맞추기위한 설정이 필요하다.
	-아래에서 build가 그설정이며 maven의 컴파일러는 뭘로할것이고 메이븐의 버젼은몇이고 자바의 버전은 1.8이고 등등의 설정이다.
		-이걸 설정추가안하면 maven프로젝트을 사용할수는 >????모르겠당
			-실험결과 가능, 기본값이 있는것으로 파악됨 다만 build하고나서 반드시 alt f5하여서 바뀐걸 알려줘야함
	<build>
		<plugins>
			<plugin>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.5.1</version>
				<configuration>
					<source>1.8</source>
					<target>1.8</target>
					<encoding>utf-8</encoding>
				</configuration>
			</plugin>
		</plugins>
	</build>

1-4)메이븐 기능인 모듈추가(pom.xml) 적용해보기
	-maven repository에서 사람들이 가장 많이받고 상위에있는걸 선택하면 된다.
	-이때 라이브러리가 어디에 저장되는가?
		-C:\Users\USER\.m2\repository\org\springframework
		-spring-context를 설치했지만 내부에는 파일이 엄청 많을건데 해당 context를 이용하기위한 의존성 파일들(라이브러리)
			까지 함께 추가된것으로 인지하면 되겠다.
		
spring 모듈 추가
	검색 keyword : spring-context => 5.1.5 설치(회사에선상관없는데 지금은 환경통일을위해 이렇게한다 아래도 마찬가지)

jstl 모듈 추가
	검색 keyword : jstl => 1.2버전

##############################################################################


답:


<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>com.spring</groupId>
	<artifactId>basic</artifactId>
	<version>0.0.1-SNAPSHOT</version>

	<!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
	<dependencies>
		<!-- Spring-context 모듈 -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
			<version>5.1.5.RELEASE</version>
		</dependency>

		<!-- jstl 모듈 -->
		<!-- https://mvnrepository.com/artifact/javax.servlet/jstl -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jstl</artifactId>
			<version>1.2</version>
		</dependency>
		
		
	</dependencies>
	<build>
		<plugins>
			<plugin>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.5.1</version>
				<configuration>
					<source>1.8</source>
					<target>1.8</target>
					<encoding>utf-8</encoding>
				</configuration>
			</plugin>
		</plugins>
	</build>
</project>













##############################################################################
2)resources의 xml을 이용하여 spring 컨테이너에 객체 생성후 사용
	-Spring을 DI frame work 혹은 Ioc frame work 라고도 한다
	-xml에서 bean을 통해 객체를 만드는 코드를 작성하고 main code에서 xml을 실행시켜 bean객체가 만들어지면 그것이
		spring 컨테이너에 들어감

<package 생성> : com.spring.basic

	-위치 : src/main/java 디렉터리 내부
	-원래 루트 패키지는 gid와 아티팩트 id를 붙여서 만든다.
		-root 패키지: 모든 코드가 출발하는 첫번재 디렉토리

<class 생성>
	-위치 : com.spring.basic 패키지(루트패키지) 내부
	-클래스1 이름 : SpringTest
		-메서드 : hello()
			- "스프링 객체주입 테스트 ~"를 출력하는 메서드
	-클래스2 이름 : HelloSpring
		-메서드 : 없음

<xml 생성>
	-위치 : src/main/resources
		-resources가 설정이되는 xml 파일이 들어가는 곳임
		-java는 java의 코드들이 들어감 
			-resources 설정에 bean만들고 뭐하고 계속 쓰는이유가 java 코드는 안만지고 resources의 설정만
				바꾸면 논리적으로 간단하니까 그런거임
	-이름 : test-config.xml

xml 생성시 아래코드를 추가하고 그안에 다른값을 만들어야함
<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd">
</beans>

1)SpringTest클래스의 인스턴스를 HelloSpring에 만들어서 인스턴스의 hello()메서드 실행
-구석기시대방식으로 출력해보기
		
-최신식으로 출력해보기(test-config.xml을 이용하여 설정에서 인스턴스를 만들고 그걸 전달받아서 구동)
	-bean id : test
	-다끝나면 ct 닫아라 꼭

##############################################################################

답:

<class 생성> : HelloSpring은 아래 1번 답에 있음
package com.spring.basic;

public class SpringTest {
	public void hello() {
		System.out.println("스프링 객체주입 테스트 ~");
	}
}

<xml 생성>
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd">
	<bean id = "test" class = "com.spring.basic.SpringTest" />
</beans>



1)SpringTest클래스의 인스턴스를 HelloSpring에 만들어서 인스턴스의 hello()메서드 실행
-구석기시대방식으로 출력해보기
		package com.spring.basic;

import org.springframework.context.support.GenericXmlApplicationContext;

public class HelloSpring {
	public static void main(String[] args) {
		System.out.println("안녕 스프링~!");
		
		SpringTest st = new SpringTest();
		st.hello();
	}
}

-최신식으로 출력해보기(test-config.xml을 이용하여 설정에서 인스턴스를 만들고 그걸 전달받아서 구동)
	-위의 xml과 함께 호환되어야함.

package com.spring.basic;

import org.springframework.context.support.GenericXmlApplicationContext;

public class HelloSpring {
	public static void main(String[] args) {

		GenericXmlApplicationContext ct = 
				new GenericXmlApplicationContext("classpath:test-config.xml");
		SpringTest st = ct.getBean("test", SpringTest.class);
		
		st.hello();
		ct.close();
	}
}














##############################################################################
3)di(의존성주입) 
	-주입코드를(의존객체를) 넣는방법(의존성주입하는법)
			-의존객체 : 대상객체 
				-의존성이 있는 두 객체에는 대상객체와 의존적인 객체가 있다. 이때 대상객체가 의존객체다.
					-대상객체: 특정객체가 어느객체에 의존적일때 의존성을 충족시키는 객체가 대상객체임
				-쉽게말해서 의존객체는 충분조건, 의존적인 객체는 필요조건
		-구시대적(수동적 주입)
			-생성자를 이용해서 넣기
			-setter를 통한 의존성 주입

		-현시대적(자동적 주입)
			-생성자를 이용해서 넣기
			-setter를 통한 의존성 주입

<packages 생성>
	-위치 : src/main/java
	-이름 : com.spring.basic.ex01

<class 생성>
	-위치 : com.spring.basic.ex01 패키지
	-구조 : Chef -> Restaurant -> Hotel 형식으로 의존성 생성(생성자를 이용하여 의존성구현)

	-이름 : Chef
		-인스턴스 생성시 "요리사가 출근함!" 출력하게 클래스 생성
		-메서드 : cook()
			-"요리사가 요리를 합니다."를 출력하는 메서드 구현
	-이름 : Restaurant
		-field : chef라는 Chef 클래스의 인스턴스 주소를 담을 참조변수 생성(변수만 생성)
		-생성자에서 처리할 것
			-인스턴스 생성시 "레스토랑이 생성됨!" 출력하게 클래스 생성
			-생성자의 매개변수를 통해서 필드인 chef에 주소값 저장(즉 Chef 클래스의 인스턴스생성)
		-메서드 : orderDinner()
			-"저녁식사를 주문합니다."를 출력하는 메서드 구현
			-내부에서 Chef클래스의 인스턴스의 cook()메서드 실행

	-이름 : Hotel
		-field : Restaurant 클래스의 인스턴스 주소를 저장할 멤버변수 res 생성
		-생성자
			-인스턴스 생성시 "호텔이 생성됨!"을 출력
			-인스턴스 생성시 생성자매개변수를 통해 res field에 값저장
		-메서드 : reserveRestaurant()
			-해당 메서드를 실행시 "레스토랑을 예약합니다."를 출력
			-res field를 이용해서 orderDinner() 메서드 실행
			-즉 reserveRestaurant()메서드 실행함으로 Chef까지 의존관계 객체를 모두 사용


	-이름 : MainClass
		
1)MainClass에서 아래 출력결과가 나오도록 실행
1-1)수동적으로 의존성 주입
1-2)자동적으로(test-config.xml이용하여 의존성 해결 및 bean으로 객체 생성) 의존성 주입
	bean id 
		-chef
		-res
		-hotel

<출력결과>
요리사가 출근함!
레스토랑이 생성됨!
호텔이 생성됨!
레스토랑을 예약합니다.
저녁식사를 주문합니다.
요리사가 요리를 합니다.


##############################################################################


답:





package com.spring.basic.ex01;

public class Chef {
	public Chef() {
		System.out.println("요리사가 출근함!");
	}
	public void cook() {
		System.out.println("요리사가 요리를 합니다.");
	}
}



package com.spring.basic.ex01;

public class Restaurant {
	private Chef chef;
	
	public Restaurant(Chef chef) {
		// TODO Auto-generated constructor stub
		this.chef = chef;
		
		System.out.println("레스토랑이 생성됨!");
	}
	
	public void orderDinner() {
		System.out.println("저녁식사를 주문합니다.");
		chef.cook();
	}
}



package com.spring.basic.ex01;

public class Hotel {
	
	private Restaurant res;
	
	public Hotel(Restaurant res) {
		this.res = res;
		System.out.println("호텔이 생성됨!");
	}
	
	public void reserveRestaurant() {
		System.out.println("레스토랑을 예약합니다.");
		res.orderDinner();
	}
}




1)MainClass에서 아래 출력결과가 나오도록 실행
1-1)수동적으로 의존성 주입

package com.spring.basic.ex01;

import org.springframework.context.support.GenericXmlApplicationContext;

public class MainClass {

	public static void main(String[] args) {
		Hotel hotel = new Hotel(new Restaurant(new Chef()));
		hotel.reserveRestaurant();
	}

}




1-2)자동적으로(test-config.xml이용하여 의존성 해결 및 bean으로 객체 생성) 의존성 주입

1-2-1)test-config.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd">
	<bean id = "test" class = "com.spring.basic.SpringTest" />
	
	<!--  Hotel 객체와 의존객체들의 빈 등록 및 의존성 주입설정 -->
	<bean id = "chef" class = "com.spring.basic.ex01.Chef" />
	<bean id = "res" class = "com.spring.basic.ex01.Restaurant" >
		<constructor-arg ref = "chef" />
	</bean>
	<bean id = "hotel" class = "com.spring.basic.ex01.Hotel" >
		<constructor-arg ref = "res" />
	</bean>
</beans>


1-2-2)MainClass
package com.spring.basic.ex01;

import org.springframework.context.support.GenericXmlApplicationContext;

public class MainClass {

	public static void main(String[] args) {
		GenericXmlApplicationContext ct =
				new GenericXmlApplicationContext("classpath:test-config.xml");
		Hotel hotel = ct.getBean("hotel", Hotel.class);
		
		hotel.reserveRestaurant();
	}
}







































































21.02.04.2회차
===============================================================================
*setter의존성주입(property_원시데이터,객체),scope(singleton,prototype),자동객체주입
===============================================================================
































































##############################################################################
4)setter를 통한 의존성 주입(원시형 자료형 데이터 주입)

*수동 의존성주입방식
1.생성자를 통한 의존성 주입
2.setter를 통한 의존성 주입


1)db-config.xml을 이용하여 setter를 통한 의존성 주입을 설정하라 
	-main 주석읽고 풀어라
	-bean id : db1, db2

package com.spring.basic.ex02;

public class DataBaseInfo {
	private String url;
	private String uid;
	private String upw;
	
	public String getUrl() {
		return url;
	}
	public void setUrl(String url) {
		this.url = url;
	}
	public String getUid() {
		return uid;
	}
	public void setUid(String uid) {
		this.uid = uid;
	}
	public String getUpw() {
		return upw;
	}
	public void setUpw(String upw) {
		this.upw = upw;
	}
	
	
}


package com.spring.basic.ex02;

public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		DataBaseInfo dbInfo = new DataBaseInfo();
		dbInfo.setUid("spring1");
		dbInfo.setUpw("sss111");
		dbInfo.setUrl("jdbc:mysql://localhost:3306/spring");
		
		System.out.println("URL : " + db1.getUrl());
		System.out.println("UID : " + db1.getUid());
		System.out.println("UPW : " + db1.getUpw());

		//위처럼 하지말고 설정으로 해보자
	}
}


<출력결과>
URL : jdbc:mysql://localhost:3306/spring
UID : spring1
UPW : sss111
URL : jdbc:mysql://localhost:3306/practice
UID : root
UPW : mysql


##############################################################################


답:

#db-config.xml

<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean id = "db1" class = "com.spring.basic.ex02.DataBaseInfo">
		<!--  setter 주입 -->
		<property name = "url" value = "jdbc:mysql://localhost:3306/spring" />
				<!--  setter에 해당하는 field이름을 name에 적는다. -->
		<property name = "uid" value = "spring1" />
		<property name = "upw" value = "sss111" />
	</bean>
	
	<bean id = "db2" class = "com.spring.basic.ex02.DataBaseInfo">
		<property name = "url" value = "jdbc:mysql://localhost:3306/practice" />
				<!--  setter에 해당하는 field이름을 name에 적는다. -->
		<property name = "uid" value = "root" />
		<property name = "upw" value = "mysql" />
	</bean>
	
	
</beans>


package com.spring.basic.ex02;

import org.springframework.context.support.GenericXmlApplicationContext;

public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
//		DataBaseInfo dbInfo = new DataBaseInfo();
//		dbInfo.setUid("spring1");
//		dbInfo.setUpw("sss111");
//		dbInfo.setUrl("jdbc:mysql://localhost:3306/spring");
		
		//위처럼하면 귀찮고 보안위험있으니 설정으로 해보자
		
		GenericXmlApplicationContext ct =
				new GenericXmlApplicationContext("classpath:db-config.xml");
		DataBaseInfo db1 = ct.getBean("db1", DataBaseInfo.class);
		
		System.out.println("URL : " + db1.getUrl());
		System.out.println("UID : " + db1.getUid());
		System.out.println("UPW : " + db1.getUpw());
		
	
		DataBaseInfo db2 = ct.getBean("db2", DataBaseInfo.class);
		System.out.println("URL : " + db2.getUrl());
		System.out.println("UID : " + db2.getUid());
		System.out.println("UPW : " + db2.getUpw());
	}

}















##############################################################################
5)setter를 통한 의존성 주입(class 자료형 객체 주입)

1)클래스 MemberDAO를 만들고(아래코드) main코드를 db-config.xml 설정을 이용해서 db객체를 의존성주입하도록 만들어라


package com.spring.basic.ex02;

public class MemberDAO {
	private DataBaseInfo dbInfo;
	
	public void setDbInfo(DataBaseInfo dbInfo) {
		this.dbInfo = dbInfo;
	}
	
	public void showDBInfo() {
		System.out.println("URL: " + dbInfo.getUrl());
		System.out.println("UID: " + dbInfo.getUid());
		System.out.println("UPW: " + dbInfo.getUpw());
	}
}


package com.spring.basic.ex02;

import org.springframework.context.support.GenericXmlApplicationContext;

public class MainClass {

	public static void main(String[] args) {
		
		GenericXmlApplicationContext ct =
				new GenericXmlApplicationContext("classpath:db-config.xml");
		DataBaseInfo db1 = ct.getBean("db1", DataBaseInfo.class);
		DataBaseInfo db2 = ct.getBean("db2", DataBaseInfo.class);
		
		
		MemberDAO dao = new MemberDAO();
		dao.setDbInfo(db1);
		dao.showDBInfo();
		
	}

}


*property 할때 원래는 대부분 ref로 참조해야하지만 원시자료형, String정도는 바로 값을 넣을수 있도록 value를 지원하는거임

<출력결과>
URL: jdbc:mysql://localhost:3306/spring
UID: spring1
UPW: sss111
##############################################################################


답:


<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean id = "db1" class = "com.spring.basic.ex02.DataBaseInfo">
		<!--  setter 주입 -->
		<property name = "url" value = "jdbc:mysql://localhost:3306/spring" />
				<!--  setter에 해당하는 field이름을 name에 적는다. -->
		<property name = "uid" value = "spring1" />
		<property name = "upw" value = "sss111" />
	</bean>
	
	<bean id = "db2" class = "com.spring.basic.ex02.DataBaseInfo">
		<property name = "url" value = "jdbc:mysql://localhost:3306/practice" />
				<!--  setter에 해당하는 field이름을 name에 적는다. -->
		<property name = "uid" value = "root" />
		<property name = "upw" value = "mysql" />
	</bean>
	
	<bean id = "dao" class = "com.spring.basic.ex02.MemberDAO">
		<property name = "dbInfo" ref = "db1" />
	</bean>
	
</beans>

package com.spring.basic.ex02;

import org.springframework.context.support.GenericXmlApplicationContext;

public class MainClass {

	public static void main(String[] args) {
		GenericXmlApplicationContext ct =
				new GenericXmlApplicationContext("classpath:db-config.xml");

		MemberDAO dao = ct.getBean("dao", MemberDAO.class);
		dao.showDBInfo();
		
	}

}














##############################################################################
6)setter를 통한 의존성 주입(class 자료형 객체 주입)

1)3번문제에서 풀었던 com.spring.basic.ex01.Restaurant class의 생성자를 없애고 해당 패키지의 MainClass에서 실행시켜라
그러면 xml에서 error가 나는데 그 에러내용은 생성자매개변수를 매칭할수있는 생성자가 클래스에 없다고 된다.
그것을 setter로 바꿔바라

아래는 기존내용 코드다

#test-config.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd">
	<bean id = "test" class = "com.spring.basic.SpringTest" />
	
	<!--  Hotel 객체와 의존객체들의 빈 등록 및 의존성 주입설정 -->
	<bean id = "chef" class = "com.spring.basic.ex01.Chef" />
	<bean id = "res" class = "com.spring.basic.ex01.Restaurant" >
		<constructor-arg ref = "chef" />
	</bean>
	<bean id = "hotel" class = "com.spring.basic.ex01.Hotel" >
		<constructor-arg ref = "res" />
	</bean>
</beans>




package com.spring.basic.ex01;

public class Restaurant {
	private Chef chef;
	
	public Restaurant(Chef chef) {
		// TODO Auto-generated constructor stub
		this.chef = chef;
		
		System.out.println("레스토랑이 생성됨!");
	}
	
	public void orderDinner() {
		System.out.println("저녁식사를 주문합니다.");
		chef.cook();
	}
}

##############################################################################


답:

#test-config.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd">
	<bean id = "test" class = "com.spring.basic.SpringTest" />
	
	<!--  Hotel 객체와 의존객체들의 빈 등록 및 의존성 주입설정 -->
	<bean id = "chef" class = "com.spring.basic.ex01.Chef" />
	<bean id = "res" class = "com.spring.basic.ex01.Restaurant" >
		<!--  <constructor-arg ref = "chef" /> -->
		<property name = "chef" ref = "chef" />
	</bean>
	<bean id = "hotel" class = "com.spring.basic.ex01.Hotel" >
		<constructor-arg ref = "res" />
	</bean>
</beans>



package com.spring.basic.ex01;

public class Restaurant {
	private Chef chef;
	
//	public Restaurant(Chef chef) {
//		// TODO Auto-generated constructor stub
//		this.chef = chef;
//		
//		System.out.println("레스토랑이 생성됨!");
//	}
	
	public void setChef(Chef chef) {
		this.chef = chef;
	}
	
	public void orderDinner() {
		System.out.println("저녁식사를 주문합니다.");
		chef.cook();
	}
}

















##############################################################################
7)bean객체의 싱글톤 기본설정 및 변경

di를 이용하면 객체는 항상 싱글톤이다.
싱글톤이 아니게하여서 아래처럼 bean이 여러 객체를 만들수있게하라
1)아래 main의 주석을 처리하라

#prototype-config.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd">
	<bean id = "person" class = "com.spring.basic.ex03.Person">
		<property name = "name" value = "홍길동" />
		<property name = "age" value = "20" />
	</bean>
	

</beans>



package com.spring.basic.ex03;

public class Person {
	private String name;
	private Integer age;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Integer getAge() {
		return age;
	}
	public void setAge(Integer age) {
		this.age = age;
	}
	
	
}



package com.spring.basic.ex03;

import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;
import org.springframework.context.support.GenericXmlApplicationContext;

public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		GenericXmlApplicationContext ct =
				new GenericXmlApplicationContext("classpath:prototype-config.xml");
		
		Person hong = ct.getBean("person", Person.class);
		Person kim = ct.getBean("person", Person.class);
		
		System.out.println("hong의 주소 : " + hong);
		System.out.println("kim의 주소 : " + kim);
		System.out.println("hong과 kim은 같은 객체인가 ? : " + (hong == kim));
		
		kim.setName("김철수");
		kim.setAge(30);
		
		//kim만 이름나이 바꾸고 싶은데 싱글톤이라서 hong의 이름과 나이도 김철수와 30세가 된다..
		//싱글톤이 아니게해서 아래 문제를 푼뒤 출력결과처럼 나오게 하여라
		
		System.out.println("hong의 이름: " + hong.getName());
		System.out.println("hong의 나이: " + hong.getAge());
		System.out.println("kim의 이름: " + kim.getName());
		System.out.println("kim의 나이: " + kim.getAge());
	}

}

<현재 위 문제코드 출력결과> : main의 코드는 그대로두고 prototype-config.xml의 답만 변경하면 된다.

hong의 주소 : com.spring.basic.ex03.Person@56ac3a89
kim의 주소 : com.spring.basic.ex03.Person@56ac3a89
hong과 kim은 같은 객체인가 ? : true
hong의 이름: 김철수
hong의 나이: 30
kim의 이름: 김철수
kim의 나이: 30

<문제를 푼뒤 출력결과(답의 출력결과)>
hong의 주소 : com.spring.basic.ex03.Person@1ce92674
kim의 주소 : com.spring.basic.ex03.Person@5700d6b1
hong과 kim은 같은 객체인가 ? : false
hong의 이름: 홍길동
hong의 나이: 20
kim의 이름: 김철수
kim의 나이: 30


##############################################################################


답:

***scope만 변경하면 됨 : 원래는 scope = "singleton"으로 기본값설정되어있다.

#prototype-config.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd">
	<bean id = "person" class = "com.spring.basic.ex03.Person" scope = "prototype">
		<property name = "name" value = "홍길동" />
		<property name = "age" value = "20" />
	</bean>
	

</beans>












##############################################################################
8)의존객체 자동주입
	-constructor-arg 또는 property 없이도 알아서 java코드를보고 spring이 의존객체를 자동주입시켜주는 것을 뜻한다

아래코드는 잘된다

<package 생성> : com.spring.basic.ex04
<Class 생성> : Printer, Paper(아래코드)


package com.spring.basic.ex04;

public class Paper {
	public String[] data = {
			"스프링 프레임워크", 
			"자동객체 주입",
			"Autowired는 객체의 타입을 검색하여 자동 주입"
	};
}



package com.spring.basic.ex04;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

public class Printer {
	private Paper paper;
	

	public Printer(Paper paper) {
		// TODO Auto-generated constructor stub
		this.paper = paper;
	}
	
	public void setPaper(Paper paper) {
		this.paper = paper;
	}
	
	
	public void showPaperInfo() {
		for (String info : paper.data) {
			System.out.println(info);
		}
	}
}


package com.spring.basic.ex04;

public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Printer printer = new Printer(new Paper());
		printer.showPaperInfo();
	}

}

1)위의 구시대적인 MainClass의 코드를 auto-config.xml을 이용하여 설정하라 


2)위의 거에서 constructor-arg 없이 자동주입하라
	-이때 생성자, 필드, 메서드 3개에 다 스캔해바라

*아래 코드로 두줄을 beans에 수정해야 자동스캔명령추가 태그를 사용가능해진다.
	-자동스캔명령추가가 해당 bean들을 만들다가 의존성이 발생하면 알아서 자동스캔해서 주입하라는 명령인것같고
		여기서 Autowired를 사용해서 자동스캔위치를 정해주는 듯

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
	http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context-4.3.xsd">
</beans>




3)위 2번답에서 auto-config.xml에 paper를 paper, paper2로 나눈뒤(아래코드참고)
	autowired가 같은 타입이 두개있을시에 beanid를 보고 찾아가서 실행한다는 개념을 이해하고
	그후 bean id가 paper인 놈을 paper1로 바꾸고 타입도 id로도 찾을수 없는 경우를 만들어라
	그리하여 paper1,paper2중 하나를 골라달라는 에러를 보고 처리해라.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
	http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context-4.3.xsd">

	<!--  자동스캔 명령 추가 -->
	<context:annotation-config />
	
	<bean id = "paper" class = "com.spring.basic.ex04.Paper" />
	<bean id = "paper2" class = "com.spring.basic.ex04.Paper" />

	<bean id = "printer" class = "com.spring.basic.ex04.Printer">
		<!--  <constructor-arg ref = "paper" />  -->
	</bean>
	

</beans>

******Autowired 
-객체를 자동 주입할때 사용하는 아노테이션
-스캔명령을 통해 객체를 찾아 주입하는데 타입이름으로 검색
-타입을 찾아내지 못하면 이름(id속성값)을 통해 검색
	-타입이 2개이상있다면 이름을 검색하여 일치하는 이름의 bean객체를 주입한다.
	-하지만 이름까지도 같은게 없으면 에러난다. 이때는 같은 타입객체 두개중 누구인지 이름을 따로알려주는 Qualifier를 사용해야함
-생성자, 필드, 메서드에 적용 가능

*****Qualifier("bean id")
-Autowired를 사용할때 동일 타입의 빈이 여러개 있을경우 어떤 빈을 주입해야하 하는지 선택해주는 추가 아노테이션
					(여러개있고 매개변수와 같은 beanid까지도 찾을수없는경우)
-qualifier + autowired로 필드에 자동주입 설정을 수행할때는 기본생성자가 반드시 있어야함


##############################################################################


답:

1)
#auto-config.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd">
	<bean id = "paper" class = "com.spring.basic.ex04.Paper" />

	<bean id = "printer" class = "com.spring.basic.ex04.Printer">
		<constructor-arg ref = "paper" />
	</bean>
	

</beans>



package com.spring.basic.ex04;

import org.springframework.context.support.GenericXmlApplicationContext;

public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		GenericXmlApplicationContext ct = 
				new GenericXmlApplicationContext("classpath:auto-config.xml");
		
		
		Printer printer = ct.getBean("printer", Printer.class);
		printer.showPaperInfo();
	}

}


2)위의 거에서 contructor-arg 없이 자동주입하라

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
	http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context-4.3.xsd">

	<!--  자동스캔 명령 추가 -->
	<context:annotation-config />
	
	<bean id = "paper" class = "com.spring.basic.ex04.Paper" />

	<bean id = "printer" class = "com.spring.basic.ex04.Printer" />
		<!--  <constructor-arg ref = "paper" />  -->
		

</beans>


package com.spring.basic.ex04;

import org.springframework.beans.factory.annotation.Autowired;

public class Printer {
	@Autowired
	private Paper paper;
	
	@Autowired // ctrl shift o 하면 자동 import 됨	
	public Printer(Paper paper) {
		// TODO Auto-generated constructor stub
		this.paper = paper;
	}
	
	
	@Autowired // 위의 생성자 혹은 필드, 메소드(setter) 다 가능	
	public void setPaper(Paper paper) {
		this.paper = paper;
	}
	
	public void showPaperInfo() {
		for (String info : paper.data) {
			System.out.println(info);
		}
	}
}



3)



<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
	http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context-4.3.xsd">

	<!--  자동스캔 명령 추가 -->
	<context:annotation-config />
	
	<bean id = "paper1" class = "com.spring.basic.ex04.Paper" />
	<bean id = "paper2" class = "com.spring.basic.ex04.Paper" />

	<bean id = "printer" class = "com.spring.basic.ex04.Printer">
		<!--  <constructor-arg ref = "paper" />  -->
	</bean>
	

</beans>




package com.spring.basic.ex04;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

public class Printer {
	@Autowired
	@Qualifier("paper1")
	private Paper paper;
	
	public Printer() { // 반드시 해당 기본생성자가 있어야 Autowired + qualifier 조합 사용가능하다
		super();		//추가실험해보니 autowired는 기본생성자 없어도 쓸수있더라
	}
	
//	@Autowired // ctrl shift o 하면 자동 import 됨
//	@Qualifier("paper1") Qualifier는 생성자는 안됨으로 여기서는 에러난다.
	public Printer(Paper paper) {
		// TODO Auto-generated constructor stub
		this.paper = paper;
	}
	
//	
//	@Autowired // 위의 생성자 혹은 필드, 메소드(setter) 다 가능
//	@Qualifier("paper1")
	public void setPaper(Paper paper) {
		this.paper = paper;
	}
	
	
	public void showPaperInfo() {
		for (String info : paper.data) {
			System.out.println(info);
		}
	}
}













##############################################################################
9)의존객체 자동주입 - 아노테이션_Resource

Book클래스를 만들어라(아래코드)
1)그리고 해당 코드를 auto-config.xml을 조작하여(2번답인 코드인상태에서 조작하면됨) 2개의 아노테이션으로 문제를 해결하라
	-아래 autowired와 resource의 공통점을 보고 매개변수가 있는 생성자의 여부에따라 기본생성자를 어떻게 해야하는지도 확인해라

package com.spring.basic.ex04;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

public class Book {
	
	private Paper paper;

	public Paper getPaper() {
		return paper;
	}


	public void setPaper(Paper paper) {
		this.paper = paper;
	}
	
	

}

package com.spring.basicReview.ex04;

import java.util.Arrays;

import org.springframework.context.support.GenericXmlApplicationContext;

public class MainClass {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		GenericXmlApplicationContext ct =
				new GenericXmlApplicationContext("classpath:auto-config.xml");
				
		Printer printer = ct.getBean("printer", Printer.class);
		printer.showPaperInfo();
		
		Book book = ct.getBean("book", Book.class);
		String data = Arrays.toString(book.getPaper().data);
		
		System.out.println(data);
	}
}




2)1번에서 두개의 아노테이션으로 처리했는데 하나로해봐라

***Autowired는 Spring 아노테이션이고 Inject는 javaSE의 아노테이션임
		-즉 아무거나해도되는데 상사가쓰는거 따라보고함
***Resource
	-Autowired + Qualifier를 합쳐놓은 것
	-사람들이 거의 안쓴다고한다. 자바 8버전에서까지만 사용가능
	-빈을 자동주입하는 아노테이션
	-필드, 메서드에만 적용이 가능하며 생성자에서는 적용불가능
		-이 특징은 autowired + qualifier 와 동일하지 않나?
			-확인결과 동일하게 안된다.
			
	-name속성을 통해 특정 bean의 id를 지정가능

*********그리고 auto + qualifier, resource 공통점
	-타입달라도 이름(bean id)으로 찝어서 주입가능
	-생성자 앞에서 스캔불가
	-매개변수가 있는 생성자 없으면 기본 생성자없이도 실행가능
	-매개변수가 있는 생성자가 있으면 기본 생성자가 있어야지만 실행가능

##############################################################################


답:

#auto-config.xml

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
	http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context-4.3.xsd">

	<!--  자동스캔 명령 추가 -->
	<context:annotation-config />
	
	<bean id = "paper1" class = "com.spring.basic.ex04.Paper" />
	<bean id = "paper2" class = "com.spring.basic.ex04.Paper" />

	<bean id = "printer" class = "com.spring.basic.ex04.Printer">
		<!--  <constructor-arg ref = "paper" />  -->
	</bean>
	
	<bean id = "book" class = "com.spring.basic.ex04.Book" />
</beans>




1)
package com.spring.basic.ex04;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

public class Book {
	
	private Paper paper;

	public Paper getPaper() {
		return paper;
	}

	@Autowired
	@Qualifier("paper1")
	public void setPaper(Paper paper) {
		this.paper = paper;
	}
	
	

}


2)

package com.spring.basic.ex04;

import javax.annotation.Resource;

public class Book {
	
	private Paper paper;

	Book () {
		
	}
	

	Book (Paper paper) {
		this.paper = paper;
	}
	public Paper getPaper() {
		return paper;
	}

	@Resource(name = "paper2")
//	@Autowired
//	@Qualifier("paper2")
	public void setPaper(Paper paper) {
		this.paper = paper;
	}
	
	

}










##############################################################################
10)자동객체주입

<패키지생성>
com.spring.basic.quiz

<클래스생성>
-위치 : com.spring.basic.quiz

-이름 : Moniter, Keyboard, Mouse
	LG 모니터! 삼성 키보드! 구글 마우스!
-기능 : 각 인스턴스의 브랜드 정보를 출력하는 info() 메서드 구현
	-interface 쓰지말고 그냥해라 그게 중요한게하니다 지금
-필드 : 필요없음

-이름 : Computer
-field : Moniter, Keyboard, Mouse 타입의 monitor, keyboard, mouse 인스턴스 주소를 담을 private한 변수
-기능 : computerInfo() 메서드를 통해 "*** 컴퓨터 정보 ***"를 출력한 뒤 위 3개의 인스턴스에 대해 info() 메서드를 
	호출하는 기능을 구현

+MainClass 생성

<xml 생성> : quiz-config.xml


1.quiz-config.xml에 Monitor, Mouse, Keyboard, Computer 빈을 생성후
2.Computer 클래스에서 자동 주입을 설정하세요.
3.xml에서 빈을 얻은 후 computerInfo()메서드를 실행하세요.


1)위 조건의 답중 Computer에 자동주입 아노테이션을 넣을때는 두가지방식으로 풀어라
1-1)아노테이션 각필드에 하나식 이용
1-2)아노테이션 단하나만 이용 


***1-2)단점 문제다풀고 읽을 것!!!
	-1-2)처럼 하면 Autowired + Qualifier 콤보를 사용할수 없음
	@Autowired
	@Qualifier("bean id")
	private Monitor monitor;
	
	@Autowired
	@Qualifier("bean id")
	private Keyboard keyboard;
	
	@Autowired
	@Qualifier("bean id")
	private Mouse mouse;
##############################################################################


답:


1-1)
package com.spring.basic.quiz;

import org.springframework.beans.factory.annotation.Autowired;

public class Computer {
	
	@Autowired
	private Monitor monitor;
	
	@Autowired
	private Keyboard keyboard;
	
	@Autowired
	private Mouse mouse;
	
	public Computer(Monitor monitor, Keyboard keyboard, Mouse mouse) {
		super();
		this.monitor = monitor;
		this.keyboard = keyboard;
		this.mouse = mouse;
	}

	public Computer() {
		// TODO Auto-generated constructor stub
	}
	
	public void computerInfo() {
		System.out.println("*** 컴퓨터 정보 ***");
		monitor.info();
		keyboard.info();
		mouse.info();
	}

}



1-2)
package com.spring.basic.quiz;

import org.springframework.beans.factory.annotation.Autowired;

public class Computer {
	
	private Monitor monitor;
	private Keyboard keyboard;
	private Mouse mouse;
	
	@Autowired	
	public Computer(Monitor monitor, Keyboard keyboard, Mouse mouse) {
		super();
		this.monitor = monitor;
		this.keyboard = keyboard;
		this.mouse = mouse;
	}
	
	public void computerInfo() {
		System.out.println("*** 컴퓨터 정보 ***");
		monitor.info();
		keyboard.info();
		mouse.info();
	}

}

















































































21.02.06.3회차
===============================================================================
*STS 및 톰캣(설치,구동),pom,web,HomeController,home.jsp,MVC출력흐름(URI)
===============================================================================























































##############################################################################
11)STS 및 톰캣 설치 후 구동

**이클립스는 20년 9월버전부턴 java 8버전사용못하니 20년 6월을 받아야한다.
	18년꺼는 썻더니 조회가 안된다. 그래서 20년 6월쯤받으면 될듯

STS 설치
	-eclipse marketplace : sts -> 3버전으로 설치
	-프로그램 껏다 키고나서 perspective에 spring 생겼나보고 생겼으면 그걸로 교체
	


톰캣 설치
	-톰켓 홈페이지가서 9버전 설치
		-이때 tomcat위치는 원하는곳으로하되 tomcat 폴더가 두개 겹치지 않게 잘라내서 다시 붙여넣기 ㄱㄱ
	-이클립스 spring으로 바꿨으면 아래 servers텝이 따로 분리되어있는데 거기 클릭해서 서버추가(톰켓폴더통째로 선택하면됨)

톰캣 설정
	-톱캣 더블클릭 server위치찾는곳에서 중간꺼(톰켓 설치되어있는 곳이 서버위치라고 하는 뜻임) 클릭
	-server options에서 publicsh module 2번재거(안전을위해서? 라고함)
	-포트번호는 확인만해라
	-저장
	-그후 servers 텝에 서버시작버튼있는 곳 가장 오른쪽에 설정 톰켓에 적용시키기 클릭
	-eclipse menu중 window의 web browser의 기본설정을 Chrome으로 변경

톰캣 구동
	-서버 시작 버튼 누르기
	-크롬에서 url입력창에 http://localhost:8080 해서 고양이 화면 나오면 성공!



STS 파일 생성 : spring legacy project로 해야함
	-프로젝트이름 : SpringWebBasic
	-groupid : com.spring
	-아티팩트 : web
		-즉 top-level package 이름지어달라할때 com.spring.web 이렇게하면 됨



##############################################################################


답: 답없음 똑같이하면됨











##############################################################################
12)STS 기본설정을 내 입맛대로 변경하여 재설치 및 업데이트(pom.xml)



** 현재 내피시 자바버전 : 1.8
	-cmd에 java -version 치면나옴


#pom.xml

1)먼저 내 artifactid, groupid, 프로젝트이름이 맞게 되어있는지 확인
	-gid : com.spring
	-artifactid : web

2)스프링 legacy project 만들때 만들어짐 pom.xml파일은 java 버전이나 다른 필요한것들이 나의 상황 또는 목적과 다르게 기본
세팅된다. 이걸 바꾸자.
	-즉 STS에서 초기에 설정해주는 툴을 내 입맛대로 조금식 바꾸는 거다.

-자바버전 1.8
-스프링프레임워크 버전 5.1.5.RELEASE
-dependencies 
	-version에 ${org.springframework-version} 의미는 위의 스프링프레임워크 버전과 맞추겠다는의미임
		-왜냐하면 이걸안하면 스프링프레임워크는 버전이 높은데 그에 관련된 라이브러리 설치할때는 버전이 안맞아질수도 있으니
			항상 똑같이 하기 위해서임
	-86번 @inject 주석 확인
		-2강에서 설명한 autowired와 inject의 차이임
			-autowired: 스프링에서만든거
			-injext: java에서 만든거 -> 그래서 그룹아이디도 javax 머시기고 이게 있어서 모듈을 불러와야
				사용가능 기능은 둘다 똑같다.
	-93번 servlet 주석아래 dependency 버전변경 
		-2.5 -> 3.1.0
		-3.1.0으로 변경되면서 추가로 바뀐점이 있어서 그부분도 설정을 변경해야한다.
			-그 바뀐것은 바로 artifactId로서 기존엔 servlet-api -> javax.servlet-api

-바로아래에 jsp와 jstl은 업뎃안된지 이미 10년 가까이 되어서 그대로 두면됨
	-특히 jsp가 요즘 안쓰여서 spring boot project에서는 jsp쓸려면 따로 설정해야함. 근데 우리 레거시에서는 jsp로 쓴다.


-build태그내(120)의 136번 plugin 태그 : maven compiler에 관한 태그
	-compiler version : 2.5.1 -> 3.5.1로 변경
	-java version(source, target 태그말하는거임) : 1.8(내피시버전)
		-위 두 버전변경은 1,2강에서 했던 maven 프로젝트에서도 똑같이 3.5.1에 자바 1.8버전을 썼다.


-이럼 변경할설정 다 변경한거고 저장(ctrl s)해서 위에서 추가시킨 버전과 설정으로 새로 다운로드(업데이트)시켜주고 maven에 업데이트해줘야함
	-근데 maven 업데이트되는등 maven 기능 다쓸수있는데 왜굳이 1,2강에선 maven project를 만들걸까?

-그후 MavenDependencies의 spring, servlet, jsp, jstl 등등 잘변경또는 있는지 확인

##############################################################################


답:


<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/maven-v4_0_0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>com.spring</groupId>
	<artifactId>web</artifactId>
	<name>SpringWebBasic</name>
	<packaging>war</packaging>
	<version>1.0.0-BUILD-SNAPSHOT</version>
	<properties>
		<java-version>1.8</java-version>
		<org.springframework-version>5.1.5.RELEASE</org.springframework-version>
		<org.aspectj-version>1.6.10</org.aspectj-version>
		<org.slf4j-version>1.6.6</org.slf4j-version>
	</properties>
	<dependencies>
		<!-- Spring -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
			<version>${org.springframework-version}</version>
			<exclusions>
				<!-- Exclude Commons Logging in favor of SLF4j -->
				<exclusion>
					<groupId>commons-logging</groupId>
					<artifactId>commons-logging</artifactId>
				 </exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>${org.springframework-version}</version>
		</dependency>
				
		<!-- AspectJ -->
		<dependency>
			<groupId>org.aspectj</groupId>
			<artifactId>aspectjrt</artifactId>
			<version>${org.aspectj-version}</version>
		</dependency>	
		
		<!-- Logging -->
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-api</artifactId>
			<version>${org.slf4j-version}</version>
		</dependency>
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>jcl-over-slf4j</artifactId>
			<version>${org.slf4j-version}</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-log4j12</artifactId>
			<version>${org.slf4j-version}</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>log4j</groupId>
			<artifactId>log4j</artifactId>
			<version>1.2.15</version>
			<exclusions>
				<exclusion>
					<groupId>javax.mail</groupId>
					<artifactId>mail</artifactId>
				</exclusion>
				<exclusion>
					<groupId>javax.jms</groupId>
					<artifactId>jms</artifactId>
				</exclusion>
				<exclusion>
					<groupId>com.sun.jdmk</groupId>
					<artifactId>jmxtools</artifactId>
				</exclusion>
				<exclusion>
					<groupId>com.sun.jmx</groupId>
					<artifactId>jmxri</artifactId>
				</exclusion>
			</exclusions>
			<scope>runtime</scope>
		</dependency>

		<!-- @Inject -->
		<dependency>
			<groupId>javax.inject</groupId>
			<artifactId>javax.inject</artifactId>
			<version>1</version>
		</dependency>
				
		<!-- Servlet -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>3.1.0</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet.jsp</groupId>
			<artifactId>jsp-api</artifactId>
			<version>2.1</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jstl</artifactId>
			<version>1.2</version>
		</dependency>
	
		<!-- Test -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.7</version>
			<scope>test</scope>
		</dependency>        
	</dependencies>
    <build>
        <plugins>
            <plugin>
                <artifactId>maven-eclipse-plugin</artifactId>
                <version>2.9</version>
                <configuration>
                    <additionalProjectnatures>
                        <projectnature>org.springframework.ide.eclipse.core.springnature</projectnature>
                    </additionalProjectnatures>
                    <additionalBuildcommands>
                        <buildcommand>org.springframework.ide.eclipse.core.springbuilder</buildcommand>
                    </additionalBuildcommands>
                    <downloadSources>true</downloadSources>
                    <downloadJavadocs>true</downloadJavadocs>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.5.1</version>
                <configuration>
                    <source>1.8</source>
                    <target>1.8</target>
                    <compilerArgument>-Xlint:all</compilerArgument>
                    <showWarnings>true</showWarnings>
                    <showDeprecation>true</showDeprecation>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>exec-maven-plugin</artifactId>
                <version>1.2.1</version>
                <configuration>
                    <mainClass>org.test.int1.Main</mainClass>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>










##############################################################################
13)tomcat 서버에 프로젝트 이관하기 및 context root 찾아서 접근하기

context root를 찾기위해
	-이걸알아야 서버에 접근해서 특정 페이지를 보기위해

-톰캣서버가 SpringWebBasic 프로젝트를 관리하도록해라
	-servers 탭의 생성한 9.0서버 우클릭 add and remove -> project 클릭 후 add finish
	-그 후 설정반영버튼 클릭
-Servers project 클릭 
	-내부 톰캣 9.0 폴더 아래 보이기
	-server.xml 열기 : context root 등록을 하는 곳이 이곳이다.
		-젤아래 context 태그에 docBase는 SpringWebBasic이고 path는 /artifactid 형태로초기에
			설정되며 이게 context root다.
			-이 context root는 바꿔도 된다. 없애도됨.
				-근데 왜필요한가?
				-톰켓이 여러개의 어플리케이션(docBase)을 관리할수 있는데 걔들을 구분하기 위해서
				 context root를 두고 톰켓 하나가 하나의 어플리케이션만 관리할 경우(서비스를 제공할경우)
				 없애는 경우가 많다.
-위 server.xml에서 context root를 알아냈으면 크롬에서 http://localhost:8080/web 을 검색해서 
	Hello world!
	The time on the server is 2022? 2? 5? (?) ?? 4? 32? 47?.
 와 같은 웹페이지가 나오는지 확인해라
	-첨에 페이지 안나오는 에러나오면 아래를 참고해라. jstl이 tomcat의 lib에 없다는 소리임

https://gaga.tistory.com/m/40 -> [500 에러] 절대 URI인 [http://java.sun.com/jsp/jstl/core]을(를), web.xml 또는 이 애플리케이션과 함께 배치된 JAR 파일 내에서 찾을 수 없습니다.
				-위 에러를 해당 페이지에서 고침
				-jstl-1.2.jar를 폴더경로 찾아가서 복사한뒤 tomcat 폴더에 lib로 가서 붙여넣기해주면해결!
					-근데 왜 강사님이랑 학생들은 문제없이 다 됐는데 나만 에러가 됐을까? 슬슬 불안하다.
						후반부에 뭔일날거같다..
##############################################################################


답: 없음 그냥 해보면 됨





















##############################################################################
14)web.xml 설정(mvc관련스프링설정파일,서블릿설정파일,서블릿처리범위)

6번줄 param태그
	- mvc와 관련된 스프링 설정파일의 위치를 적어놓은것임
		- 그쪽(root-context.xml)을 다라가면 bean이 나온다.
	- root-context.xml을 mvc-config.xml로 이름변경
		- 서버 재실행 후 12번에서 잘들어가졌던 홈페이지가 안들어가지는것을 확인
		- 즉 http://localhost:8080/web가 이름바꾸기전엔 hello world하며 나왔는데 그게
			이름바꾸고나선 안됨. 
			- 아 이게 서버 접근과 관련된 것이구나~ 하고 느껴라
				1)이거 안되는 문제를 고쳐라
					-답 : web.xml(of SpringWebBasic)에서 변경된 이름으로
						설정된 파일 위치를 다시 알려주면 됨

20번줄 servlet 태그 : 디스패쳐 서블릿 등록 설정
	-디스패쳐 : mvc패턴에서 브라우저의 모든 요청을 하나의 서블릿이 받는 front controller의 역할을
		하는데 이때 그 서블릿 이름이 디스패쳐
		-그런데 이 디스패쳐는 우리가 만들필요 없이 해당 서블릿 클래스를 이미 스프링프레임워크에서 만들어
			놓았다. 
	-22번줄 <servlet-class> 태그 
	-해당 서블릿의 이름은 appServlet 21번줄
	-27번줄 <load-on-startup>1 : 서블릿중 가장먼저 실행시키겠다는 의미
		-여러개있을때 효과적으로 사용됨 1개 있을땐 사실상 의미 없음
	-<init-param> : 초기화 파라미터
		-서블릿이 실행됐을 때 어떤 설정파일을 읽을 것인가에 대한 내용임
		-<param-value> 태그의 위치를 따라가서 설정파일엔 뭐가 있는가 확인하자
			-여기도 beans가 있네(servlet-context.xml) 즉 bean을 등록하는 역할을 하는 곳이란 것이다.
			-해당 파일의이름 변경
				-servlet-context.xml -> servlet-config.xml
			-해당 파일의 경로변경
				-appServlet내에 있던 해당파일을 상위폴더인 spring내부로 옮기고 appServlet 폴더를
					삭제
			2)이렇게 했을때 인터넷연결안되는데 문제를 해결하라
			-답:web.xml에서 param-value의 경로를 
			<param-value>/WEB-INF/spring/appServlet/servlet-context.xml</param-value>
			에서 
			<param-value>/WEB-INF/spring/servlet-config.xml</param-value>
			로 바꾸면 됨

30번줄 <servlet-mapping>태그
	-<servlet-name> 태그의 appServlet은 위의 서블렛 네임을 뜻한다.
		-3)<servlet>태그의 <servlet-name>을 banana로 변경한뒤 연결문제를 해결하라
			답: mapping의 servlet-name 태그의 이름도 banana로 바꾸면 됨

	-<url-pattern>태그 : url들어오는것중 여기서 설정한 url 부분을 현재 servlet mapping된 banana가 처리하도록
		하겠다라는 의미
		즉 <url-pattern>/</url-pattern> 면 /로 오는 모든걸 처리하겠다는 뜻임. 즉 디스패쳐 서블릿이니까 모든걸
		처리하겠다는것이고 그렇기에 front controller를 만들 필요가 없는 것임
			-회원관리든 게시판관련 요청이든 모두 ㅇ디스패쳐 서블릿으로 오는 것이다.
		-ex)
			<url-pattern>/hello</url-pattern> : /hello url을 banana 서블릿이 처리하게 하겠다.
			<url-pattern>*.do</url-pattern> : .do로 끝나는걸 banana 서블릿이 처리하게 하겠다.

	-해당 줄 변경이 끝나면 바나나는 실습을 위해 변경한것이니 원래이름인 appServlet으로 변경해라 다시
##############################################################################


답:






#web.xml

<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">

	<!-- mvc와 관련된 스프링 설정파일의 위치를 지정하는 태그 -->
	<!-- The definition of the Root Spring Container shared by all Servlets and Filters -->
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/spring/mvc-config.xml</param-value>
	</context-param>
	
	<!-- Creates the Spring Container shared by all Servlets and Filters -->
	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>

	<!--  디스패쳐 서블릿 등록 설정 -->
	<!-- Processes application requests -->
	<servlet>
		<servlet-name>appServlet</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>/WEB-INF/spring/servlet-config.xml</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>
		
	<servlet-mapping>
		<servlet-name>appServlet</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping>

</web-app>











##############################################################################
15)서블릿설정파일 개념파악

#src.main.webapp.WEB-INF.spring의 servlet-config.xml 파일임

<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/mvc"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:beans="http://www.springframework.org/schema/beans"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd
		http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

	<!-- DispatcherServlet Context: defines this servlet's request-processing infrastructure -->
	
	
	<!--  DispatcherServlet 관련 설정 -->
	<!-- Enables the Spring MVC @Controller programming model -->
	
	<annotation-driven />
		<!-- 아노테이션을 통한 자동 빈 주입 명령을 처리하는 태그  -->
		<!-- 위 아노테이션드라이븐이 <context:annotaion-config /> 랑 똑같은거임-->
		
	<!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources directory -->
	<!--  정적자원(html, css, img, js)을 절대경로로 쉽게 매핑하는 태그 -->
	<resources mapping="/resources/**" location="/resources/" />


	<!-- 뷰 리졸버 빈 등록 설정 -->
	<!-- Resolves views selected for rendering by @Controllers to .jsp resources in the /WEB-INF/views directory -->
	<beans:bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<beans:property name="prefix" value="/WEB-INF/views/" />
		<beans:property name="suffix" value=".jsp" />
	</beans:bean>
	
	<!--  아노테이션을 사용하여 자동으로 빈 등록을 하게 해주는 설정 태그 -->
	<context:component-scan base-package="com.spring.web" />
		
	
	
</beans:beans>


##############################################################################


답: 위에 한글주석내용은 다 추가로 달린것이니 눈으로 확인하고 넘어가라























##############################################################################
16)context root 입력했을시 출력되는 화면 원리(mvc패턴 흐름)

*****인터넷의 context root(http://localhost:8080/web)을 입력했을때 정보가 출력되게하는 핵심개념은
 com.spring.web의 HomeController, src.main.webapp.WEB-INF.views의 home.jsp임

****연결된 우리서버내 SpringWebBsic 홈페이지의 페이지소스보기를 하면 home.jsp 거의 똑같음

1-1)HomeController.java 와 home.jsp를 동시에 켜놓고 class의 method home()의 리턴값 "home"
	을 "test"로 변경한 뒤 새로고침 해보시오.
	-그리하면 /WEB-INF/views/test.jsp를 찾을수없다고 나온다. 즉 여기서 리턴하는 값뒤에 .jsp를 붙여서
		해당 파일을 찾아가는 것이다. HomeController.java가 먼저 실행되고 리턴값에 .jsp를통해
		home.jsp를 실행하고 home에서는 12번줄에서 serverTime으로 세션처럼 값을 전해받아서 현재시각을 뛰우는 원리이다.

1-2)위 문제를 해결하시오
	-단, homecontroller.java는 손대지말고 home.jsp 파일을 이용해서 처리하시오
		답: home.jsp 파일의 이름을 test.jsp로 변경하면 됨

*문제를 푼 뒤엔 다시 home으로 돌려두시오 둘다


2)homecontroller.java 파일의 @RequestMapping(value = "/", method = RequestMethod.GET)에서
						// cf) 슬러쉬로 겟요청이 들어올시 해당 메서드를 작동시킨다는의미임
	@RequestMapping(value = "/test", method = RequestMethod.GET)
	로 변경한뒤 서버재시작후 http://localhost:8080/web 해보면 안될것이고
		http://localhost:8080/web/test하면 나오는 것을 확인하라
			즉 value의 값은 url에서 context root값 뒤에서부터 나오는 경로에 따라 반응을 하는 것이다.

*문제를 푼 뒤엔 다시 value를 /로 돌려나라


3)homecontroller가 동작을 수행하고나면 view 리절버로 "home" 값을 리턴한다.
	뷰리절버에 관련한 설정은 servlet-config에 있다. 
	<beans:bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<beans:property name="prefix" value="/WEB-INF/views/" />
		<beans:property name="suffix" value=".jsp" />
	</beans:bean>

	위에서 prefix는 ViewResorver로 반환된 값에 대한 접두어를 정의해놓은 것이고 suffix는 접미어를 정의해놓은 것으로
	최종적으로 /WEB-INF/views/home.jsp가 된다.
	그래서 home.jsp에 관한 bean을 생성한다는 것을 이해해라(view를 뷰리절브가 생성한 것이다)
	그후 view인 bean 객체가 브라우저(클라이언트)에게 답변한다.

	**젤첨엔 handle adapter가 uri를 보고 해당 uri를 처리하는 controller가 뭔지 알려주고
		그걸 handle mapping이 컨트롤러에 직접 연결한다.

4)그렇다면 디스패처 서블릿이 homecontroller를 어떻게 찾았을까? 
	-둘사이에 의존성이 있기 때문이다.의존관계가 있다.
	-어딘가에서 의존성 주입을 해야한다.
	-의존성주입이 되려면 homecontroller를 bean 객체로 만들어야하고 디스패쳐도 bean객체로 만들어야한다.		

4-1)beans graph 확인

	-그렇다면 두놈이 bean 객체로 만들어졌는지 함 보자! servlet-config.xml을 spring config editor로 들어가서 
		beans graph를 클릭하라
		-이클립스 20.6월버전하면 자바8에 호환되는 최신버전이긴하다만 spring config editor를 지원하지 않아서
			beans graph를 볼수 없다. 그러니 아랫버전사용해야하는데 나는 18.09버전을 사용했다.

4-2)beans graph 구성요소
	1)InternalResourceViewResolver
		-이놈은 servelet-config.xml의 27번쯤의 코드에서 bean을 등록하는 코드가 있으니 미래에 bean객체로
			 생겨난다는 의미이다.
			-참고로 어디다 의존성 주입할거아니면 27번쯤의 코드처럼 id를 생략해도 된다.
	2)homeController
		-이걸 디스패쳐가 찾을수 있었던 이유는 디스패쳐와 homecontroller가 의존성관계에 있기 때문이다.
		-이놈이 어덯게 빈으로 만들어 졌는가?
			-servlet-config.xml의 
				<context:component-scan base-package="com.spring.web" />
			 를 보면 요소 스캔을 하되 com.spring.web pacage에서 해라고 되어있고
			 com.spring.web.HomeController.java에 보면 @Controller라는 annotation이 있다.
			 즉 원래라면 <bean id = "home" class = "com.spring.web.HomeController" />
			 라고 있어야하는 빈등록코드가 위 context 태그와 아노테이션 controller덕분에 대체되었다는 뜻이다.

	3)annotation-driven mvcUriComponentsContributor




##############################################################################


답: 답이너무 간단해서 문제에 적어둠
















##############################################################################
17)context root 입력했을시 출력되는 화면 원리(mvc패턴 흐름)2

views 폴더에 test.jsp 생성

#test.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>안녕안녕 메렁메렁 ~~ </h2>
<p>
	오늘은 2022년 2월 7일 일요일 스프링 수업이야 ~~ <br>
	완전 재밌다!!
</p>

</body>
</html>




1)위상태에서 서버키고 http://localhost:8080/web/test를 하면 에러난다.
	컨텍스트루트 뒤에 /로 들어오는 놈은 home()메서드에서 다 처리하도록 해놨지만 /test를 처리할
	메서드를 만들지 않았기 때문이다.
	그럼 이제 위에 만든 test.jsp가 보여질수있도록 클라이언트가 검색했을때 /test를 HomeController에서 처리할수 
	있도록 하여라

##############################################################################


답: helloController만 손보면됨
	-그럼 리턴하는거 views폴더에서 출력하는거는 이미 설계되어있으니(servlet-config.xml) helloController만 만지면됨



package com.spring.web;

import java.text.DateFormat;
import java.util.Date;
import java.util.Locale;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

/**
 * Handles requests for the application home page.
 */
@Controller
public class HomeController {
	
	private static final Logger logger = LoggerFactory.getLogger(HomeController.class);
	
	/**
	 * Simply selects the home view to render by returning its name.
	 */
	@RequestMapping(value = "/", method = RequestMethod.GET)
	public String home(Locale locale, Model model) {
		logger.info("Welcome home! The client locale is {}.", locale);
		
		Date date = new Date();
		DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, locale);
		
		String formattedDate = dateFormat.format(date);
		
		//session.setAttribute //request.setAttribute 형태와 비슷함
		model.addAttribute("serverTime", formattedDate );
		
		
		return "home";
	}
	
	
	//test.jsp를 열기 위한 요청 메서드 구성
	@RequestMapping(value = "/test", method = RequestMethod.GET)
	// '/test'라는 요청이 get으로 들어오면 바로아래 메서드가 좀 처리해줘라고
	// 디스패쳐 서블릿에게 부탁하는 문구임
	public String test() { // 이름은 맘대로
		System.out.println("/test 요청이 들어옴 : GET방식!!!");
		return "test";
	}
}



















##############################################################################
18)클라이언트 측에서 요청을 보냈을때 그것을 처리하는 컨트롤러 만들기


packge 생성 : src/main/java에 com.spring.web.controller
controller 내부에 1번 class 생성

1)자동으로 스프링 컨테이너에 해당 클래스의 빈을 등록하는 아노테이션을 이용하여 spring container에 bean을 등록해라
	-등록하고나서 beans graph로 등록됐는지 확인하라

Class : RequestController
//디스패쳐서블릿이라는 프론트 컨트롤러가 RequestController를 찾게하려면
//디스패쳐서블릿과 requestController의 의존관계를 설정을 해야한다.
//의존관계설정을 우리가 따로할 필요는 없고 해당 클래스에 대한 빈객체를 실행시 만들어지게만 하면된다.
//근데 helloController는 빈등록 코드를 자동으로 이루어지게 했으니 다른 컨트롤러들도 
//자동 빈등록 코드와 아노테이션을 이용하여 만들면 된다.


2)http://localhost:8080/web/test/request/test로 검색했을때 test.jsp가 출력되도록 하라




	//RequestMapping은 어떤 URI로 이 메서드를 동작시킬 것인가에 대한 설정임
	//이거 value = "", GET 이런 설정안하면 post든 get이든 모두 받겠다는 의미임

<출력결과> uri가 /test일경우와 /request/test일 경우의 내부 출력결과
/test 요청이 들어옴 : GET방식!!!
/request/test 요청이 들어옴!

재밌는것이 controller가 homecontroller에서 test.jsp를 출력할수있고 RequestController에서도 test.jsp를 출력할수있다.

##############################################################################


답: RequestController.java만 만지면됨 


1)자동으로 스프링 컨테이너에 해당 클래스의 빈을 등록하는 아노테이션을 이용하여 spring container에 bean을 등록해라
	-등록하고나서 beans graph로 등록됐는지 확인하라

package com.spring.web.controller;

import org.springframework.stereotype.Controller;

@Controller	
public class RequestController {

}



2)http://localhost:8080/web/test/request/test로 검색했을때 test.jsp가 출력되도록 하라

package com.spring.web.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller	
public class RequestController {

	//RequestMapping은 어떤 URI로 이 메서드를 동작시킬 것인가에 대한 설정임
	//이거 value = "", GET 이런 설정안하면 post든 get이든 모두 받겠다는 의미임
	@RequestMapping("/request/test")
	public String testCall() {
		System.out.println("/request/test 요청이 들어옴!");
		return "test";
	}
}
















##############################################################################
19)uri에 따라서 특정 controller의 반환값 조절하여 jsp 파일 view로 응답하기

views 폴더 안에 request 폴더만들어라
request 폴더안에 req-ex01.jsp 만들어라

#req-ex01.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>Request컨트롤러를 이용한 요청 처리 작업</h2>
<p>- 컨틀롤러 테스트중입닏. </p>

</body>
</html>



1)만약 /request/req 요청이 들어왔을때 views폴더 아래에 있는 request 폴더 아래에 req-ex01.jsp파일을 열도록 메서드를
	구성해 보세요
	-단 RequestController.java를 이용한다
		-메서드이름: req

##############################################################################


답: 이것도 servlet-config.xml은 안만지고 RequestController만 만지면 된다




package com.spring.web.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

//클라이언트 측에서 요청을 보냈을때 그것을 처리하는 컨트롤러
//디스패쳐서블릿이라는 프론트 컨트롤러가 RequestController를 찾게하려면
//디스패쳐서블릿과 requestController의 의존관계를 설정을 해야한다.
//의존관계설정을 우리가 따로할 필요는 없고 해당 클래스에 대한 빈객체를 실행시 만들어지게만 하면된다.
//근데 helloController는 빈등록 코드를 자동으로 이루어지게 했으니 다른 컨트롤러들도 
//자동 빈등록 코드와 아노테이션을 이용하여 그러헥 만들면 된다.

@Controller	
public class RequestController {

	//RequestMapping은 어떤 URI로 이 메서드를 동작시킬 것인가에 대한 설정임
	//이거 value = "", GET 이런 설정안하면 post든 get이든 모두 받겠다는 의미임
	@RequestMapping("/request/test")
	public String testCall() {
		System.out.println("/request/test 요청이 들어옴!");
		return "test";
	}
	
	@RequestMapping("/request/req")
	public String req() {
		System.out.println("/request/req 요청이 들어옴~!");
		return "request/req-ex01";
	}
	
}







##############################################################################
20)하나의 uri로 두개의 결과물을 내는법
	-하나의 uri지만 get 또는 post전송방식의 차이에 따라서 두개의 결과물을 낼수 있다.

req-ex01.jsp에 코드를 추가해라
버튼 두개를 만들어서 GET요청누르면 get방식으로 /web/request/basic01이라는 uri로 보내고
POST요청누르면 post방식으로 /web/request/basic01라는 uri로 보내려한다.

1)이때 RquestController.java를 이용해서 두 메서드를 만들고 각각의 로그를 남기며 해당 페이지로 다시 보내라
	-이때 아노테이션을 스프링 4버전에서부터 나온 신기술을 사용해서도 풀어봐라
	-메서드이름 : basicGet(), basicPost()
		-원래는 두개다 이름같이해도되는데(get방식과 post방식의 매개변수가다르기때문에)
			지금은 실습이니까 그냥 이렇게 해라

	-내부로그
		-"/request/basic01요청이 들어옴: GET"
		-"/request/basic01요청이 들어옴: POST"


#/views/request/req-ex01.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>Request컨트롤러를 이용한 요청 처리 작업</h2>
<p>- 컨틀롤러 테스트중입닏. </p>

<form action = "/web/request/basic01" method = "get" >
	<p><input type = "submit" value = "GET요청!!"></p>
</form>

<form action = "/web/request/basic01" method = "post" >
	<p><input type = "submit" value = "POST요청!!"></p>
</form>

</body>
</html>


/request/basic




##############################################################################


답: 





package com.spring.web.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

//클라이언트 측에서 요청을 보냈을때 그것을 처리하는 컨트롤러
//디스패쳐서블릿이라는 프론트 컨트롤러가 RequestController를 찾게하려면
//디스패쳐서블릿과 requestController의 의존관계를 설정을 해야한다.
//의존관계설정을 우리가 따로할 필요는 없고 해당 클래스에 대한 빈객체를 실행시 만들어지게만 하면된다.
//근데 helloController는 빈등록 코드를 자동으로 이루어지게 했으니 다른 컨트롤러들도 
//자동 빈등록 코드와 아노테이션을 이용하여 그러헥 만들면 된다.

@Controller	
public class RequestController {

	//RequestMapping은 어떤 URI로 이 메서드를 동작시킬 것인가에 대한 설정임
	//이거 value = "", GET 이런 설정안하면 post든 get이든 모두 받겠다는 의미임
	@RequestMapping("/request/test")
	public String testCall() {
		System.out.println("/request/test 요청이 들어옴!");
		return "test";
	}
	
	@RequestMapping("/request/req")
	public String req() {
		System.out.println("/request/req 요청이 들어옴~!");
		return "request/req-ex01";
	}
	
//	@RequestMapping(value = "/request/basic01", method = RequestMethod.GET)
	@GetMapping("/request/basic01")
	public String basicGet() {
		System.out.println("/request/basic01요청이 들어옴: GET");
		return "request/req-ex01";
	}
	
//	@RequestMapping(value = "/request/basic01", method = RequestMethod.POST)
	@PostMapping("/request/basic01") 
	public String basicPost() {
		System.out.println("/request/basic01요청이 들어옴: POST");
		return "request/req-ex01";
	}
	
}









##############################################################################
21)요청파라미터 받아보기

1)http://localhost:8080/web/request/param(이하uri생략_파라미터입력부분)을 입력해서 접속시도 시에
	view로 보낼 .jsp는 만들지말고(이말은 controller의 return값을 ""로 두라는거임, 브라우저요청시 응답화면은 에러가 나겠고!)
	아래 시스템로그를 남기도록 하여라
get방식이니 uri입력시에 파라미터를 입력해서 접속해라
	-파라미터 입력시 field명 2개
		-name
		-age 
	-RequestController.java를 이용한다.

request/param 요청: GET
이름 : 박영희
나이 : 22


##############################################################################




답: 






package com.spring.web.controller;

import javax.servlet.http.HttpServletRequest;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

//클라이언트 측에서 요청을 보냈을때 그것을 처리하는 컨트롤러
//디스패쳐서블릿이라는 프론트 컨트롤러가 RequestController를 찾게하려면
//디스패쳐서블릿과 requestController의 의존관계를 설정을 해야한다.
//의존관계설정을 우리가 따로할 필요는 없고 해당 클래스에 대한 빈객체를 실행시 만들어지게만 하면된다.
//근데 helloController는 빈등록 코드를 자동으로 이루어지게 했으니 다른 컨트롤러들도 
//자동 빈등록 코드와 아노테이션을 이용하여 그러헥 만들면 된다.

@Controller	
public class RequestController {

	//RequestMapping은 어떤 URI로 이 메서드를 동작시킬 것인가에 대한 설정임
	//이거 value = "", GET 이런 설정안하면 post든 get이든 모두 받겠다는 의미임
	@RequestMapping("/request/test")
	public String testCall() {
		System.out.println("/request/test 요청이 들어옴!");
		return "test";
	}
	
	@RequestMapping("/request/req")
	public String req() {
		System.out.println("/request/req 요청이 들어옴~!");
		return "request/req-ex01";
	}
	
//	@RequestMapping(value = "/request/basic01", method = RequestMethod.GET)
	@GetMapping("/request/basic01")
	public String basicGet() {
		System.out.println("/request/basic01요청이 들어옴: GET");
		return "request/req-ex01";
	}
	
//	@RequestMapping(value = "/request/basic01", method = RequestMethod.POST)
	@PostMapping("/request/basic01") 
	public String basicPost() {
		System.out.println("/request/basic01요청이 들어옴: POST");
		return "request/req-ex01";
	}
	
	// 요청 파라미터 받아보기
	@GetMapping("/request/param")
	public String paramTest(HttpServletRequest request) {
		System.out.println("request/param 요청: GET");
		
		String name = request.getParameter("name");
		String age = request.getParameter("age");
		System.out.println("이름 : " + name);
		System.out.println("이름 : " + age);
		
		return "";
	}
	
}





















































































































21.02.07.4회차
===============================================================================
*Controller메소드반환값x,context root매칭,톰캣한글설정,공통uri매핑,파라미터처리,model(@ModelAttribute(),ModelAndView)
===============================================================================











































































































##############################################################################
22)공통 uri 매핑, 반환값 없는 메소드, context root 매칭시키기, 톰캣한글설정

1)RequestController나 혹은 다른 컨트롤러 내부에서 특정 uri를 공통으로 매핑하여라
	모든 uri를 받는 아노테이션들에 /request를 하지 않아도 /request를 포함한 uri로 아노테이션이
	수신받도록 하여라
	*String형으로 반환할때는 /request를 붙여줘야함
		-다만 void형으로 자동 반환되게할때는 /request가 붙음
	*그리고 반환할때 / 붙여도 되고 안붙여도됨

-----------------------------------------------------------

2)아래 req-ex02.jsp를 만들고 RequestController에서 특정 메소드를 반환값없도록 만들었지만
	viewResolver에는 값이 잘 전달되도록 만드시오.
	-homeController에서 /test uri가 요청된 경우에 void로 메서드를 구성해서 test.jsp페이지가
		열리도록 해보시오.

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	<h2>req-ex02.jsp 파일입니다!</h2>
</body>
</html>

-----------------------------------------------------------
3)jsp만 만지면 되는 문제이다.

3-1)아래 join.jsp를 이용하여 반환값 void일때 공통uri 포함하여 반환
uri로 /request/join이(/web/request/join) 들어왔을때 Controller 메소드 register()
	를 만든뒤 반환값을 void로 하여 views/request/join.jsp가 열리도록 하세요.

3-2)아래 join.jsp를 이용하여 context root 매칭시키기

	-c태그의 특정속성을 이용하여 path 변수를 만들어서 변수에 context root 집어넣은뒤 사용하기
		-path변수는 해당 프로젝트내의 어디서든 사용될수 있도록하여라
	-c태그의 특정속성을 이용하여 변수를 만들지 않고 context root 사용하기


<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
    
<%--
	#컨텍스트 루트 경로가 변경될 경우 처리방법
	1.컨텍스트 루트 경로를 변수로 지정함
	2.<c:url> 태그를 사용
 --%>
 
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>요청 파라미터값 테스트!!</h2>

<form action = "" method = "post"> 	
	<fieldset>
		<legend>회원가입 양식</legend>
		<p>
			- ID : <input type = "text" name = "userId" size = "10"> <br>
			- PW : <input type = "password" name = "userPw" size = "10"> <br>
			- NAME : <input type = "text" name = "userName" size = "10"> <br>
			- HOBY :
			<input type = "checkbox" name = "hobby" value = "soccer" > 축구&nbsp;
			<input type = "checkbox" name = "hobby" value = "book" > 독서&nbsp;
			<input type = "checkbox" name = "hobby" value = "music" > 음악&nbsp;
			<br>
			<input type = "submit" value = "회원가입" />
		</p>
	</fieldset>
</form>

</body>
</html>

****컨텍스트 루트 경로가 변경될 경우 처리방법 : 유지보수가 편하다.

-----------------------------------------------------------
4)4-1, 4-2의 답은 같다. 둘중하나라도 처리하면 모두 해결이 된다.
	문제를 해결하라(톰캣설정과 관련된 web.xml을 이용하라)

4-1)컨텍스트 루트만포함한 url을 요청했을때 한국언어가 깨지는데 그걸해결해라
http://localhost:8080/web/

4-2)아래 url을 요청했을때 id등 post로 보낼 입력값에 한글을치면 깨지는데 그걸 해결해라
http://localhost:8080/web/request/join
	-4-2)는 사실 아래문제에서 파라미터 처리를 해야 확인가능하니까 4-1)로만 확인해라


	<!-- 한글 인코딩 필터 설정(톰캣 내부의 한글처리) -->
	<filter>
	    <filter-name>encodingFilter</filter-name>
	    <filter-class>
				org.springframework.web.filter.CharacterEncodingFilter
			</filter-class>
	    <init-param>
	      <param-name>encoding</param-name>
	      <param-value>UTF-8</param-value>
	    </init-param>
	    <init-param>
	      <param-name>forceEncoding</param-name>
	      <param-value>true</param-value>
	    </init-param>
    </filter>
    <!-- 위에 지정한  encodingFilter이름을 모든 패턴에 적용-->
    <filter-mapping>
	    <filter-name>encodingFilter</filter-name>
	    <url-pattern>/*</url-pattern>
    </filter-mapping>


##############################################################################




답: 



#RequestController.java

package com.spring.web.controller;

import javax.servlet.http.HttpServletRequest;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import com.spring.web.model.UserVO;
import com.spring.web.model.UserVO2;

//클라이언트 측에서 요청을 보냈을때 그것을 처리하는 컨트롤러
//디스패쳐서블릿이라는 프론트 컨트롤러가 RequestController를 찾게하려면
//디스패쳐서블릿과 requestController의 의존관계를 설정을 해야한다.
//의존관계설정을 우리가 따로할 필요는 없고 해당 클래스에 대한 빈객체를 실행시 만들어지게만 하면된다.
//근데 helloController는 빈등록 코드를 자동으로 이루어지게 했으니 다른 컨트롤러들도 
//자동 빈등록 코드와 아노테이션을 이용하여 그러헥 만들면 된다.

@Controller	
@RequestMapping("/request") // 공통 uri 떼놓기
public class RequestController {

	//RequestMapping은 어떤 URI로 이 메서드를 동작시킬 것인가에 대한 설정임
	//이거 value = "", GET 이런 설정안하면 post든 get이든 모두 받겠다는 의미임
//	@RequestMapping("/request/test")
	@RequestMapping("/test") // 원래 위에처럼 해야하지만 클래스선언분위에 일괄매핑을 했어서 괜찮다.
	public String testCall() {
		System.out.println("/request/test 요청이 들어옴!");
		return "test";
	}
	
//	@RequestMapping("/request/req") // 이대로 두면 /request/request/req 해야지 온다.
	@RequestMapping("/req")
	public String req() {
		System.out.println("/request/req 요청이 들어옴~!");
		return "request/req-ex01";
	}
	
	@GetMapping("/req-ex02")
	public void reqEx02() {
		System.out.println("/reqeust/req-ex02 요청!");
	}
	
//	@RequestMapping(value = "/request/basic01", method = RequestMethod.GET)
//	@GetMapping("/request/basic01")
	@GetMapping("/basic01")
	
	public String basicGet() {
		System.out.println("/request/basic01요청이 들어옴: GET");
		return "request/req-ex01";
	}
	
//	@RequestMapping(value = "/request/basic01", method = RequestMethod.POST)
//	@PostMapping("/request/basic01")
	@PostMapping("/basic01")
	public String basicPost() {
		System.out.println("/request/basic01요청이 들어옴: POST");
		return "request/req-ex01";
	}

	// 요청 파라미터 받아보기
//	@GetMapping("/request/param")
	@GetMapping("/param")
	public String paramTest(HttpServletRequest request) {
		System.out.println("request/param 요청: GET");
		
		String name = request.getParameter("name");
		String age = request.getParameter("age");
		System.out.println("이름 : " + name);
		System.out.println("나이 : " + age);
		
		return "";
	}
	
	
	/////////////////////////////////////////////////////////////////////
	@GetMapping("/join")
	public void register() {
		System.out.println("/request/join : GET");
	}
	
}




#./views/request/join.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
    
    
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>
    
<%--
	#컨텍스트 루트 경로가 변경될 경우 처리방법
	1.컨텍스트 루트 경로를 변수로 지정함
	2.<c:url> 태그를 사용
 --%>
 
 <c:set var = "path" value = "<%= request.getContextPath() %>" scope = "application"/>
    
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>요청 파라미터값 테스트!!</h2>
<%--
# 1번방식
<form action = "${path}/request/join" method = "post">
 --%>
 <%-- #2번방식 --%>
<form action = "<c:url value = '/request/join' />" method = "post"> 	
	<fieldset>
		<legend>회원가입 양식</legend>
		<p>
			- ID : <input type = "text" name = "userId" size = "10"> <br>
			- PW : <input type = "password" name = "userPw" size = "10"> <br>
			- NAME : <input type = "text" name = "userName" size = "10"> <br>
			- HOBY :
			<input type = "checkbox" name = "hobby" value = "soccer" > 축구&nbsp;
			<input type = "checkbox" name = "hobby" value = "book" > 독서&nbsp;
			<input type = "checkbox" name = "hobby" value = "music" > 음악&nbsp;
			<br>
			<input type = "submit" value = "회원가입" />
		</p>
	</fieldset>
</form>

</body>
</html>




#./WEB-INF/web.xml


<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">

	<!-- mvc와 관련된 스프링 설정파일의 위치를 지정하는 태그 -->
	<!-- The definition of the Root Spring Container shared by all Servlets and Filters -->
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/spring/mvc-config.xml</param-value>
	</context-param>
	
	<!-- Creates the Spring Container shared by all Servlets and Filters -->
	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>

	<!--  디스패쳐 서블릿 등록 설정 -->
	<!-- Processes application requests -->
	<servlet>
		<servlet-name>appServlet</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>/WEB-INF/spring/servlet-config.xml</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>
		
	<servlet-mapping>
		<servlet-name>appServlet</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping>


	<!-- 한글 인코딩 필터 설정(톰캣 내부의 한글처리) -->
	<filter>
	    <filter-name>encodingFilter</filter-name>
	    <filter-class>
				org.springframework.web.filter.CharacterEncodingFilter
			</filter-class>
	    <init-param>
	      <param-name>encoding</param-name>
	      <param-value>UTF-8</param-value>
	    </init-param>
	    <init-param>
	      <param-name>forceEncoding</param-name>
	      <param-value>true</param-value>
	    </init-param>
    </filter>
    <!-- 위에 지정한  encodingFilter이름을 모든 패턴에 적용-->
    <filter-mapping>
	    <filter-name>encodingFilter</filter-name>
	    <url-pattern>/*</url-pattern>
    </filter-mapping>

</web-app>




























##############################################################################
23)post 혹은 get으로 오는 파라미터를 Controller에서 처리하기

<가 문제>

1.전통적인 jsp/servlet의 파라미터 읽기처리방법

2.아노테이션을 이용한 요청 파라미터 처리

3.커맨드 객체를 활용한 파라미터 처리(UserVO)
	pacakge com.spring.web.model 생성


*join을 이용해서 파라미터 처리 3가지방식으로 풀어라(join.jsp는 수정할필요없거 RequestController에서
		join.jsp가 보내주는 파라미터를 처리만 하면 된다)
	-ID, PW, HOBBY 값을 입력받았을때 그걸 출력해라
		-2번방법(아노테이션)을 이용한경우 HOBBY가 없을시에  
			에러가 난다. 두개의 에러원인이 있는데 f3을 써가면서 고쳐라
		-HOBBY가 없을시에는 "no hobby person"이 출력되게 하라
		-HOBBY를 담을때는 List<String>을 이용하라

<출력방식코드>
		System.out.println("ID : " + id);
		System.out.println("PW : " + pw);
		System.out.println("HOBBY : " + hobbys.toString());








<나 문제>


class이용 : RequestController.java

# 문제
	1. RequestController에 현재 파일을 열어주는 메서드 생성
	 - url: /request/quiz : GET
	 - views: /request/req-quiz.jsp
		-이놈은 아래 코드참고
	 - method-name: quiz()
	2. RequestController에 전송된 아이디, 비밀번호 파라미터를
	  받아 로그인을 처리하는 메서드 생성
	 - url: /request/quiz : POST
	 - views: 
	 	성공시: /request/login-success.jsp
			-그냥 성공입니다만 띄워라
	 	실패시: /request/login-fail.jsp
			-그냥 실패입니다만 띄워라
	 - method-name: quiz()
	3. 로그인 성공조건: 
	 - id값이 : abc1234 , pw: xxx4321
	 
	 -리퀘스트 파람이나 커맨드객체를 사용해라


위 #문제를 3가지 방법으로 풀어라

1.전통적인 jsp/servlet의 파라미터 읽기처리방법

2.아노테이션을 이용한 요청 파라미터 처리

3.커맨드 객체를 활용한 파라미터 처리(UserVO)
	pacakge com.spring.web.model 생성


#req-quiz.jsp



<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<%--
	# 문제
	1. RequestController에 현재 파일을 열어주는 메서드 생성
	 - url: /request/quiz : GET
	 - views: /request/req-quiz.jsp
	 - method-name: quiz()
	2. RequestController에 전송된 아이디, 비밀번호 파라미터를
	  받아 로그인을 처리하는 메서드 생성
	 - url: /request/quiz : POST
	 - views: 
	 	성공시: /request/login-success.jsp
	 	실패시: /request/login-fail.jsp
	 - method-name: quiz()
	3. 로그인 성공조건: 
	 - id값이 : abc1234 , pw: xxx4321
	 
	 -리퀘스트 파람이나 커맨드객체를 사용해라
 --%>

<h3>파라미터값 처리하기 문제~</h3>

<form action="<c:url value='/request/quiz'/>" method="post">
	<p>
		# ID: <input type="text" name="userId" size="10"><br>
		# PW: <input type="password" name="userPw" size="10"><br>
		<input type="submit" value="로그인">
	</p>
</form>

</body>
</html>




##############################################################################




답: 


#RequestController.java만 만지고 나머지는 그냥 만들면됨

package com.spring.web.controller;

import javax.servlet.http.HttpServletRequest;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import com.spring.web.model.UserVO;
import com.spring.web.model.UserVO2;

//클라이언트 측에서 요청을 보냈을때 그것을 처리하는 컨트롤러
//디스패쳐서블릿이라는 프론트 컨트롤러가 RequestController를 찾게하려면
//디스패쳐서블릿과 requestController의 의존관계를 설정을 해야한다.
//의존관계설정을 우리가 따로할 필요는 없고 해당 클래스에 대한 빈객체를 실행시 만들어지게만 하면된다.
//근데 helloController는 빈등록 코드를 자동으로 이루어지게 했으니 다른 컨트롤러들도 
//자동 빈등록 코드와 아노테이션을 이용하여 그러헥 만들면 된다.

@Controller	
@RequestMapping("/request") // 공통 uri 떼놓기
public class RequestController {

	//RequestMapping은 어떤 URI로 이 메서드를 동작시킬 것인가에 대한 설정임
	//이거 value = "", GET 이런 설정안하면 post든 get이든 모두 받겠다는 의미임
//	@RequestMapping("/request/test")
	@RequestMapping("/test") // 원래 위에처럼 해야하지만 클래스선언분위에 일괄매핑을 했어서 괜찮다.
	public String testCall() {
		System.out.println("/request/test 요청이 들어옴!");
		return "test";
	}
	
//	@RequestMapping("/request/req") // 이대로 두면 /request/request/req 해야지 온다.
	@RequestMapping("/req")
	public String req() {
		System.out.println("/request/req 요청이 들어옴~!");
		return "request/req-ex01";
	}
	
	@GetMapping("/req-ex02")
	public void reqEx02() {
		System.out.println("/reqeust/req-ex02 요청!");
	}
	
//	@RequestMapping(value = "/request/basic01", method = RequestMethod.GET)
//	@GetMapping("/request/basic01")
	@GetMapping("/basic01")
	
	public String basicGet() {
		System.out.println("/request/basic01요청이 들어옴: GET");
		return "request/req-ex01";
	}
	
//	@RequestMapping(value = "/request/basic01", method = RequestMethod.POST)
//	@PostMapping("/request/basic01")
	@PostMapping("/basic01")
	public String basicPost() {
		System.out.println("/request/basic01요청이 들어옴: POST");
		return "request/req-ex01";
	}
	
	// 요청 파라미터 받아보기
//	@GetMapping("/request/param")
	@GetMapping("/param")
	public String paramTest(HttpServletRequest request) {
		System.out.println("request/param 요청: GET");
		
		String name = request.getParameter("name");
		String age = request.getParameter("age");
		System.out.println("이름 : " + name);
		System.out.println("나이 : " + age);
		
		return "";
	}
	
	
	/////////////////////////////////////////////////////////////////////
	@GetMapping("/join")
	public void register() {
		System.out.println("/request/join : GET");
	}
	
	/*
	 # 1.전통적인 jsp/servlet의 파라미터 읽기처리방법
	 	-HttpServletRequest객체를 사용
	 
	
	@PostMapping("/join")
	public String register(HttpServletRequest request) {
		System.out.println("/request/join : POST");
		System.out.println("ID : " + request.getParameter("userId"));
		System.out.println("PW : " + request.getParameter("userPw"));
		System.out.println("HOBBY : " 
				+ Arrays.toString(request.getParameterValues("hobby")));
		return "request/join";
	}
	*/
	
	/* 
	 # 2.@RequestParam 아노테이션을 이용한 요청 파라미터 처리
	 	-1번 안쓰는 이유 : 받아야할 파라미터가 많다면 request함수를 넘많이써야함. 나이가 들어오면
	 		변환처리를 해야한다. request의 리턴타입은 항상 String이기때문에 변환과정이 추가돼서 별로다.
	 		즉 형변환 처리의 귀찮음을 막아주는 법
	 	-2번단점 : 현재경우 hobby취미를 선택하지 않으면 에러난다. 즉 매개변수로 hobby값이 null이 오면 에러다
	 		@RequestParam(value = "hobby", required = false) List<String> hobbys) {
	 		위처럼하면 해결됨 f3보면 required가 true로 되어있어서에러인거다
	 		근데 이렇게해도 null이 들어오니까 문법에러가 나긴함 왜냐면 아래 .toString()을 했기때문
	 		그럼 @RequestParam(value = "hobby", required = false, defaultValue = "no hobby person") List<String> hobbys) {
	 		하면 됨
	 		
	 	**별개로 한글로 입력하면 깨진다. 톰캣이 한글을 못알아먹어서 그렇다.
	 		톰캣한글처리에 대해 편하게 할수있는 방법을 spring에서 제공한다.
	 		
	 
	@PostMapping("/join")
	public void register(@RequestParam("userId") String id,
							@RequestParam("userPw") String pw,
							@RequestParam(value = "hobby", required = false, defaultValue = "no hobby person") List<String> hobbys) {
			//String id = request.getParameter("userId"); 를 한번에 처리해주는 것임
			//int라면 형변환도 int로 해서 알아서 됨
			
		System.out.println("ID : " + id);
		System.out.println("PW : " + pw);
		System.out.println("HOBBY : " + hobbys.toString());
	}
	
	*/
	
	/*
	 # 3.커맨드 객체를 활용한 파라미터 처리
	 	-UserVO의 필드명과 jsp의 파라미터명이 같고 UserVo라는 객체에 setter getter가 있다면 그대로 바로 형변환
	 	될건 되면서 알아서 다 들어간다. 자동화의 신세계!
	 */
	@PostMapping("/join")
	public void register(UserVO user) {
		System.out.println("ID : " + user.getUserId());
		System.out.println("PW : " + user.getUserPw());
		System.out.println("NAME : " + user.getUserName());
		System.out.println("HOBBY : " + user.getHobby());
	}
	
	@GetMapping("/quiz")
	public String quiz() {
		System.out.println("/request/req-quiz 요청됨 : GET");
		return "/request/req-quiz"; // / 붙여도 되고 안붙여도 됨
	}
	
	
//	@RequestMapping(value = "/quiz", method = RequestMethod.POST)
//	public String quiz(HttpServletRequest request) {
//		String id = request.getParameter("userId");
//		String pw = request.getParameter("userPw");
//		
//		if (id.equals("abc1234") && pw.equals("xxx4321")) {			
//			return "request/login-success";
//		}
//		
//		return "request/login-fail";
//	}
	
//	@RequestMapping(value = "/quiz", method = RequestMethod.POST)
//	public String quiz(@RequestParam("userId") String id,
//						@RequestParam("userPw") String pw) {
//		if (id.equals("abc1234") && pw.equals("xxx4321")) {
//			return "request/login-success";			
//		}
//		return "request/login-fail";
//	}

	@PostMapping("/quiz")
	public String quiz(UserVO2 user) {
		System.out.println("/request/req-quiz 요청됨 : POST");
		
		if (user.getUserId().equals("abc1234") 
				&& user.getUserPw().equals("xxx4321")) {
			return "request/login-success";	
		}
		
		return "request/login-fail";
	}
	
}



























##############################################################################
24)bean id 설정, model사용

<package생성> : package com.spring.web.controller;
<class 생성> : ResponseController.java
<views>
폴더생성 : response
jsp생성 : res-ex01.jsp, test.jsp, test2.jsp

1)아노테이션을 통한 자동빈등록시 bean id 따로 지정하는법
	-따로지정한뒤 beans graph를 이용하여 bean id가 바꼈나 봐라
		-원래 자동생성시 beanid는 기본값으로 해당 클래스이름에서 첫글자를 소문자로 한 것이다.
	-bean id는 responseController에서 resCon으로 바꿔라



답: @Controller("resCon")



2)동적으로 jsp에 값을 넘겨주기위해 model 사용하기

1.아노테이션과 Model 객체를 사용하여 매개변수받기
2.1번의 것을 특정 아노테이션을 이용하여 매개변수에서 한번에 처리하기

	1,2번문제는 test.jsp로 해결(아래 테스트1페이지와 관련)
3.model 관련 class 타입을 반환하여 얻기
	-3번문제는 test2.jsp로 해결
	-특정 객체를 반환하여 viewResolver에게 문자열을 전달하면서 동시에
		데이터 세트도 전달하기
	-데이터세트 : "userName", "박영희"
	-viewResolver에게 전달할 문자열 : "/response/test2"


#res-ex01.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>    

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>Model 객체에 대해 알아보기</h2>

<a href = ""> 테스트 1페이지로~</a>
	<%-- 여기서 get으로 보내는건데(아래도 get인건 마찬가지) 나이에 대해서를 링크에 ?붙여서(30으로)
		보내고 별명은 nick, 뽀삐로 Controller에서 model에 담은뒤 보내라 
		즉 나이는 jsp에서 파라미터로 보내고 별명은 controller에서 model에 담아서 보낸걸
		받아서 사용해라
--%>
<a href = ""> 테스트 2페이지로~</a>

</body>
</html>

#test.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>test.jsp 페이지입니다.</h2>

<p> 지정된 별명은 ??입니다. 그리고 나이는 ??세 입니다.</p>

</body>
</html>


#test2.jsp



<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>test2.jsp 페이지입니다.</h2>
<p>
	컨트롤러가 전달한 데이터 : ??
</p>

</body>
</html>
##############################################################################




답: 


#ResponseController.java

package com.spring.web.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

@Controller("resCon")
@RequestMapping("/response")

public class ResponseController {
	
	public ResponseController() {
		// TODO Auto-generated constructor stub
	}
	
	@GetMapping("/res-ex01")
	public void resEx01() {
		
	}
	
	//1.Model 객체를 사용하여 화면에 데이터 전송하기
	/*
	@GetMapping("/test")
	public void test(@RequestParam("age") int age,
						Model model) {
		model.addAttribute("nick", "뽀삐");
		model.addAttribute("age", age);
	}
	*/
	
	//@ModelAttribute : @RequestParam("age") int age + model.addAttribute("age", age)
					//와 같은 것이다. 포함관계
	//2.@ModelAttribute를 사용한 화면에 데이터 전송처리
	@GetMapping("/test")
	public void test(@ModelAttribute("age") int age,
			Model model) {
		model.addAttribute("nick", "뽀삐");
//		model.addAttribute("age", age);
	}
	
	//3.ModelAndView 객체를 활용한 처리
	@GetMapping("/test2")
	public ModelAndView test2() {
//		ModelAndView mv = new ModelAndView();
//		mv.addObject("userName", "박영희"); //화면에 전달할 데이터 래핑
//		mv.setViewName("/response/test2"); //viewResolver에게 전달할 문자열
//		return mv;
		
		return new ModelAndView("/response/test2", "userName", "박영희");
	}
}



#res-ex01.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>    

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>Model 객체에 대해 알아보기</h2>

<%--
	<c:url value='' />
		-value 속성안에 컨텍스트 루트 경로를 제외한 절대경로를 작성
		-그러면 컨텍스트 루트를 제외하고 연결가능
		<a href = "/web/response/test">테스트페이지로~</a>
		위에 놈을 아래로 전환
		<a href = "<c:url value = '/response/test' />"> 테스트페이지로~</a>
		
		
 --%>

<a href = "<c:url value = '/response/test?age=30' />"> 테스트 1페이지로~</a>
<a href = "<c:url value = '/response/test2' />"> 테스트 2페이지로~</a>

</body>
</html>



#test.jsp


<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>test.jsp 페이지입니다.</h2>
<%--
	<p> 지정된 별명은 ??입니다. 그리고 나이는 ??세 입니다.</p>
 --%>
<p> 지정된 별명은 ${nick}입니다. 그리고 나이는 ${age}세 입니다.</p>
</body>
</html>



#test2.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>test2.jsp 페이지입니다.</h2>
<p>
	컨트롤러가 전달한 데이터 : ${userName}
</p>

</body>
</html>


































































































































































21.02.08.5회차
===============================================================================
*jstl, EL, 커맨드객체 생성원리(setter이용), form에서 action 없는경우, 재전송요청, model, session한계, 재전송시 효율높은 scope 객체
===============================================================================































































































##############################################################################
25)jstl, EL, 커맨드객체 생성원리(setter이용)

1)아래 흐름과 조건을 지켜서 정상적으로 회원정보를 출력하라
	-회원정보 EL로 넣을떼는 해당 클래스에서 toString을 재정의해야한다.
	-test3에서 hobby 출력시에는 jstl로 조건문과 for문을 이용한다.

res-ex02.jsp생성
test3.jsp 생성
ResponseController.java 이용

순서 : 클라이언트 uri요청 -> Controller -> res-ex02.jsp -> Controller -> test3.jsp 
client uri 요청 : /response/res-ex02
res-ex02.jsp에서 요청 uri : /response/join

메소드 : resEx02(), join()

 
#res-ex02.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<form action = "" method = "post"> 	
	<fieldset>
		<legend>회원가입 양식</legend>
		<p>
			- ID : <input type = "text" name = "userId" size = "10"> <br>
			- PW : <input type = "password" name = "userPw" size = "10"> <br>
			- NAME : <input type = "text" name = "userName" size = "10"> <br>
			- HOBY :
			<input type = "checkbox" name = "hobby" value = "soccer" > 축구&nbsp;
			<input type = "checkbox" name = "hobby" value = "book" > 독서&nbsp;
			<input type = "checkbox" name = "hobby" value = "music" > 음악&nbsp;
			<br>
			<input type = "submit" value = "회원가입" />
		</p>
	</fieldset>
</form>

</body>
</html>


#test3
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
  
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>회원가입정보 출력하기</h2>
<p>
	# 회원정보 : ${} <br>
	# 아이디 : ${} <br>
	# 비밀번호 : ${} <br>
	# 이름 : ${} <br>
	# 취미 :
	<%-- 자바코드를 html코드처럼 일관성있게 쓰는 방법이 jstl이다. --%>

		이 사람은 취미가 없는 사람입니다.

	<br>
</p>

</body>
</html>

	

##############################################################################



답:

-----------------------------------------------

#res-ex02.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<form action = "<c:url value = '/response/join' />" method = "post"> 	
	<fieldset>
		<legend>회원가입 양식</legend>
		<p>
			- ID : <input type = "text" name = "userId" size = "10"> <br>
			- PW : <input type = "password" name = "userPw" size = "10"> <br>
			- NAME : <input type = "text" name = "userName" size = "10"> <br>
			- HOBY :
			<input type = "checkbox" name = "hobby" value = "soccer" > 축구&nbsp;
			<input type = "checkbox" name = "hobby" value = "book" > 독서&nbsp;
			<input type = "checkbox" name = "hobby" value = "music" > 음악&nbsp;
			<br>
			<input type = "submit" value = "회원가입" />
		</p>
	</fieldset>
</form>

</body>
</html>






-----------------------------------------------



#test3.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
    
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>    
    
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>회원가입정보 출력하기</h2>
<p>
	# 회원정보 : ${user} <br>
	# 아이디 : ${user.getUserId()} <br>
	# 비밀번호 : ${user.userPw} <br>
	# 이름 : ${user.userName} <br>
	# 취미 :
	<%-- 자바코드를 html코드처럼 일관성있게 쓰는 방법이 jstl이다. --%>
	<c:if test = "${user.hobby.size() != 0}" >
		<c:forEach var="h" items="${user.hobby}">
			${h} &nbsp;
		</c:forEach>
	</c:if>
	<c:if test = "${user.hobby.size() == null}" >
	
		이 사람은 취미가 없는 사람입니다.
	</c:if>
	<br>
</p>

</body>
</html>


-----------------------------------------------


#ResponseController.java

package com.spring.web.controller;

import javax.servlet.http.HttpSession;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.spring.web.model.UserVO;
import com.spring.web.model.UserVO2;

@Controller("resCon")
@RequestMapping("/response")

public class ResponseController {
	
	public ResponseController() {
		// TODO Auto-generated constructor stub
	}
	
	@GetMapping("/res-ex01")
	public void resEx01() {
		
	}
	
	//1.Model 객체를 사용하여 화면에 데이터 전송하기
	/*
	@GetMapping("/test")
	public void test(@RequestParam("age") int age,
						Model model) {
		model.addAttribute("nick", "뽀삐");
		model.addAttribute("age", age);
	}
	*/
	
	//@ModelAttribute : @RequestParam("age") int age + model.addAttribute("age", age)
					//와 같은 것이다. 포함관계
	//2.@ModelAttribute를 사용한 화면에 데이터 전송처리
	@GetMapping("/test")
	public void test(@ModelAttribute("age") int age,
			Model model) {
		model.addAttribute("nick", "뽀삐");
//		model.addAttribute("age", age);
	}
	
	//3.ModelAndView 객체를 활용한 처리
	@GetMapping("/test2")
	public ModelAndView test2() {
//		ModelAndView mv = new ModelAndView();
//		mv.addObject("userName", "박영희"); //화면에 전달할 데이터 래핑
//		mv.setViewName("/response/test2"); //viewResolver에게 전달할 문자열
//		return mv;
		
		return new ModelAndView("/response/test2", "userName", "박영희");
	}
	
	
	//res-ex02.jsp파일을 열람하는 요청메서드 작성
	@GetMapping("/res-ex02")
	public void resEx02() {
		
	}
	
	
	/*
	@PostMapping("/join")
	public String join(UserVO user, Model model) {
		model.addAttribute("user", user);
		return "response/test3";
	}
	*/
	@PostMapping("/join")
	public String join(@ModelAttribute("user") UserVO user) {
		return "response/test3";
	}
	
	@GetMapping("/res-quiz")
	public void resQuiz() {
		
	}
	
	@PostMapping("/res-login")
	public String resLogin(@ModelAttribute("user") UserVO2 user) {
		String id = user.getUserId();
		String pw = user.getUserPw();
		
		if (id.equals("kim123") && pw.equals("kkk1234")) {
			return "response/res-quiz-success";			
		}
		
		return "response/res-quiz-fail";
	}
	
	
	///////////////////////////////////////////////////////////////////
	//Redirect처리 
	//원래는 viewResolver에게 보내는 방식이 포워드 방식이다.
	//글쓰기 요청이 끝난다음에 글목록 페이지가 떠야하는데 포워드면 요청끝나고 디스패쳐왔다가 다시 db에 가야함
	//글쓰기 요청(insert)가 되고나면 다시 돌아오지않고 재요청으로  select하여 목록을 가져오면 좋다.
	//그 재요청방법이 Redirect처리다.
	//글 삭제같은경우도 delete로 게시글 지우고 목록을 보여줄때 디스패쳐까지 돌아오지않고 재요청을해서 바로 db에서 목록을
	//가져오는 것도 포워드로는 않되고 Redirect로 가능하다.
	
	//로그인 화면 요청처리
	@GetMapping("/login")
	public String login() {
		System.out.println("/response/login 요청 발생 : GET");
		return "response/res-redirect-form";
	}
	
	//로그인 검증처리
	/*
	@PostMapping("/login")
	public String login(@ModelAttribute("userId") String id
							, @RequestParam("userPw") String pw
							, @RequestParam("userPwChk") String pwChk
							, Model model
							//, HttpServletResponse response)원래 이게 jsp방식인데 spirng에선 이렇게 안해도됨
							, HttpSession session
							){
		System.out.println("/response/login 요청 발생 : POST");
		System.out.println("id : " + id); 
		System.out.println("pw : " + pw);
		System.out.println("pwChk : " + pwChk);
		
		
		
		if (id.equals("")) { // 아이디 입력하지 않은 경우
//			response.sendRedirect(); 원래 이게 jsp방식인데 spirng에선 이렇게 안해도됨
			System.out.println("아이디가 비었습니다.");
//			model.addAttribute("msg", "아이디는 필수 값이에요!");
			session.setAttribute("msg", "아이디는 필수 값이에요!");
			return "redirect:/response/login"; // jsp를 열러가지않고 바로 다시 controller의 
												// /resposne/login uri를 받을수있는 메서드를
												// 찾는다.
												//이때 redirect로 보내면 무조건 get요청이다.
												//그래서 위에 로그인화면요청처리로 간다.
		} else if (!pw.equals(pwChk)) { // 비번과 확인비번이 다른 경우
			System.out.println("두 비밀번호가 같지 않습니다.");
//			model.addAttribute("msg", "비밀번호 확인란을 체크하세요!");
			session.setAttribute("msg", "두 비밀번호가 같지 않습니다.");
			return "redirect:/response/login";
		} else if (id.equals("abc123") && pw.equals("1234")) {
			System.out.println("로그인성공!");
			return "response/res-quiz-success";
		} else { // 안전빵
			System.out.println("그런 아이디와 비번은 등록되지 않았습니다.");
//			model.addAttribute("msg", "그런 아이디와 비번은 등록되지 않았습니다.");
			return null;
		}
	}
	*/
	@PostMapping("/login")
	public String login(@ModelAttribute("userId") String id
							, @RequestParam("userPw") String pw
							, @RequestParam("userPwChk") String pwChk
							, RedirectAttributes ra
//							, HttpSession session
							, Model model
							){
		System.out.println("/response/login 요청 발생 : POST");
		System.out.println("id : " + id); 
		System.out.println("pw : " + pw);
		System.out.println("pwChk : " + pwChk);
		
		
		
		if (id.equals("")) { // 아이디 입력하지 않은 경우
			System.out.println("아이디가 비었습니다.");
			ra.addFlashAttribute("msg2", "아이디는 필수 값이에요!");
//			session.setAttribute("msg1", "아이디는 필수 값이에요!");
//			model.
			return "redirect:/response/login"; 
		} else if (!pw.equals(pwChk)) { // 비번과 확인비번이 다른 경우
			System.out.println("두 비밀번호가 같지 않습니다.");
			ra.addFlashAttribute("msg2", "두 비밀번호가 같지 않습니다.");
//			session.setAttribute("msg1", "두 비밀번호가 같지 않습니다.");
			return "redirect:/response/login";
		} else if (id.equals("abc123") && pw.equals("1234")) {
			System.out.println("로그인성공!");
			
			return "response/res-quiz-success";
		} else { // 안전빵
			System.out.println("그런 아이디와 비번은 등록되지 않았습니다.");
			return null;
		}
	}
	
	
}











##############################################################################
26)jstl, EL, 커맨드객체 생성원리(setter이용)

1. res-quiz 파일의 화면처리를 할 수 있는 메서드를 생성하세요.(res-quiz 맵핑)
2. 폼태그의 액션URL은 res-login 으로 설정하세요.
3. ID:kim123, PW:kkk1234 라면 res-quiz-success.jsp페이지로 
     이동해서 "로그인 성공" "(회원ID)님 환영합니다" 출력
4. 아니라면 res-quiz-fail.jsp페이지로 이동해서 
   "로그인 실패" "(회원ID)는 회원이 아닙니다" 출력
	-이때 id만 실어서 보내는방법과 idpw를 보내는방법 모두이용해라
		1.커맨드객체와 Model을 사용한 방식
		2.아노테이션을 사용한 방식
			2-1)userId는 아노테이션으로 받고, userPw는 아노테이션 requestParam으로 받는다
				-어차피 userId만 넘기면되니까!
			2-2)userVO를 아노테이션으로 받아서 한번에 attribute까지 처리한다.





#res-quiz.jsp

<form action="#" method="post">
	<p>
		# ID: <input type="text" name="userId" size="10"><br>
		# PW: <input type="password" name="userPw" size="10"><br>
		<input type="submit" value="로그인">
	</p>
</form>


</body>
</html>
##############################################################################



답:





#res-quiz.jsp


<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<%--
1. res-quiz 파일의 화면처리를 할 수 있는 메서드를 생성하세요.(res-quiz 맵핑)
2. 폼태그의 액션URL은 res-login 으로 설정하세요.
3. ID:kim123, PW:kkk1234 라면 res-quiz-success.jsp페이지로 
     이동해서 "로그인 성공" "(회원ID)님 환영합니다" 출력
4. 아니라면 res-quiz-fail.jsp페이지로 이동해서 
   "로그인 실패" "(회원ID)는 회원이 아닙니다" 출력
	
--%>

<form action="<c:url value = '/response/res-login'/>" method="post">
	<p>
		# ID: <input type="text" name="userId" size="10"><br>
		# PW: <input type="password" name="userPw" size="10"><br>
		<input type="submit" value="로그인">
	</p>
</form>


</body>
</html>




#res-quiz-success.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

	<h2>로그인 성공!!</h2>
	<p>
		( ${userId} )님 환영합니다!!!!!!
	</p>

</body>
</html>


#ResponseController.java : 25코드와 같음



package com.spring.web.controller;

import javax.servlet.http.HttpSession;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.spring.web.model.UserVO;
import com.spring.web.model.UserVO2;

@Controller("resCon")
@RequestMapping("/response")

public class ResponseController {
	
	public ResponseController() {
		// TODO Auto-generated constructor stub
	}
	
	@GetMapping("/res-ex01")
	public void resEx01() {
		
	}
	
	//1.Model 객체를 사용하여 화면에 데이터 전송하기
	/*
	@GetMapping("/test")
	public void test(@RequestParam("age") int age,
						Model model) {
		model.addAttribute("nick", "뽀삐");
		model.addAttribute("age", age);
	}
	*/
	
	//@ModelAttribute : @RequestParam("age") int age + model.addAttribute("age", age)
					//와 같은 것이다. 포함관계
	//2.@ModelAttribute를 사용한 화면에 데이터 전송처리
	@GetMapping("/test")
	public void test(@ModelAttribute("age") int age,
			Model model) {
		model.addAttribute("nick", "뽀삐");
//		model.addAttribute("age", age);
	}
	
	//3.ModelAndView 객체를 활용한 처리
	@GetMapping("/test2")
	public ModelAndView test2() {
//		ModelAndView mv = new ModelAndView();
//		mv.addObject("userName", "박영희"); //화면에 전달할 데이터 래핑
//		mv.setViewName("/response/test2"); //viewResolver에게 전달할 문자열
//		return mv;
		
		return new ModelAndView("/response/test2", "userName", "박영희");
	}
	
	
	//res-ex02.jsp파일을 열람하는 요청메서드 작성
	@GetMapping("/res-ex02")
	public void resEx02() {
		
	}
	
	
	/*
	@PostMapping("/join")
	public String join(UserVO user, Model model) {
		model.addAttribute("user", user);
		return "response/test3";
	}
	*/
	@PostMapping("/join")
	public String join(@ModelAttribute("user") UserVO user) {
		return "response/test3";
	}
	
	@GetMapping("/res-quiz")
	public void resQuiz() {
		
	}
	
	@PostMapping("/res-login")
	public String resLogin(@ModelAttribute("user") UserVO2 user) {
		String id = user.getUserId();
		String pw = user.getUserPw();
		
		if (id.equals("kim123") && pw.equals("kkk1234")) {
			return "response/res-quiz-success";			
		}
		
		return "response/res-quiz-fail";
	}
	
	
	///////////////////////////////////////////////////////////////////
	//Redirect처리 
	//원래는 viewResolver에게 보내는 방식이 포워드 방식이다.
	//글쓰기 요청이 끝난다음에 글목록 페이지가 떠야하는데 포워드면 요청끝나고 디스패쳐왔다가 다시 db에 가야함
	//글쓰기 요청(insert)가 되고나면 다시 돌아오지않고 재요청으로  select하여 목록을 가져오면 좋다.
	//그 재요청방법이 Redirect처리다.
	//글 삭제같은경우도 delete로 게시글 지우고 목록을 보여줄때 디스패쳐까지 돌아오지않고 재요청을해서 바로 db에서 목록을
	//가져오는 것도 포워드로는 않되고 Redirect로 가능하다.
	
	//로그인 화면 요청처리
	@GetMapping("/login")
	public String login() {
		System.out.println("/response/login 요청 발생 : GET");
		return "response/res-redirect-form";
	}
	
	//로그인 검증처리
	/*
	@PostMapping("/login")
	public String login(@ModelAttribute("userId") String id
							, @RequestParam("userPw") String pw
							, @RequestParam("userPwChk") String pwChk
							, Model model
							//, HttpServletResponse response)원래 이게 jsp방식인데 spirng에선 이렇게 안해도됨
							, HttpSession session
							){
		System.out.println("/response/login 요청 발생 : POST");
		System.out.println("id : " + id); 
		System.out.println("pw : " + pw);
		System.out.println("pwChk : " + pwChk);
		
		
		
		if (id.equals("")) { // 아이디 입력하지 않은 경우
//			response.sendRedirect(); 원래 이게 jsp방식인데 spirng에선 이렇게 안해도됨
			System.out.println("아이디가 비었습니다.");
//			model.addAttribute("msg", "아이디는 필수 값이에요!");
			session.setAttribute("msg", "아이디는 필수 값이에요!");
			return "redirect:/response/login"; // jsp를 열러가지않고 바로 다시 controller의 
												// /resposne/login uri를 받을수있는 메서드를
												// 찾는다.
												//이때 redirect로 보내면 무조건 get요청이다.
												//그래서 위에 로그인화면요청처리로 간다.
		} else if (!pw.equals(pwChk)) { // 비번과 확인비번이 다른 경우
			System.out.println("두 비밀번호가 같지 않습니다.");
//			model.addAttribute("msg", "비밀번호 확인란을 체크하세요!");
			session.setAttribute("msg", "두 비밀번호가 같지 않습니다.");
			return "redirect:/response/login";
		} else if (id.equals("abc123") && pw.equals("1234")) {
			System.out.println("로그인성공!");
			return "response/res-quiz-success";
		} else { // 안전빵
			System.out.println("그런 아이디와 비번은 등록되지 않았습니다.");
//			model.addAttribute("msg", "그런 아이디와 비번은 등록되지 않았습니다.");
			return null;
		}
	}
	*/
	@PostMapping("/login")
	public String login(@ModelAttribute("userId") String id
							, @RequestParam("userPw") String pw
							, @RequestParam("userPwChk") String pwChk
							, RedirectAttributes ra
//							, HttpSession session
							, Model model
							){
		System.out.println("/response/login 요청 발생 : POST");
		System.out.println("id : " + id); 
		System.out.println("pw : " + pw);
		System.out.println("pwChk : " + pwChk);
		
		
		
		if (id.equals("")) { // 아이디 입력하지 않은 경우
			System.out.println("아이디가 비었습니다.");
			ra.addFlashAttribute("msg2", "아이디는 필수 값이에요!");
//			session.setAttribute("msg1", "아이디는 필수 값이에요!");
//			model.
			return "redirect:/response/login"; 
		} else if (!pw.equals(pwChk)) { // 비번과 확인비번이 다른 경우
			System.out.println("두 비밀번호가 같지 않습니다.");
			ra.addFlashAttribute("msg2", "두 비밀번호가 같지 않습니다.");
//			session.setAttribute("msg1", "두 비밀번호가 같지 않습니다.");
			return "redirect:/response/login";
		} else if (id.equals("abc123") && pw.equals("1234")) {
			System.out.println("로그인성공!");
			
			return "response/res-quiz-success";
		} else { // 안전빵
			System.out.println("그런 아이디와 비번은 등록되지 않았습니다.");
			return null;
		}
	}
	
	
}























##############################################################################
27)jstl, EL, 커맨드객체 생성원리(setter이용)

views: birth 폴더생성
	-birth-form.jsp
	-birth-result.jsp

class : BirthController.java 생성


	1. 다음 생년월일을 받아서 콘솔에 출력하는 
	   메서드를 생성 (url: /birth : POST)
          조건) BirthVO 커맨드객체 사용, 
          콘솔에 전송된 값을 붙여서 출력합니다 ex)20180615
	2. birth-result.jsp 페이지에 
	"당신의 생일은 ~~~~년 ~~월 ~~일입니다." 을 출력하세요

-option에 value?였나? 를 넣으면 2월에서 2값만 보낼수 있다.
-유의할점:커맨드 객체를 이용하여 파라미터 처리할때 setter가 작동된다.
	-0을 추가로 붙이는 작업을 setter에서 하라는 소리다.
	-월입력시 버튼으로 1~12월중선택할수있게하고 그 선택한 값에 월을 붙이지않고 숫자만 파라미터로 보내게
		설정해라





#birth-form.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>


<form action = "#" method = "post" >
	<fieldset>
		<legend>생일 등록 양식</legend>
		<p>
			# 생년월일 :
			<input type = "text" name = "year" size = "6" maxlength = "4" placeholder = "연도(4자리)"/>
			<select name = "month">
	
					<option>${m}월</option>
	
			</select>
			<input type = "text" name = "day" maxlength = "2" size = "4" placeholder = "일(1-31)" />
			<input type = "submit" value = "확인" />
		</p>
	</fieldset>
</form>

</body>
</html>




#birth-result.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	당신의 생일은 ?년 ?월 ?일입니다.
</body>
</html>

##############################################################################



답:






#birth-form.jsp


<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>


<form action = "<c:url value = '/birth'/>" method = "post" >
	<fieldset>
		<legend>생일 등록 양식</legend>
		<p>
			# 생년월일 :
			<input type = "text" name = "year" size = "6" maxlength = "4" placeholder = "연도(4자리)"/>
			<select name = "month">
				<c:forEach var = "m" begin = "1" end = "12" step = "1">
					<option value = "${m}">${m}월</option>
				</c:forEach>
			</select>
			<input type = "text" name = "day" maxlength = "2" size = "4" placeholder = "일(1-31)" />
			<input type = "submit" value = "확인" />
		</p>
	</fieldset>
</form>

</body>
</html>





#birth-result.jsp


<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	당신의 생일은 ${birth.year}년 ${birth.month}월 ${birth.day}일입니다.
</body>
</html>





#BirthController.java
package com.spring.web.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import com.spring.web.model.BirthVO;

@Controller("birC")
public class BirthController {
	@RequestMapping(value = "/birth", method = RequestMethod.GET)
	public String birth() {
		return "birth/birth-form";
	}
	
	@RequestMapping(value = "/birth", method = RequestMethod.POST)
	public String birth(@ModelAttribute("birth") BirthVO birth) {
		System.out.println(birth.getYear()+birth.getMonth()+birth.getDay());
		return "birth/birth-result";
	}
}









#BirthVO
package com.spring.web.model;

public class BirthVO {
	private String year;
	private String month;
	private String day;
	
	
	public BirthVO() {
		// TODO Auto-generated constructor stub
	}


	public String getYear() {
		return year;
	}


	public void setYear(String year) {
		this.year = year;
	}


	public String getMonth() {
		return month;
	}


	public void setMonth(String month) {
		if (Integer.valueOf(month) < 10) {
			this.month = 0 + month;
			return;
		}
		this.month = month;
	}


	public String getDay() {
		return day;
	}


	public void setDay(String day) {
		this.day = day;
	}
	
	
	
}

























##############################################################################
28)form에서 action 없는경우, 재전송요청, null반환

#res-redirect-form.jsp 생성
#res-quiz-success.jsp 생성
#ResponseController.java 이용
	-method : login()
		


사용자입력 uri : /web/response/login
흐름 : client uri -> CM -> /response/res-redirect-form.jsp -> CM
	-> 2가지
		-/resposne/login uri로 재전송요청(get으로들어감)
		-/response/res-quiz-success 열기

	1)id 입력하지 않은경우 처리해라
		-이거 졸라이상함.. post보내면 다시 get으로 받고 로그인누르면 다시 post 가는데 기존 post보낸 userId가 살아
			있음 계속.. 그래서 uri의 파라미터부분을 지워서 직접 get방식으로 다시 접근해서 아이디비번비번확인쳐야됨
	2)비번 다른경우처리
	3)위 abc123 1234와 같은경우 처리
	4)위 abc123 1234와 같지않은경우 처리
		-같지않으면 null을 리턴해서 null 리턴한경우 viewResolver로 뭐가 반환되서 가는지봐라
			-답: null이면 null에 .jsp를 붙일순없으니 Mapping된 uri를 반환한다.
						즉 /response/login.jsp가 되는 것이다. 하지만 우리파일에
						이런 경로와 jsp파일은 없다. 그래서 에러가 날것인데 그게 맞다.
				-근데 나중에 뒤에서 RedirectAttributes하면 또 null.jsp로 됨
					ㅋㅋ 좀더 지켜보자이건.
		**핵심개념은 redirect:/response/login을 반환할경우 (즉 redierect:이 있을경우)
			viewResolver로 보내서 .jsp등을 붙이지않고 viewResolver가기전에 바로 다시 Controller에게 
			오는 것이다.
		**추가 핵심은 redirect될때는 반드시 get방식으로 된다. post방식이 아니다.






#res-redirect-form.jsp 생성

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<%-- ResponseController 사용 --%>


<form method = "post">
<p>
	# ID : <input type = "text" name = "userId" size = "10"> <br>
	# 비밀번호 : <input type = "password" name = "userPw" size = "10"> <br>
	# 비밀번호 확인 : <input type = "password" name = "userPwChk" size = "10"> <br>
	<input type = "submit" value = "로그인">
</p>
</form>

</body>
</html>




#res-quiz-success.jsp 생성

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

	<h2>로그인 성공!!</h2>
	<p>
		( ? )님 환영합니다!!!!!!
	</p>

</body>
</html>



##############################################################################



답:



#res-quiz-success.jsp 생성

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

	<h2>로그인 성공!!</h2>
	<p>
		( ${userId} )님 환영합니다!!!!!!
	</p>

</body>
</html>










#ResponseController.java 이용 : 앞 ResponseController.java와 같음

package com.spring.web.controller;

import javax.servlet.http.HttpSession;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.spring.web.model.UserVO;
import com.spring.web.model.UserVO2;

@Controller("resCon")
@RequestMapping("/response")

public class ResponseController {
	
	public ResponseController() {
		// TODO Auto-generated constructor stub
	}
	
	@GetMapping("/res-ex01")
	public void resEx01() {
		
	}
	
	//1.Model 객체를 사용하여 화면에 데이터 전송하기
	/*
	@GetMapping("/test")
	public void test(@RequestParam("age") int age,
						Model model) {
		model.addAttribute("nick", "뽀삐");
		model.addAttribute("age", age);
	}
	*/
	
	//@ModelAttribute : @RequestParam("age") int age + model.addAttribute("age", age)
					//와 같은 것이다. 포함관계
	//2.@ModelAttribute를 사용한 화면에 데이터 전송처리
	@GetMapping("/test")
	public void test(@ModelAttribute("age") int age,
			Model model) {
		model.addAttribute("nick", "뽀삐");
//		model.addAttribute("age", age);
	}
	
	//3.ModelAndView 객체를 활용한 처리
	@GetMapping("/test2")
	public ModelAndView test2() {
//		ModelAndView mv = new ModelAndView();
//		mv.addObject("userName", "박영희"); //화면에 전달할 데이터 래핑
//		mv.setViewName("/response/test2"); //viewResolver에게 전달할 문자열
//		return mv;
		
		return new ModelAndView("/response/test2", "userName", "박영희");
	}
	
	
	//res-ex02.jsp파일을 열람하는 요청메서드 작성
	@GetMapping("/res-ex02")
	public void resEx02() {
		
	}
	
	
	/*
	@PostMapping("/join")
	public String join(UserVO user, Model model) {
		model.addAttribute("user", user);
		return "response/test3";
	}
	*/
	@PostMapping("/join")
	public String join(@ModelAttribute("user") UserVO user) {
		return "response/test3";
	}
	
	@GetMapping("/res-quiz")
	public void resQuiz() {
		
	}
	
	@PostMapping("/res-login")
	public String resLogin(@ModelAttribute("user") UserVO2 user) {
		String id = user.getUserId();
		String pw = user.getUserPw();
		
		if (id.equals("kim123") && pw.equals("kkk1234")) {
			return "response/res-quiz-success";			
		}
		
		return "response/res-quiz-fail";
	}
	
	
	///////////////////////////////////////////////////////////////////
	//Redirect처리 
	//원래는 viewResolver에게 보내는 방식이 포워드 방식이다.
	//글쓰기 요청이 끝난다음에 글목록 페이지가 떠야하는데 포워드면 요청끝나고 디스패쳐왔다가 다시 db에 가야함
	//글쓰기 요청(insert)가 되고나면 다시 돌아오지않고 재요청으로  select하여 목록을 가져오면 좋다.
	//그 재요청방법이 Redirect처리다.
	//글 삭제같은경우도 delete로 게시글 지우고 목록을 보여줄때 디스패쳐까지 돌아오지않고 재요청을해서 바로 db에서 목록을
	//가져오는 것도 포워드로는 않되고 Redirect로 가능하다.
	
	//로그인 화면 요청처리
	@GetMapping("/login")
	public String login() {
		System.out.println("/response/login 요청 발생 : GET");
		return "response/res-redirect-form";
	}
	
	//로그인 검증처리
	/*
	@PostMapping("/login")
	public String login(@ModelAttribute("userId") String id
							, @RequestParam("userPw") String pw
							, @RequestParam("userPwChk") String pwChk
							, Model model
							//, HttpServletResponse response)원래 이게 jsp방식인데 spirng에선 이렇게 안해도됨
							, HttpSession session
							){
		System.out.println("/response/login 요청 발생 : POST");
		System.out.println("id : " + id); 
		System.out.println("pw : " + pw);
		System.out.println("pwChk : " + pwChk);
		
		
		
		if (id.equals("")) { // 아이디 입력하지 않은 경우
//			response.sendRedirect(); 원래 이게 jsp방식인데 spirng에선 이렇게 안해도됨
			System.out.println("아이디가 비었습니다.");
//			model.addAttribute("msg", "아이디는 필수 값이에요!");
			session.setAttribute("msg", "아이디는 필수 값이에요!");
			return "redirect:/response/login"; // jsp를 열러가지않고 바로 다시 controller의 
												// /resposne/login uri를 받을수있는 메서드를
												// 찾는다.
												//이때 redirect로 보내면 무조건 get요청이다.
												//그래서 위에 로그인화면요청처리로 간다.
		} else if (!pw.equals(pwChk)) { // 비번과 확인비번이 다른 경우
			System.out.println("두 비밀번호가 같지 않습니다.");
//			model.addAttribute("msg", "비밀번호 확인란을 체크하세요!");
			session.setAttribute("msg", "두 비밀번호가 같지 않습니다.");
			return "redirect:/response/login";
		} else if (id.equals("abc123") && pw.equals("1234")) {
			System.out.println("로그인성공!");
			return "response/res-quiz-success";
		} else { // 안전빵
			System.out.println("그런 아이디와 비번은 등록되지 않았습니다.");
//			model.addAttribute("msg", "그런 아이디와 비번은 등록되지 않았습니다.");
			return null;
		}
	}
	*/
	@PostMapping("/login")
	public String login(@ModelAttribute("userId") String id
							, @RequestParam("userPw") String pw
							, @RequestParam("userPwChk") String pwChk
							, RedirectAttributes ra
//							, HttpSession session
							, Model model
							){
		System.out.println("/response/login 요청 발생 : POST");
		System.out.println("id : " + id); 
		System.out.println("pw : " + pw);
		System.out.println("pwChk : " + pwChk);
		
		
		
		if (id.equals("")) { // 아이디 입력하지 않은 경우
			System.out.println("아이디가 비었습니다.");
			ra.addFlashAttribute("msg2", "아이디는 필수 값이에요!");
//			session.setAttribute("msg1", "아이디는 필수 값이에요!");
//			model.
			return "redirect:/response/login"; 
		} else if (!pw.equals(pwChk)) { // 비번과 확인비번이 다른 경우
			System.out.println("두 비밀번호가 같지 않습니다.");
			ra.addFlashAttribute("msg2", "두 비밀번호가 같지 않습니다.");
//			session.setAttribute("msg1", "두 비밀번호가 같지 않습니다.");
			return "redirect:/response/login";
		} else if (id.equals("abc123") && pw.equals("1234")) {
			System.out.println("로그인성공!");
			
			return "response/res-quiz-success";
		} else { // 안전빵
			System.out.println("그런 아이디와 비번은 등록되지 않았습니다.");
			return null;
		}
	}
	
	
}




















##############################################################################
29)model, session한계, 재전송시 효율높은 scope 객체


1)위 문제 res-redirect를 아래 설명처럼 살짝 손봐서 화면에 추가내용을 넣음으로
	model의 한계와 session의 단점과 재전송시 가장 효율적인 데이터전송방법을 알아보시오.

매개변수 Model model 추가
msg라는 모델id에 대해서 각상황이오면 상황에맞게 아래 3개 중 하나를 넣어라
	-"비밀번호 확인란을 체크하세요!"
	-"그런 아이디와 비번은 등록되지 않았습니다."
	-"아이디는 필수 값이에요!"
그후 모델 id에 대한 값을 res-redirect-form에서 실패한경우(3가지)에 대해서 model value를 빨간글자로 
출력하게하라
	-빨간글자 안뜬다 그 이유는 model이 request객체와같이 재전송시에는 데이터를 잃어버리기때문이다.
		즉 바로다음 영역으로 갔을때는 살아있고 거기서 다시 다른영역으로 가면 사라진다.
		그럼 최초 get() 상태에서 로그인눌러스 post()방식으로 파라미터를 login()에 보냈고
		해당 파라미터를 login()에서 모델에 담았고 여기서 2가지다
		ㄱ.원래방식
			-모델이 담고 String값을 viewResolver에게 반환하여 .jsp를 찾아가서 거기서 model값을 활용한다.
		ㄴ.재전송방식
			-모델이 담고 .jsp로 가는게 아니라 바로 다시 컨트롤러로 오니까 영역이 바껴서 컨트롤러에서는 model 사용
				가능하지만 거기서 다시 jsp를 열었을때는 이미 소실되고 난이후다. 두영역을 갔으니까

	
model을 잠시 주석처리하고 session처럼 여러영역을 돌아다닐수있는놈들은 어떤가 보자.
session을 이용해서 똑같이 msg에 담아봐라
그럼 msg 내용이 계속 남아있고 f5할때마다 변하지 않는다.
그렇기때문에 잠깐 재전송할때만 쓰는걸 사용해서 풀어라.
	-f5할때 그때그때 변하도록해라

	-근데 진짜 희한한게 msg를 msg1 msg2 msg3안바꿔주면 나중에 했던 값들이 계속 남아있는데 그게 세션값인듯하고(주석번갈아끼우면서
											생긴세션값)
		그놈을 없애려고 브라우저도 껐다키고 서버도 껏다켰는데 안사라진다.
	-그리고 세션을 해도 userId가 계속 붙는걸 해결함. 왜 @ModelAttribute 문제를 session과 얘들 msg를 세팅하는걸로
		해결이 되는가?
		-session에 한번담기고나면 msg1 msg2 식으로 이름바꾸는게 편하다.


##############################################################################



답:


#res-redirect-form.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<%-- ResponseController 사용 --%>


<form method = "post">
<p>
	# ID : <input type = "text" name = "userId" size = "10"> <br>
	# 비밀번호 : <input type = "password" name = "userPw" size = "10"> <br>
	# 비밀번호 확인 : <input type = "password" name = "userPwChk" size = "10"> <br>
	<input type = "submit" value = "로그인">
</p>
</form>


<p style="color:red;">${msg2}</p>

</body>
</html>



#ResponseController.java
package com.spring.web.controller;

import javax.servlet.http.HttpSession;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.spring.web.model.UserVO;
import com.spring.web.model.UserVO2;

@Controller("resCon")
@RequestMapping("/response")

public class ResponseController {
	
	public ResponseController() {
		// TODO Auto-generated constructor stub
	}
	
	@GetMapping("/res-ex01")
	public void resEx01() {
		
	}
	
	//1.Model 객체를 사용하여 화면에 데이터 전송하기
	/*
	@GetMapping("/test")
	public void test(@RequestParam("age") int age,
						Model model) {
		model.addAttribute("nick", "뽀삐");
		model.addAttribute("age", age);
	}
	*/
	
	//@ModelAttribute : @RequestParam("age") int age + model.addAttribute("age", age)
					//와 같은 것이다. 포함관계
	//2.@ModelAttribute를 사용한 화면에 데이터 전송처리
	@GetMapping("/test")
	public void test(@ModelAttribute("age") int age,
			Model model) {
		model.addAttribute("nick", "뽀삐");
//		model.addAttribute("age", age);
	}
	
	//3.ModelAndView 객체를 활용한 처리
	@GetMapping("/test2")
	public ModelAndView test2() {
//		ModelAndView mv = new ModelAndView();
//		mv.addObject("userName", "박영희"); //화면에 전달할 데이터 래핑
//		mv.setViewName("/response/test2"); //viewResolver에게 전달할 문자열
//		return mv;
		
		return new ModelAndView("/response/test2", "userName", "박영희");
	}
	
	
	//res-ex02.jsp파일을 열람하는 요청메서드 작성
	@GetMapping("/res-ex02")
	public void resEx02() {
		
	}
	
	
	/*
	@PostMapping("/join")
	public String join(UserVO user, Model model) {
		model.addAttribute("user", user);
		return "response/test3";
	}
	*/
	@PostMapping("/join")
	public String join(@ModelAttribute("user") UserVO user) {
		return "response/test3";
	}
	
	@GetMapping("/res-quiz")
	public void resQuiz() {
		
	}
	
	@PostMapping("/res-login")
	public String resLogin(@ModelAttribute("user") UserVO2 user) {
		String id = user.getUserId();
		String pw = user.getUserPw();
		
		if (id.equals("kim123") && pw.equals("kkk1234")) {
			return "response/res-quiz-success";			
		}
		
		return "response/res-quiz-fail";
	}
	
	
	///////////////////////////////////////////////////////////////////
	//Redirect처리 
	//원래는 viewResolver에게 보내는 방식이 포워드 방식이다.
	//글쓰기 요청이 끝난다음에 글목록 페이지가 떠야하는데 포워드면 요청끝나고 디스패쳐왔다가 다시 db에 가야함
	//글쓰기 요청(insert)가 되고나면 다시 돌아오지않고 재요청으로  select하여 목록을 가져오면 좋다.
	//그 재요청방법이 Redirect처리다.
	//글 삭제같은경우도 delete로 게시글 지우고 목록을 보여줄때 디스패쳐까지 돌아오지않고 재요청을해서 바로 db에서 목록을
	//가져오는 것도 포워드로는 않되고 Redirect로 가능하다.
	
	//로그인 화면 요청처리
	@GetMapping("/login")
	public String login() {
		System.out.println("/response/login 요청 발생 : GET");
		return "response/res-redirect-form";
	}
	
	//로그인 검증처리
	/*
	@PostMapping("/login")
	public String login(@ModelAttribute("userId") String id
							, @RequestParam("userPw") String pw
							, @RequestParam("userPwChk") String pwChk
							, Model model
							//, HttpServletResponse response)원래 이게 jsp방식인데 spirng에선 이렇게 안해도됨
							, HttpSession session
							){
		System.out.println("/response/login 요청 발생 : POST");
		System.out.println("id : " + id); 
		System.out.println("pw : " + pw);
		System.out.println("pwChk : " + pwChk);
		
		
		
		if (id.equals("")) { // 아이디 입력하지 않은 경우
//			response.sendRedirect(); 원래 이게 jsp방식인데 spirng에선 이렇게 안해도됨
			System.out.println("아이디가 비었습니다.");
//			model.addAttribute("msg", "아이디는 필수 값이에요!");
			session.setAttribute("msg", "아이디는 필수 값이에요!");
			return "redirect:/response/login"; // jsp를 열러가지않고 바로 다시 controller의 
												// /resposne/login uri를 받을수있는 메서드를
												// 찾는다.
												//이때 redirect로 보내면 무조건 get요청이다.
												//그래서 위에 로그인화면요청처리로 간다.
		} else if (!pw.equals(pwChk)) { // 비번과 확인비번이 다른 경우
			System.out.println("두 비밀번호가 같지 않습니다.");
//			model.addAttribute("msg", "비밀번호 확인란을 체크하세요!");
			session.setAttribute("msg", "두 비밀번호가 같지 않습니다.");
			return "redirect:/response/login";
		} else if (id.equals("abc123") && pw.equals("1234")) {
			System.out.println("로그인성공!");
			return "response/res-quiz-success";
		} else { // 안전빵
			System.out.println("그런 아이디와 비번은 등록되지 않았습니다.");
//			model.addAttribute("msg", "그런 아이디와 비번은 등록되지 않았습니다.");
			return null;
		}
	}
	*/
	@PostMapping("/login")
	public String login(@ModelAttribute("userId") String id
							, @RequestParam("userPw") String pw
							, @RequestParam("userPwChk") String pwChk
							, RedirectAttributes ra
//							, HttpSession session
							, Model model
							){
		System.out.println("/response/login 요청 발생 : POST");
		System.out.println("id : " + id); 
		System.out.println("pw : " + pw);
		System.out.println("pwChk : " + pwChk);
		
		
		
		if (id.equals("")) { // 아이디 입력하지 않은 경우
			System.out.println("아이디가 비었습니다.");
			ra.addFlashAttribute("msg2", "아이디는 필수 값이에요!");
//			session.setAttribute("msg1", "아이디는 필수 값이에요!");
//			model.
			return "redirect:/response/login"; 
		} else if (!pw.equals(pwChk)) { // 비번과 확인비번이 다른 경우
			System.out.println("두 비밀번호가 같지 않습니다.");
			ra.addFlashAttribute("msg2", "두 비밀번호가 같지 않습니다.");
//			session.setAttribute("msg1", "두 비밀번호가 같지 않습니다.");
			return "redirect:/response/login";
		} else if (id.equals("abc123") && pw.equals("1234")) {
			System.out.println("로그인성공!");
			
			return "response/res-quiz-success";
		} else { // 안전빵
			System.out.println("그런 아이디와 비번은 등록되지 않았습니다.");
			return null;
		}
	}
	
	
}
























































































21.02.09.6회차
===============================================================================
*SpringFrameWork를 이용하여 학생들의 점수를 관리하는 웹어플리케이션 제작(db는 list로 대체)
===============================================================================

































































##############################################################################
30)MVC패턴으로 점수등록, 점수확인, 삭제, 개별조회
	-MVC패턴  흐름 (Controller -> Service -> Repository(DAO) -> DB)
		-각각 의존성이다. Controller는 service가 있어야하고 등등
	


1)학생들의 점수를 등록하고 삭제할수있으며 list.jsp 출력하였을때 전체학생의 점수를 볼수있도록 mvc 패턴으로 웹어플리케이션을 만드시오.
	-각 클래스 이름에 맞는 아노테이션 사용하여 디스패쳐가 자동빈등록할수 있도록 하고 
		차후 스캔해서 singleton형식의 객체들을 사용한다.(autowired)

client uri : http/localhost:8080/web/score/register

<controller>
ScoreController.java
	-/score/delete 요청시에는 해당 학번의 학생정보 삭제처리한뒤에
		웹창에서 바로 삭제된결과가 보여야한다.

<model>
ScoreVO.java

<repository> : (DAO)
IScoreDAO.java // interface
ScoreDAO.java
	-현재 db가 없으니 scoreList라는 list 변수 만들어서 사용
	-삭제시 deleteScore()를 사용하라
<service>
IScoreService.java
ScoreService.java

<views/score>
write-form.jsp
	-post 요청 uri : /web/score/register
write-result.jsp
list.jsp
	-학번만 list.jsp에서 생성하여 넣어라.
		-학번을 jstl이용해서 변수 stuNum만들고 1번부터 한놈당 부여. 전체 리스트 조회할때 한놈나올때마다 제일앞에
				-이때 인덱스는 0부터 나오니 1더해야함
<IScoreDAO, IScoreService 메소드>
		// 매개변수의 ?는 공백일수도, 존재할수도 있다.
	//점수 등록 기능 
	void insertScore(?);
	
	//점수 전체 조회 기능
	List<ScoreVO> selectAllScores(?);
	
	//점수 삭제기능
	void deleteScore(?); // stuNum을 사용
	
<write-form.jsp 출력화면>
시험 점수 등록
# 이름 : 
	
# 국어 : 

# 영어 : 

# 수학 : 

확인

<write-result.jsp 출력화면>
점수 등록 성공!
다른 점수 등록하기 점수 전체 조회 점수 개별 조회(이놈은 이문제에서 만드는게 아니니까 uri #으로 해놔라)


<최종결과> : list.jsp페이지 출력화면
학생들의 전체 성적 조회
# 학번 : 1, 이름 : 박여으히, 국어 : 50, 영어 : 39, 수학 : 99, 총점 : 188, 평균 : 62.67   [삭제]

# 학번 : 2, 이름 : 김철수, 국어 : 55, 영어 : 99, 수학 : 23, 총점 : 177, 평균 : 59.0   [삭제]

다른 점수 등록하기

<위의 김철수의 삭제 클릭시 최종결과> : 삭제 완료하면 아래 결과에다가 위에 팝업을 js로 띄워서 점수 삭제 완료! 
				라고 표시해라. f12하면 나오는곳의 console에는 delSuccess가 뜨게하라
					-중간에 만들어야할 변수 이름들은 자유롭게
학생들의 전체 성적 조회
# 학번 : 1, 이름 : 박여으히, 국어 : 50, 영어 : 39, 수학 : 99, 총점 : 188, 평균 : 62.67   [삭제]

다른 점수 등록하기









2)위의 상황에서 개별점수 조회기능이 돌아가도록 mvc패턴에 입각하여 앱을 설계하라
-/selectOne 요청을 통해 해당 학번을 가진 학생의 성적정보를 조회하여 search-result.jsp에서 해당 정보를
	화면에 출력하세요.
	-아래 제공된 search.jsp를 이용하시오
		-조회할 학번에 존재하지 않는 학번입력시 아래에 학번정보가 없습니다. 라고 빨간글씨띄워라
		-search.jsp로 가기위한 uri : /score/search
				-근데 그냥 selectOne()메소드로 통일해서
					/score/selectOne 으로 해도 됨 자유
-기존 service, dao의 메서드에서 추가로 더 만들어야함
	-이름은 자유롭게 혹은 selectOneScore(?)
-아래 메세지가 출력될 상황이 나면 search.jsp에서 조회할 학번 아래에 빨간글자로 아래 메세지를 출력하라.
	-없는 학번을 입력할시 : 학번정보가 없습니다.
	-숫자가아닌 문자를 입력할시 : 숫자로만 입력하세요!


#search.jsp 

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>개별 점수 조회</h2>
<form action = "/web/score/selectOne">
	<p>
		#조회할 학번 : <input type = "text" name = "stuNum" size = "5">
				   <input type = "submit" value = "조회">
	</p>
</form>

</body>
</html>

##############################################################################



답:

---------------------------------------

<controller>
ScoreController.java

package com.spring.web.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.spring.web.model.ScoreVO;
import com.spring.web.service.IScoreService;

@Controller
@RequestMapping("/score")
public class ScoreController {
	@Autowired
	private IScoreService service;
	
	//점수 등록 화면을 열어주는 처리를 하는 요청메서드
	@GetMapping("/register")
	public String register() {
		System.out.println("/score/register: GET");
		return "score/write-form";
	}
	
	//점수 등록을 처리하는 요청 메서드
	@PostMapping("/register")
	public String register(ScoreVO scores) {
		System.out.println("/score/register: POST");
		System.out.println("Controller param: " + scores);
		
		service.insertScore(scores);
		return "score/write-result";
	}
	
	//점수 전체 조회를 처리하는 요청 메서드
	@GetMapping("/list")
	public void list(Model model) {
		System.out.println("/score/list: GET");
		List<ScoreVO> list = service.selectAllScores();
		model.addAttribute("sList", list);
		
	}
	
	//점수 삭제 요청 처리 메서드
	@GetMapping("/delete")
	public String delete(@RequestParam("stuNum") int stuNum, RedirectAttributes ra) {
		List<ScoreVO> list = service.selectAllScores();
		service.deleteScore(stuNum);
		ra.addFlashAttribute("message", "delSuccess");
		return "redirect:/score/list";
	}
	
	//점수 개별 조회 화면 열람요청 메서드
	@GetMapping("/search")
	public void search() {
		System.out.println("/score/search: GET");
		
	}
	
	@PostMapping("/selectOne")
	public String selectOne(String stuNum, Model model, RedirectAttributes ra) {
		
		/*
		try {
			ScoreVO stu = service.selectOneScore(Integer.parseInt(stuNum));			
			model.addAttribute("stu", stu);
			return "/score/select-result";
		} catch(NumberFormatException e) {
			ra.addFlashAttribute("message", "숫자로만 입력하세요!");
			return "redirect:/score/search"; 
		} catch(IndexOutOfBoundsException e) {
			ra.addFlashAttribute("message", "학번정보가 없습니다.");
			return "redirect:/score/search";
		} 
		*/
		List<ScoreVO> list = service.selectAllScores();
		
		try {
			int n = Integer.parseInt(stuNum);
			if (n > list.size()) {
				ra.addFlashAttribute("message", "학번정보가 없습니다.");
				return "redirect:/score/search";
			}
			
			ScoreVO stu = service.selectOneScore(n);			
			model.addAttribute("stu", stu);
			return "score/select-result";
		} catch(NumberFormatException e) {
			ra.addFlashAttribute("message", "숫자로만 입력하세요!");
			return "redirect:/score/search"; 
		} 
	}
}




---------------------------------------


<model>
ScoreVO.java


package com.spring.web.model;

public class ScoreVO {
	private String stuName;
	private Integer kor;
	private Integer eng;
	private Integer math;
	private Integer total;
	private Double average;
	
	
	public ScoreVO() {
		// TODO Auto-generated constructor stub
	}
	
	
	//총점 평균을 구하는 메서드
	public void calcData() {
		this.total = this.kor + this.eng + this.math;
		this.average = Math.round((this.total / 3.0) * 100) / 100.0;
		
	}
	
	public String getStuName() {
		return stuName;
	}
	public void setStuName(String stuName) {
		this.stuName = stuName;
	}
	public Integer getKor() {
		return kor;
	}
	public void setKor(Integer kor) {
		this.kor = kor;
	}
	public Integer getEng() {
		return eng;
	}
	public void setEng(Integer eng) {
		this.eng = eng;
	}
	public Integer getMath() {
		return math;
	}
	public void setMath(Integer math) {
		this.math = math;
	}
	public Integer getTotal() {
		return total;
	}
	public void setTotal(Integer total) {
		this.total = total;
	}
	public Double getAverage() {
		return average;
	}
	public void setAverage(Double average) {
		this.average = average;
	}


	@Override
	public String toString() {
		return "ScoreVO [stuName=" + stuName + ", kor=" + kor + ", eng=" + eng + ", math=" + math + ", total=" + total
				+ ", average=" + average + "]";
	}
	
	
	
	
}


---------------------------------------



<repository> : (DAO)

#IScoreDAO.java // interface

package com.spring.web.repository;

import java.util.List;

import com.spring.web.model.ScoreVO;

public interface IScoreDAO {
	//점수 등록 기능
	void insertScore(ScoreVO scores);
	
	//점수 전체 조회 기능
	List<ScoreVO> selectAllScores();
	
	//점수 삭제기능
	void deleteScore(int stuNum);
	
	ScoreVO selectOneScore(int stuNum);
}




#ScoreDAO.java
	-현재 db가 없으니 scoreList라는 list 변수 만들어서 사용
	-삭제시 deleteScore()를 사용하라


package com.spring.web.repository;

import java.util.ArrayList;
import java.util.List;

import org.springframework.stereotype.Repository;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.spring.web.model.ScoreVO;

@Repository
public class ScoreDAO implements IScoreDAO {
	//학생들의 점수정보를 저장할 리스트 생성(DB대용)_ DB대용 : scoreList
	private List<ScoreVO> scoreList = new ArrayList<>();
	
	@Override
	public void insertScore(ScoreVO scores) {
		// TODO Auto-generated method stub
		System.out.println("Repository param: " + scores);
		scoreList.add(scores);
	}

	@Override
	public List<ScoreVO> selectAllScores() {
		// TODO Auto-generated method stub
		return scoreList;
	}

	@Override
	public void deleteScore(int stuNum) {
		// TODO Auto-generated method stub
		scoreList.remove(stuNum - 1);
	}

	public ScoreVO selectOneScore(int stuNum) {
		return scoreList.get(stuNum - 1);
	}
}


---------------------------------------




<service>
#IScoreService.java

package com.spring.web.service;

import java.util.List;

import com.spring.web.model.ScoreVO;

public interface IScoreService {
	//점수 등록 기능
	void insertScore(ScoreVO scores);
	
	//점수 전체 조회 기능
	List<ScoreVO> selectAllScores();
	
	//점수 삭제기능
	void deleteScore(int stuNum);
	
	ScoreVO selectOneScore(int stuNum);
	
}





#ScoreService.java

package com.spring.web.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.spring.web.model.ScoreVO;
import com.spring.web.repository.IScoreDAO;


@Service
public class ScoreService implements IScoreService {

	@Autowired
	private IScoreDAO dao;
	
	@Override
	public void insertScore(ScoreVO scores) {
		// TODO Auto-generated method stub
		scores.calcData();
		dao.insertScore(scores);
	}

	@Override
	public List<ScoreVO> selectAllScores() {
		// TODO Auto-generated method stub
		return dao.selectAllScores();
	}

	@Override
	public void deleteScore(int stuNum) {
		// TODO Auto-generated method stub
		dao.deleteScore(stuNum);
	}
	
	public ScoreVO selectOneScore(int stuNum) {
		return dao.selectOneScore(stuNum);
	}

}


---------------------------------------




<views/score>
#write-form.jsp


<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>시험 점수 등록</h2>
<form method = "post">
	<p>
		# 이름 : <input type = "text" name = "stuName"><br>
		# 국어 : <input type = "text" name = "kor"><br>
		# 영어 : <input type = "text" name = "eng"><br>
		# 수학 : <input type = "text" name = "math"><br>
		<input type = "submit" value = "확인">
	</p>
</form>

</body>
</html>



#write-result.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	<h2>점수 등록 성공!</h2>
	<a href = "/web/score/register">다른 점수 등록하기</a>
	<a href = "/web/score/list">점수 전체 조회</a>
	<a href = "/web/score/search">점수 개별 조회</a>

</body>
</html>


#list.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>    
    
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>학생들의 전체  성적 조회</h2>
<c:forEach var = "stu" items = "${sList}" varStatus = "stuNum">
	<p>
		# 학번 : ${stuNum.index + 1}, 이름 : ${stu.stuName}, 국어 : ${stu.kor}, 영어 : ${stu.eng},
		 수학 : ${stu.math}, 총점 : ${stu.total}, 평균 : ${stu.average}
		&nbsp;
		<a href = "/web/score/delete?stuNum=${stuNum.index + 1}">[삭제]</a>	
	</p>
</c:forEach>

<a href = "/web/score/register">다른 점수 등록하기</a> 
<a href = "/web/score/list">점수 전체 조회</a>
<a href = "/web/score/search">점수 개별 조회</a>

<script type = "text/javascript">
	const msg = "${message}";
	console.log(msg);
	if (msg === "delSuccess") {
		alert("점수 삭제 완료!");
	}
</script>


</body>
</html>




#search.jsp


<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>개별 점수 조회</h2>
<form action = "/web/score/selectOne" method = "post">
	<p>
		#조회할 학번 : <input type = "text" name = "stuNum" size = "5">
				   <input type = "submit" value = "조회">
	</p>
</form>

<p style = "color:red;">
	${message}
</p>

</body>
</html>



#select-result.jsp




<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>${stu.stuName}학생 성적 정보 조회</h2>

<p>	
	# 국어 : ${stu.kor} <br>
	# 영어 : ${stu.eng} <br>
	# 수학 : ${stu.math} <br>
	# 총점 : ${stu.total} <br>
	# 평균 : ${stu.average} 
</p>

<a href = "/web/score/register">다른 점수 등록하기</a> 
<a href = "/web/score/list">점수 전체 조회</a>
<a href = "/web/score/search">점수 개별 조회</a>

</body>
</html>

