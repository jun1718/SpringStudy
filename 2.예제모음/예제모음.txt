21.02.03.1회차
===============================================================================
*maven, spring모듈추가, bean객체, DI(의존성주입)
===============================================================================


##############################################################################
1)Spring 환경구축 및 모듈 추가

1-1)매이븐 프로젝트 만들기
project : maven project
	-만들때 create a simple project해야 기본설정이 들어옴 
group id : com.spring 
Artifact id : basicReivew
		-생각해보니이거 basic해도 됨 workspace 이름만다르면되고 내부에서 artifat id group id 동일해도 상관없음.. 

	*메이븐 프로젝트 만드는 이유
		-필요한 라이브러리(모듈, API)에 관한 정보를 특정문서(pom.xml)에 정의해 놓으면 네트워크를 통해서
		 라이브러리들을 자동으로 설치해준다. 직접 수동으로 설치해서 집어넣을수도 있지만 메이븐프로젝트는 이렇게
		 자동설치의 이점이 있기에 사용한다.
	*메이븐 자동설치 전제조건
		-maven repository 사이트에서 라이브러리에 관한 정보가 정의된 것을 복사해와야함
			-maven repository : 메이븐 프로젝트에서 자동으로 모듈들 검색하여 설치할수있도록 관련 정보들을 모아놓은 사이트

1-2)프로젝트 기본 환경구축
encoding하여 web언어들이나 workspace, xml등 모두 utf-8인 유니코드로 변경
						-기존의 Korean, EUC로하면 ㄱ ㄴ ㄷ 을 못읽음
화면 블랙

1-3)설정추가(pom.xml)
	-설정추가는 앞으로 나올 dependencies 즉 의존성때문에 설치해야하는 모듈들을 묶어놓은 그룹 아래에 작성한다.
build 설정추가 : build안하고 모듈추가 즉 메이븐프로젝트의 기능을 사용가능한지 확인해바라
	-maven도 자바라이브러리중 하나이고 java와 본인간에 호환성을 맞추기위한 설정이 필요하다.
	-아래에서 build가 그설정이며 maven의 컴파일러는 뭘로할것이고 메이븐의 버젼은몇이고 자바의 버전은 1.8이고 등등의 설정이다.
		-이걸 설정추가안하면 maven프로젝트을 사용할수는 >????모르겠당
			-실험결과 가능, 기본값이 있는것으로 파악됨 다만 build하고나서 반드시 alt f5하여서 바뀐걸 알려줘야함
	<build>
		<plugins>
			<plugin>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.5.1</version>
				<configuration>
					<source>1.8</source>
					<target>1.8</target>
					<encoding>utf-8</encoding>
				</configuration>
			</plugin>
		</plugins>
	</build>

1-4)메이븐 기능인 모듈추가(pom.xml) 적용해보기
	-maven repository에서 사람들이 가장 많이받고 상위에있는걸 선택하면 된다.
	-이때 라이브러리가 어디에 저장되는가?
		-C:\Users\USER\.m2\repository\org\springframework
		-spring-context를 설치했지만 내부에는 파일이 엄청 많을건데 해당 context를 이용하기위한 의존성 파일들(라이브러리)
			까지 함께 추가된것으로 인지하면 되겠다.
		
spring 모듈 추가
	검색 keyword : spring-context => 5.1.5 설치(회사에선상관없는데 지금은 환경통일을위해 이렇게한다 아래도 마찬가지)

jstl 모듈 추가
	검색 keyword : jstl => 1.2버전

##############################################################################


답:


<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>com.spring</groupId>
	<artifactId>basic</artifactId>
	<version>0.0.1-SNAPSHOT</version>

	<!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
	<dependencies>
		<!-- Spring-context 모듈 -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
			<version>5.1.5.RELEASE</version>
		</dependency>

		<!-- jstl 모듈 -->
		<!-- https://mvnrepository.com/artifact/javax.servlet/jstl -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jstl</artifactId>
			<version>1.2</version>
		</dependency>
		
		
	</dependencies>
	<build>
		<plugins>
			<plugin>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.5.1</version>
				<configuration>
					<source>1.8</source>
					<target>1.8</target>
					<encoding>utf-8</encoding>
				</configuration>
			</plugin>
		</plugins>
	</build>
</project>













##############################################################################
2)resources의 xml을 이용하여 spring 컨테이너에 객체 생성후 사용
	-Spring을 DI frame work 혹은 Ioc frame work 라고도 한다
	-xml에서 bean을 통해 객체를 만드는 코드를 작성하고 main code에서 xml을 실행시켜 bean객체가 만들어지면 그것이
		spring 컨테이너에 들어감

<package 생성> : com.spring.basic

	-위치 : src/main/java 디렉터리 내부
	-원래 루트 패키지는 gid와 아티팩트 id를 붙여서 만든다.
		-root 패키지: 모든 코드가 출발하는 첫번재 디렉토리

<class 생성>
	-위치 : com.spring.basic 패키지(루트패키지) 내부
	-클래스1 이름 : SpringTest
		-메서드 : hello()
			- "스프링 객체주입 테스트 ~"를 출력하는 메서드
	-클래스2 이름 : HelloSpring
		-메서드 : 없음

<xml 생성>
	-위치 : src/main/resources
		-resources가 설정이되는 xml 파일이 들어가는 곳임
		-java는 java의 코드들이 들어감 
			-resources 설정에 bean만들고 뭐하고 계속 쓰는이유가 java 코드는 안만지고 resources의 설정만
				바꾸면 논리적으로 간단하니까 그런거임
	-이름 : test-config.xml

xml 생성시 아래코드를 추가하고 그안에 다른값을 만들어야함
<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd">
</beans>

1)SpringTest클래스의 인스턴스를 HelloSpring에 만들어서 인스턴스의 hello()메서드 실행
-구석기시대방식으로 출력해보기
		
-최신식으로 출력해보기(test-config.xml을 이용하여 설정에서 인스턴스를 만들고 그걸 전달받아서 구동)
	-bean id : test
	-다끝나면 ct 닫아라 꼭

##############################################################################

답:

<class 생성> : HelloSpring은 아래 1번 답에 있음
package com.spring.basic;

public class SpringTest {
	public void hello() {
		System.out.println("스프링 객체주입 테스트 ~");
	}
}

<xml 생성>
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd">
	<bean id = "test" class = "com.spring.basic.SpringTest" />
</beans>



1)SpringTest클래스의 인스턴스를 HelloSpring에 만들어서 인스턴스의 hello()메서드 실행
-구석기시대방식으로 출력해보기
		package com.spring.basic;

import org.springframework.context.support.GenericXmlApplicationContext;

public class HelloSpring {
	public static void main(String[] args) {
		System.out.println("안녕 스프링~!");
		
		SpringTest st = new SpringTest();
		st.hello();
	}
}

-최신식으로 출력해보기(test-config.xml을 이용하여 설정에서 인스턴스를 만들고 그걸 전달받아서 구동)
	-위의 xml과 함께 호환되어야함.

package com.spring.basic;

import org.springframework.context.support.GenericXmlApplicationContext;

public class HelloSpring {
	public static void main(String[] args) {

		GenericXmlApplicationContext ct = 
				new GenericXmlApplicationContext("classpath:test-config.xml");
		SpringTest st = ct.getBean("test", SpringTest.class);
		
		st.hello();
		ct.close();
	}
}














##############################################################################
3)di(의존성주입) 
	-주입코드를(의존객체를) 넣는방법(의존성주입하는법)
			-의존객체 : 대상객체 
				-의존성이 있는 두 객체에는 대상객체와 의존적인 객체가 있다. 이때 대상객체가 의존객체다.
					-대상객체: 특정객체가 어느객체에 의존적일때 의존성을 충족시키는 객체가 대상객체임
				-쉽게말해서 의존객체는 충분조건, 의존적인 객체는 필요조건
		-구시대적(수동적 주입)
			-생성자를 이용해서 넣기
			-setter를 통한 의존성 주입

		-현시대적(자동적 주입)
			-생성자를 이용해서 넣기
			-setter를 통한 의존성 주입

<packages 생성>
	-위치 : src/main/java
	-이름 : com.spring.basic.ex01

<class 생성>
	-위치 : com.spring.basic.ex01 패키지
	-구조 : Chef -> Restaurant -> Hotel 형식으로 의존성 생성(생성자를 이용하여 의존성구현)

	-이름 : Chef
		-인스턴스 생성시 "요리사가 출근함!" 출력하게 클래스 생성
		-메서드 : cook()
			-"요리사가 요리를 합니다."를 출력하는 메서드 구현
	-이름 : Restaurant
		-field : chef라는 Chef 클래스의 인스턴스 주소를 담을 참조변수 생성(변수만 생성)
		-생성자에서 처리할 것
			-인스턴스 생성시 "레스토랑이 생성됨!" 출력하게 클래스 생성
			-생성자의 매개변수를 통해서 필드인 chef에 주소값 저장(즉 Chef 클래스의 인스턴스생성)
		-메서드 : orderDinner()
			-"저녁식사를 주문합니다."를 출력하는 메서드 구현
			-내부에서 Chef클래스의 인스턴스의 cook()메서드 실행

	-이름 : Hotel
		-field : Restaurant 클래스의 인스턴스 주소를 저장할 멤버변수 res 생성
		-생성자
			-인스턴스 생성시 "호텔이 생성됨!"을 출력
			-인스턴스 생성시 생성자매개변수를 통해 res field에 값저장
		-메서드 : reserveRestaurant()
			-해당 메서드를 실행시 "레스토랑을 예약합니다."를 출력
			-res field를 이용해서 orderDinner() 메서드 실행
			-즉 reserveRestaurant()메서드 실행함으로 Chef까지 의존관계 객체를 모두 사용


	-이름 : MainClass
		
1)MainClass에서 아래 출력결과가 나오도록 실행
1-1)수동적으로 의존성 주입
1-2)자동적으로(test-config.xml이용하여 의존성 해결 및 bean으로 객체 생성) 의존성 주입
	bean id 
		-chef
		-res
		-hotel

<출력결과>
요리사가 출근함!
레스토랑이 생성됨!
호텔이 생성됨!
레스토랑을 예약합니다.
저녁식사를 주문합니다.
요리사가 요리를 합니다.


##############################################################################


답:





package com.spring.basic.ex01;

public class Chef {
	public Chef() {
		System.out.println("요리사가 출근함!");
	}
	public void cook() {
		System.out.println("요리사가 요리를 합니다.");
	}
}



package com.spring.basic.ex01;

public class Restaurant {
	private Chef chef;
	
	public Restaurant(Chef chef) {
		// TODO Auto-generated constructor stub
		this.chef = chef;
		
		System.out.println("레스토랑이 생성됨!");
	}
	
	public void orderDinner() {
		System.out.println("저녁식사를 주문합니다.");
		chef.cook();
	}
}



package com.spring.basic.ex01;

public class Hotel {
	
	private Restaurant res;
	
	public Hotel(Restaurant res) {
		this.res = res;
		System.out.println("호텔이 생성됨!");
	}
	
	public void reserveRestaurant() {
		System.out.println("레스토랑을 예약합니다.");
		res.orderDinner();
	}
}




1)MainClass에서 아래 출력결과가 나오도록 실행
1-1)수동적으로 의존성 주입

package com.spring.basic.ex01;

import org.springframework.context.support.GenericXmlApplicationContext;

public class MainClass {

	public static void main(String[] args) {
		Hotel hotel = new Hotel(new Restaurant(new Chef()));
		hotel.reserveRestaurant();
	}

}




1-2)자동적으로(test-config.xml이용하여 의존성 해결 및 bean으로 객체 생성) 의존성 주입

1-2-1)test-config.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd">
	<bean id = "test" class = "com.spring.basic.SpringTest" />
	
	<!--  Hotel 객체와 의존객체들의 빈 등록 및 의존성 주입설정 -->
	<bean id = "chef" class = "com.spring.basic.ex01.Chef" />
	<bean id = "res" class = "com.spring.basic.ex01.Restaurant" >
		<constructor-arg ref = "chef" />
	</bean>
	<bean id = "hotel" class = "com.spring.basic.ex01.Hotel" >
		<constructor-arg ref = "res" />
	</bean>
</beans>


1-2-2)MainClass
package com.spring.basic.ex01;

import org.springframework.context.support.GenericXmlApplicationContext;

public class MainClass {

	public static void main(String[] args) {
		GenericXmlApplicationContext ct =
				new GenericXmlApplicationContext("classpath:test-config.xml");
		Hotel hotel = ct.getBean("hotel", Hotel.class);
		
		hotel.reserveRestaurant();
	}
}







































































21.02.04.2회차
===============================================================================
*setter의존성주입(property_원시데이터,객체),scope(singleton,prototype),자동객체주입
===============================================================================
































































##############################################################################
4)setter를 통한 의존성 주입(원시형 자료형 데이터 주입)

*수동 의존성주입방식
1.생성자를 통한 의존성 주입
2.setter를 통한 의존성 주입


1)db-config.xml을 이용하여 setter를 통한 의존성 주입을 설정하라 
	-main 주석읽고 풀어라
	-bean id : db1, db2

package com.spring.basic.ex02;

public class DataBaseInfo {
	private String url;
	private String uid;
	private String upw;
	
	public String getUrl() {
		return url;
	}
	public void setUrl(String url) {
		this.url = url;
	}
	public String getUid() {
		return uid;
	}
	public void setUid(String uid) {
		this.uid = uid;
	}
	public String getUpw() {
		return upw;
	}
	public void setUpw(String upw) {
		this.upw = upw;
	}
	
	
}


package com.spring.basic.ex02;

public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		DataBaseInfo dbInfo = new DataBaseInfo();
		dbInfo.setUid("spring1");
		dbInfo.setUpw("sss111");
		dbInfo.setUrl("jdbc:mysql://localhost:3306/spring");
		
		System.out.println("URL : " + db1.getUrl());
		System.out.println("UID : " + db1.getUid());
		System.out.println("UPW : " + db1.getUpw());

		//위처럼 하지말고 설정으로 해보자
	}
}


<출력결과>
URL : jdbc:mysql://localhost:3306/spring
UID : spring1
UPW : sss111
URL : jdbc:mysql://localhost:3306/practice
UID : root
UPW : mysql


##############################################################################


답:

#db-config.xml

<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean id = "db1" class = "com.spring.basic.ex02.DataBaseInfo">
		<!--  setter 주입 -->
		<property name = "url" value = "jdbc:mysql://localhost:3306/spring" />
				<!--  setter에 해당하는 field이름을 name에 적는다. -->
		<property name = "uid" value = "spring1" />
		<property name = "upw" value = "sss111" />
	</bean>
	
	<bean id = "db2" class = "com.spring.basic.ex02.DataBaseInfo">
		<property name = "url" value = "jdbc:mysql://localhost:3306/practice" />
				<!--  setter에 해당하는 field이름을 name에 적는다. -->
		<property name = "uid" value = "root" />
		<property name = "upw" value = "mysql" />
	</bean>
	
	
</beans>


package com.spring.basic.ex02;

import org.springframework.context.support.GenericXmlApplicationContext;

public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
//		DataBaseInfo dbInfo = new DataBaseInfo();
//		dbInfo.setUid("spring1");
//		dbInfo.setUpw("sss111");
//		dbInfo.setUrl("jdbc:mysql://localhost:3306/spring");
		
		//위처럼하면 귀찮고 보안위험있으니 설정으로 해보자
		
		GenericXmlApplicationContext ct =
				new GenericXmlApplicationContext("classpath:db-config.xml");
		DataBaseInfo db1 = ct.getBean("db1", DataBaseInfo.class);
		
		System.out.println("URL : " + db1.getUrl());
		System.out.println("UID : " + db1.getUid());
		System.out.println("UPW : " + db1.getUpw());
		
	
		DataBaseInfo db2 = ct.getBean("db2", DataBaseInfo.class);
		System.out.println("URL : " + db2.getUrl());
		System.out.println("UID : " + db2.getUid());
		System.out.println("UPW : " + db2.getUpw());
	}

}















##############################################################################
5)setter를 통한 의존성 주입(class 자료형 객체 주입)

1)클래스 MemberDAO를 만들고(아래코드) main코드를 db-config.xml 설정을 이용해서 db객체를 의존성주입하도록 만들어라


package com.spring.basic.ex02;

public class MemberDAO {
	private DataBaseInfo dbInfo;
	
	public void setDbInfo(DataBaseInfo dbInfo) {
		this.dbInfo = dbInfo;
	}
	
	public void showDBInfo() {
		System.out.println("URL: " + dbInfo.getUrl());
		System.out.println("UID: " + dbInfo.getUid());
		System.out.println("UPW: " + dbInfo.getUpw());
	}
}


package com.spring.basic.ex02;

import org.springframework.context.support.GenericXmlApplicationContext;

public class MainClass {

	public static void main(String[] args) {
		
		GenericXmlApplicationContext ct =
				new GenericXmlApplicationContext("classpath:db-config.xml");
		DataBaseInfo db1 = ct.getBean("db1", DataBaseInfo.class);
		DataBaseInfo db2 = ct.getBean("db2", DataBaseInfo.class);
		
		
		MemberDAO dao = new MemberDAO();
		dao.setDbInfo(db1);
		dao.showDBInfo();
		
	}

}


*property 할때 원래는 대부분 ref로 참조해야하지만 원시자료형, String정도는 바로 값을 넣을수 있도록 value를 지원하는거임

<출력결과>
URL: jdbc:mysql://localhost:3306/spring
UID: spring1
UPW: sss111
##############################################################################


답:


<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<bean id = "db1" class = "com.spring.basic.ex02.DataBaseInfo">
		<!--  setter 주입 -->
		<property name = "url" value = "jdbc:mysql://localhost:3306/spring" />
				<!--  setter에 해당하는 field이름을 name에 적는다. -->
		<property name = "uid" value = "spring1" />
		<property name = "upw" value = "sss111" />
	</bean>
	
	<bean id = "db2" class = "com.spring.basic.ex02.DataBaseInfo">
		<property name = "url" value = "jdbc:mysql://localhost:3306/practice" />
				<!--  setter에 해당하는 field이름을 name에 적는다. -->
		<property name = "uid" value = "root" />
		<property name = "upw" value = "mysql" />
	</bean>
	
	<bean id = "dao" class = "com.spring.basic.ex02.MemberDAO">
		<property name = "dbInfo" ref = "db1" />
	</bean>
	
</beans>

package com.spring.basic.ex02;

import org.springframework.context.support.GenericXmlApplicationContext;

public class MainClass {

	public static void main(String[] args) {
		GenericXmlApplicationContext ct =
				new GenericXmlApplicationContext("classpath:db-config.xml");

		MemberDAO dao = ct.getBean("dao", MemberDAO.class);
		dao.showDBInfo();
		
	}

}














##############################################################################
6)setter를 통한 의존성 주입(class 자료형 객체 주입)

1)3번문제에서 풀었던 com.spring.basic.ex01.Restaurant class의 생성자를 없애고 해당 패키지의 MainClass에서 실행시켜라
그러면 xml에서 error가 나는데 그 에러내용은 생성자매개변수를 매칭할수있는 생성자가 클래스에 없다고 된다.
그것을 setter로 바꿔바라

아래는 기존내용 코드다

#test-config.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd">
	<bean id = "test" class = "com.spring.basic.SpringTest" />
	
	<!--  Hotel 객체와 의존객체들의 빈 등록 및 의존성 주입설정 -->
	<bean id = "chef" class = "com.spring.basic.ex01.Chef" />
	<bean id = "res" class = "com.spring.basic.ex01.Restaurant" >
		<constructor-arg ref = "chef" />
	</bean>
	<bean id = "hotel" class = "com.spring.basic.ex01.Hotel" >
		<constructor-arg ref = "res" />
	</bean>
</beans>




package com.spring.basic.ex01;

public class Restaurant {
	private Chef chef;
	
	public Restaurant(Chef chef) {
		// TODO Auto-generated constructor stub
		this.chef = chef;
		
		System.out.println("레스토랑이 생성됨!");
	}
	
	public void orderDinner() {
		System.out.println("저녁식사를 주문합니다.");
		chef.cook();
	}
}

##############################################################################


답:

#test-config.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd">
	<bean id = "test" class = "com.spring.basic.SpringTest" />
	
	<!--  Hotel 객체와 의존객체들의 빈 등록 및 의존성 주입설정 -->
	<bean id = "chef" class = "com.spring.basic.ex01.Chef" />
	<bean id = "res" class = "com.spring.basic.ex01.Restaurant" >
		<!--  <constructor-arg ref = "chef" /> -->
		<property name = "chef" ref = "chef" />
	</bean>
	<bean id = "hotel" class = "com.spring.basic.ex01.Hotel" >
		<constructor-arg ref = "res" />
	</bean>
</beans>



package com.spring.basic.ex01;

public class Restaurant {
	private Chef chef;
	
//	public Restaurant(Chef chef) {
//		// TODO Auto-generated constructor stub
//		this.chef = chef;
//		
//		System.out.println("레스토랑이 생성됨!");
//	}
	
	public void setChef(Chef chef) {
		this.chef = chef;
	}
	
	public void orderDinner() {
		System.out.println("저녁식사를 주문합니다.");
		chef.cook();
	}
}

















##############################################################################
7)bean객체의 싱글톤 기본설정 및 변경

di를 이용하면 객체는 항상 싱글톤이다.
싱글톤이 아니게하여서 아래처럼 bean이 여러 객체를 만들수있게하라
1)아래 main의 주석을 처리하라

#prototype-config.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd">
	<bean id = "person" class = "com.spring.basic.ex03.Person">
		<property name = "name" value = "홍길동" />
		<property name = "age" value = "20" />
	</bean>
	

</beans>



package com.spring.basic.ex03;

public class Person {
	private String name;
	private Integer age;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Integer getAge() {
		return age;
	}
	public void setAge(Integer age) {
		this.age = age;
	}
	
	
}



package com.spring.basic.ex03;

import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;
import org.springframework.context.support.GenericXmlApplicationContext;

public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		GenericXmlApplicationContext ct =
				new GenericXmlApplicationContext("classpath:prototype-config.xml");
		
		Person hong = ct.getBean("person", Person.class);
		Person kim = ct.getBean("person", Person.class);
		
		System.out.println("hong의 주소 : " + hong);
		System.out.println("kim의 주소 : " + kim);
		System.out.println("hong과 kim은 같은 객체인가 ? : " + (hong == kim));
		
		kim.setName("김철수");
		kim.setAge(30);
		
		//kim만 이름나이 바꾸고 싶은데 싱글톤이라서 hong의 이름과 나이도 김철수와 30세가 된다..
		//싱글톤이 아니게해서 아래 문제를 푼뒤 출력결과처럼 나오게 하여라
		
		System.out.println("hong의 이름: " + hong.getName());
		System.out.println("hong의 나이: " + hong.getAge());
		System.out.println("kim의 이름: " + kim.getName());
		System.out.println("kim의 나이: " + kim.getAge());
	}

}

<현재 위 문제코드 출력결과> : main의 코드는 그대로두고 prototype-config.xml의 답만 변경하면 된다.

hong의 주소 : com.spring.basic.ex03.Person@56ac3a89
kim의 주소 : com.spring.basic.ex03.Person@56ac3a89
hong과 kim은 같은 객체인가 ? : true
hong의 이름: 김철수
hong의 나이: 30
kim의 이름: 김철수
kim의 나이: 30

<문제를 푼뒤 출력결과(답의 출력결과)>
hong의 주소 : com.spring.basic.ex03.Person@1ce92674
kim의 주소 : com.spring.basic.ex03.Person@5700d6b1
hong과 kim은 같은 객체인가 ? : false
hong의 이름: 홍길동
hong의 나이: 20
kim의 이름: 김철수
kim의 나이: 30


##############################################################################


답:

***scope만 변경하면 됨 : 원래는 scope = "singleton"으로 기본값설정되어있다.

#prototype-config.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd">
	<bean id = "person" class = "com.spring.basic.ex03.Person" scope = "prototype">
		<property name = "name" value = "홍길동" />
		<property name = "age" value = "20" />
	</bean>
	

</beans>












##############################################################################
8)의존객체 자동주입
	-constructor-arg 또는 property 없이도 알아서 java코드를보고 spring이 의존객체를 자동주입시켜주는 것을 뜻한다

아래코드는 잘된다

<package 생성> : com.spring.basic.ex04
<Class 생성> : Printer, Paper(아래코드)


package com.spring.basic.ex04;

public class Paper {
	public String[] data = {
			"스프링 프레임워크", 
			"자동객체 주입",
			"Autowired는 객체의 타입을 검색하여 자동 주입"
	};
}



package com.spring.basic.ex04;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

public class Printer {
	private Paper paper;
	

	public Printer(Paper paper) {
		// TODO Auto-generated constructor stub
		this.paper = paper;
	}
	
	public void setPaper(Paper paper) {
		this.paper = paper;
	}
	
	
	public void showPaperInfo() {
		for (String info : paper.data) {
			System.out.println(info);
		}
	}
}


package com.spring.basic.ex04;

public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Printer printer = new Printer(new Paper());
		printer.showPaperInfo();
	}

}

1)위의 구시대적인 MainClass의 코드를 auto-config.xml을 이용하여 설정하라 


2)위의 거에서 constructor-arg 없이 자동주입하라
	-이때 생성자, 필드, 메서드 3개에 다 스캔해바라

*아래 코드로 두줄을 beans에 수정해야 자동스캔명령추가 태그를 사용가능해진다.
	-자동스캔명령추가가 해당 bean들을 만들다가 의존성이 발생하면 알아서 자동스캔해서 주입하라는 명령인것같고
		여기서 Autowired를 사용해서 자동스캔위치를 정해주는 듯

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
	http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context-4.3.xsd">
</beans>




3)위 2번답에서 auto-config.xml에 paper를 paper, paper2로 나눈뒤(아래코드참고)
	autowired가 같은 타입이 두개있을시에 beanid를 보고 찾아가서 실행한다는 개념을 이해하고
	그후 bean id가 paper인 놈을 paper1로 바꾸고 타입도 id로도 찾을수 없는 경우를 만들어라
	그리하여 paper1,paper2중 하나를 골라달라는 에러를 보고 처리해라.

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
	http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context-4.3.xsd">

	<!--  자동스캔 명령 추가 -->
	<context:annotation-config />
	
	<bean id = "paper" class = "com.spring.basic.ex04.Paper" />
	<bean id = "paper2" class = "com.spring.basic.ex04.Paper" />

	<bean id = "printer" class = "com.spring.basic.ex04.Printer">
		<!--  <constructor-arg ref = "paper" />  -->
	</bean>
	

</beans>

******Autowired 
-객체를 자동 주입할때 사용하는 아노테이션
-스캔명령을 통해 객체를 찾아 주입하는데 타입이름으로 검색
-타입을 찾아내지 못하면 이름(id속성값)을 통해 검색
	-타입이 2개이상있다면 이름을 검색하여 일치하는 이름의 bean객체를 주입한다.
	-하지만 이름까지도 같은게 없으면 에러난다. 이때는 같은 타입객체 두개중 누구인지 이름을 따로알려주는 Qualifier를 사용해야함
-생성자, 필드, 메서드에 적용 가능

*****Qualifier("bean id")
-Autowired를 사용할때 동일 타입의 빈이 여러개 있을경우 어떤 빈을 주입해야하 하는지 선택해주는 추가 아노테이션
					(여러개있고 매개변수와 같은 beanid까지도 찾을수없는경우)
-qualifier + autowired로 필드에 자동주입 설정을 수행할때는 기본생성자가 반드시 있어야함


##############################################################################


답:

1)
#auto-config.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans  
http://www.springframework.org/schema/beans/spring-beans.xsd">
	<bean id = "paper" class = "com.spring.basic.ex04.Paper" />

	<bean id = "printer" class = "com.spring.basic.ex04.Printer">
		<constructor-arg ref = "paper" />
	</bean>
	

</beans>



package com.spring.basic.ex04;

import org.springframework.context.support.GenericXmlApplicationContext;

public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		GenericXmlApplicationContext ct = 
				new GenericXmlApplicationContext("classpath:auto-config.xml");
		
		
		Printer printer = ct.getBean("printer", Printer.class);
		printer.showPaperInfo();
	}

}


2)위의 거에서 contructor-arg 없이 자동주입하라

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
	http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context-4.3.xsd">

	<!--  자동스캔 명령 추가 -->
	<context:annotation-config />
	
	<bean id = "paper" class = "com.spring.basic.ex04.Paper" />

	<bean id = "printer" class = "com.spring.basic.ex04.Printer" />
		<!--  <constructor-arg ref = "paper" />  -->
		

</beans>


package com.spring.basic.ex04;

import org.springframework.beans.factory.annotation.Autowired;

public class Printer {
	@Autowired
	private Paper paper;
	
	@Autowired // ctrl shift o 하면 자동 import 됨	
	public Printer(Paper paper) {
		// TODO Auto-generated constructor stub
		this.paper = paper;
	}
	
	
	@Autowired // 위의 생성자 혹은 필드, 메소드(setter) 다 가능	
	public void setPaper(Paper paper) {
		this.paper = paper;
	}
	
	public void showPaperInfo() {
		for (String info : paper.data) {
			System.out.println(info);
		}
	}
}



3)



<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
	http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context-4.3.xsd">

	<!--  자동스캔 명령 추가 -->
	<context:annotation-config />
	
	<bean id = "paper1" class = "com.spring.basic.ex04.Paper" />
	<bean id = "paper2" class = "com.spring.basic.ex04.Paper" />

	<bean id = "printer" class = "com.spring.basic.ex04.Printer">
		<!--  <constructor-arg ref = "paper" />  -->
	</bean>
	

</beans>




package com.spring.basic.ex04;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

public class Printer {
	@Autowired
	@Qualifier("paper1")
	private Paper paper;
	
	public Printer() { // 반드시 해당 기본생성자가 있어야 Autowired + qualifier 조합 사용가능하다
		super();		//추가실험해보니 autowired는 기본생성자 없어도 쓸수있더라
	}
	
//	@Autowired // ctrl shift o 하면 자동 import 됨
//	@Qualifier("paper1") Qualifier는 생성자는 안됨으로 여기서는 에러난다.
	public Printer(Paper paper) {
		// TODO Auto-generated constructor stub
		this.paper = paper;
	}
	
//	
//	@Autowired // 위의 생성자 혹은 필드, 메소드(setter) 다 가능
//	@Qualifier("paper1")
	public void setPaper(Paper paper) {
		this.paper = paper;
	}
	
	
	public void showPaperInfo() {
		for (String info : paper.data) {
			System.out.println(info);
		}
	}
}













##############################################################################
9)의존객체 자동주입 - 아노테이션_Resource

Book클래스를 만들어라(아래코드)
1)그리고 해당 코드를 auto-config.xml을 조작하여(2번답인 코드인상태에서 조작하면됨) 2개의 아노테이션으로 문제를 해결하라
	-아래 autowired와 resource의 공통점을 보고 매개변수가 있는 생성자의 여부에따라 기본생성자를 어떻게 해야하는지도 확인해라

package com.spring.basic.ex04;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

public class Book {
	
	private Paper paper;

	public Paper getPaper() {
		return paper;
	}


	public void setPaper(Paper paper) {
		this.paper = paper;
	}
	
	

}

package com.spring.basicReview.ex04;

import java.util.Arrays;

import org.springframework.context.support.GenericXmlApplicationContext;

public class MainClass {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		GenericXmlApplicationContext ct =
				new GenericXmlApplicationContext("classpath:auto-config.xml");
				
		Printer printer = ct.getBean("printer", Printer.class);
		printer.showPaperInfo();
		
		Book book = ct.getBean("book", Book.class);
		String data = Arrays.toString(book.getPaper().data);
		
		System.out.println(data);
	}
}




2)1번에서 두개의 아노테이션으로 처리했는데 하나로해봐라

***Autowired는 Spring 아노테이션이고 Inject는 javaSE의 아노테이션임
		-즉 아무거나해도되는데 상사가쓰는거 따라보고함
***Resource
	-Autowired + Qualifier를 합쳐놓은 것
	-사람들이 거의 안쓴다고한다. 자바 8버전에서까지만 사용가능
	-빈을 자동주입하는 아노테이션
	-필드, 메서드에만 적용이 가능하며 생성자에서는 적용불가능
		-이 특징은 autowired + qualifier 와 동일하지 않나?
			-확인결과 동일하게 안된다.
			
	-name속성을 통해 특정 bean의 id를 지정가능

*********그리고 auto + qualifier, resource 공통점
	-타입달라도 이름(bean id)으로 찝어서 주입가능
	-생성자 앞에서 스캔불가
	-매개변수가 있는 생성자 없으면 기본 생성자없이도 실행가능
	-매개변수가 있는 생성자가 있으면 기본 생성자가 있어야지만 실행가능

##############################################################################


답:

#auto-config.xml

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
	http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context-4.3.xsd">

	<!--  자동스캔 명령 추가 -->
	<context:annotation-config />
	
	<bean id = "paper1" class = "com.spring.basic.ex04.Paper" />
	<bean id = "paper2" class = "com.spring.basic.ex04.Paper" />

	<bean id = "printer" class = "com.spring.basic.ex04.Printer">
		<!--  <constructor-arg ref = "paper" />  -->
	</bean>
	
	<bean id = "book" class = "com.spring.basic.ex04.Book" />
</beans>




1)
package com.spring.basic.ex04;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

public class Book {
	
	private Paper paper;

	public Paper getPaper() {
		return paper;
	}

	@Autowired
	@Qualifier("paper1")
	public void setPaper(Paper paper) {
		this.paper = paper;
	}
	
	

}


2)

package com.spring.basic.ex04;

import javax.annotation.Resource;

public class Book {
	
	private Paper paper;

	Book () {
		
	}
	

	Book (Paper paper) {
		this.paper = paper;
	}
	public Paper getPaper() {
		return paper;
	}

	@Resource(name = "paper2")
//	@Autowired
//	@Qualifier("paper2")
	public void setPaper(Paper paper) {
		this.paper = paper;
	}
	
	

}










##############################################################################
10)자동객체주입

<패키지생성>
com.spring.basic.quiz

<클래스생성>
-위치 : com.spring.basic.quiz

-이름 : Moniter, Keyboard, Mouse
	LG 모니터! 삼성 키보드! 구글 마우스!
-기능 : 각 인스턴스의 브랜드 정보를 출력하는 info() 메서드 구현
	-interface 쓰지말고 그냥해라 그게 중요한게하니다 지금
-필드 : 필요없음

-이름 : Computer
-field : Moniter, Keyboard, Mouse 타입의 monitor, keyboard, mouse 인스턴스 주소를 담을 private한 변수
-기능 : computerInfo() 메서드를 통해 "*** 컴퓨터 정보 ***"를 출력한 뒤 위 3개의 인스턴스에 대해 info() 메서드를 
	호출하는 기능을 구현

+MainClass 생성

<xml 생성> : quiz-config.xml


1.quiz-config.xml에 Monitor, Mouse, Keyboard, Computer 빈을 생성후
2.Computer 클래스에서 자동 주입을 설정하세요.
3.xml에서 빈을 얻은 후 computerInfo()메서드를 실행하세요.


1)위 조건의 답중 Computer에 자동주입 아노테이션을 넣을때는 두가지방식으로 풀어라
1-1)아노테이션 각필드에 하나식 이용
1-2)아노테이션 단하나만 이용 


***1-2)단점 문제다풀고 읽을 것!!!
	-1-2)처럼 하면 Autowired + Qualifier 콤보를 사용할수 없음
	@Autowired
	@Qualifier("bean id")
	private Monitor monitor;
	
	@Autowired
	@Qualifier("bean id")
	private Keyboard keyboard;
	
	@Autowired
	@Qualifier("bean id")
	private Mouse mouse;
##############################################################################


답:


1-1)
package com.spring.basic.quiz;

import org.springframework.beans.factory.annotation.Autowired;

public class Computer {
	
	@Autowired
	private Monitor monitor;
	
	@Autowired
	private Keyboard keyboard;
	
	@Autowired
	private Mouse mouse;
	
	public Computer(Monitor monitor, Keyboard keyboard, Mouse mouse) {
		super();
		this.monitor = monitor;
		this.keyboard = keyboard;
		this.mouse = mouse;
	}

	public Computer() {
		// TODO Auto-generated constructor stub
	}
	
	public void computerInfo() {
		System.out.println("*** 컴퓨터 정보 ***");
		monitor.info();
		keyboard.info();
		mouse.info();
	}

}



1-2)
package com.spring.basic.quiz;

import org.springframework.beans.factory.annotation.Autowired;

public class Computer {
	
	private Monitor monitor;
	private Keyboard keyboard;
	private Mouse mouse;
	
	@Autowired	
	public Computer(Monitor monitor, Keyboard keyboard, Mouse mouse) {
		super();
		this.monitor = monitor;
		this.keyboard = keyboard;
		this.mouse = mouse;
	}
	
	public void computerInfo() {
		System.out.println("*** 컴퓨터 정보 ***");
		monitor.info();
		keyboard.info();
		mouse.info();
	}

}

















































































21.02.06.3회차
===============================================================================
*STS 및 톰캣(설치,구동),pom,web,HomeController,home.jsp,MVC출력흐름(URI)
===============================================================================























































##############################################################################
11)STS 및 톰캣 설치 후 구동

**이클립스는 20년 9월버전부턴 java 8버전사용못하니 20년 6월을 받아야한다.
	18년꺼는 썻더니 조회가 안된다. 그래서 20년 6월쯤받으면 될듯

STS 설치
	-eclipse marketplace : sts -> 3버전으로 설치
	-프로그램 껏다 키고나서 perspective에 spring 생겼나보고 생겼으면 그걸로 교체
	


톰캣 설치
	-톰켓 홈페이지가서 9버전 설치
		-이때 tomcat위치는 원하는곳으로하되 tomcat 폴더가 두개 겹치지 않게 잘라내서 다시 붙여넣기 ㄱㄱ
	-이클립스 spring으로 바꿨으면 아래 servers텝이 따로 분리되어있는데 거기 클릭해서 서버추가(톰켓폴더통째로 선택하면됨)

톰캣 설정
	-톱캣 더블클릭 server위치찾는곳에서 중간꺼(톰켓 설치되어있는 곳이 서버위치라고 하는 뜻임) 클릭
	-server options에서 publicsh module 2번재거(안전을위해서? 라고함)
	-포트번호는 확인만해라
	-저장
	-그후 servers 텝에 서버시작버튼있는 곳 가장 오른쪽에 설정 톰켓에 적용시키기 클릭
	-eclipse menu중 window의 web browser의 기본설정을 Chrome으로 변경

톰캣 구동
	-서버 시작 버튼 누르기
	-크롬에서 url입력창에 http://localhost:8080 해서 고양이 화면 나오면 성공!



STS 파일 생성 : spring legacy project로 해야함
	-프로젝트이름 : SpringWebBasic
	-groupid : com.spring
	-아티팩트 : web
		-즉 top-level package 이름지어달라할때 com.spring.web 이렇게하면 됨



##############################################################################


답: 답없음 똑같이하면됨











##############################################################################
12)STS 기본설정을 내 입맛대로 변경하여 재설치 및 업데이트(pom.xml)



** 현재 내피시 자바버전 : 1.8
	-cmd에 java -version 치면나옴


#pom.xml

1)먼저 내 artifactid, groupid, 프로젝트이름이 맞게 되어있는지 확인
	-gid : com.spring
	-artifactid : web

2)스프링 legacy project 만들때 만들어짐 pom.xml파일은 java 버전이나 다른 필요한것들이 나의 상황 또는 목적과 다르게 기본
세팅된다. 이걸 바꾸자.
	-즉 STS에서 초기에 설정해주는 툴을 내 입맛대로 조금식 바꾸는 거다.

-자바버전 1.8
-스프링프레임워크 버전 5.1.5.RELEASE
-dependencies 
	-version에 ${org.springframework-version} 의미는 위의 스프링프레임워크 버전과 맞추겠다는의미임
		-왜냐하면 이걸안하면 스프링프레임워크는 버전이 높은데 그에 관련된 라이브러리 설치할때는 버전이 안맞아질수도 있으니
			항상 똑같이 하기 위해서임
	-86번 @inject 주석 확인
		-2강에서 설명한 autowired와 inject의 차이임
			-autowired: 스프링에서만든거
			-injext: java에서 만든거 -> 그래서 그룹아이디도 javax 머시기고 이게 있어서 모듈을 불러와야
				사용가능 기능은 둘다 똑같다.
	-93번 servlet 주석아래 dependency 버전변경 
		-2.5 -> 3.1.0
		-3.1.0으로 변경되면서 추가로 바뀐점이 있어서 그부분도 설정을 변경해야한다.
			-그 바뀐것은 바로 artifactId로서 기존엔 servlet-api -> javax.servlet-api

-바로아래에 jsp와 jstl은 업뎃안된지 이미 10년 가까이 되어서 그대로 두면됨
	-특히 jsp가 요즘 안쓰여서 spring boot project에서는 jsp쓸려면 따로 설정해야함. 근데 우리 레거시에서는 jsp로 쓴다.


-build태그내(120)의 136번 plugin 태그 : maven compiler에 관한 태그
	-compiler version : 2.5.1 -> 3.5.1로 변경
	-java version(source, target 태그말하는거임) : 1.8(내피시버전)
		-위 두 버전변경은 1,2강에서 했던 maven 프로젝트에서도 똑같이 3.5.1에 자바 1.8버전을 썼다.


-이럼 변경할설정 다 변경한거고 저장(ctrl s)해서 위에서 추가시킨 버전과 설정으로 새로 다운로드(업데이트)시켜주고 maven에 업데이트해줘야함
	-근데 maven 업데이트되는등 maven 기능 다쓸수있는데 왜굳이 1,2강에선 maven project를 만들걸까?

-그후 MavenDependencies의 spring, servlet, jsp, jstl 등등 잘변경또는 있는지 확인

##############################################################################


답:


<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/maven-v4_0_0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>com.spring</groupId>
	<artifactId>web</artifactId>
	<name>SpringWebBasic</name>
	<packaging>war</packaging>
	<version>1.0.0-BUILD-SNAPSHOT</version>
	<properties>
		<java-version>1.8</java-version>
		<org.springframework-version>5.1.5.RELEASE</org.springframework-version>
		<org.aspectj-version>1.6.10</org.aspectj-version>
		<org.slf4j-version>1.6.6</org.slf4j-version>
	</properties>
	<dependencies>
		<!-- Spring -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
			<version>${org.springframework-version}</version>
			<exclusions>
				<!-- Exclude Commons Logging in favor of SLF4j -->
				<exclusion>
					<groupId>commons-logging</groupId>
					<artifactId>commons-logging</artifactId>
				 </exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>${org.springframework-version}</version>
		</dependency>
				
		<!-- AspectJ -->
		<dependency>
			<groupId>org.aspectj</groupId>
			<artifactId>aspectjrt</artifactId>
			<version>${org.aspectj-version}</version>
		</dependency>	
		
		<!-- Logging -->
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-api</artifactId>
			<version>${org.slf4j-version}</version>
		</dependency>
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>jcl-over-slf4j</artifactId>
			<version>${org.slf4j-version}</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-log4j12</artifactId>
			<version>${org.slf4j-version}</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>log4j</groupId>
			<artifactId>log4j</artifactId>
			<version>1.2.15</version>
			<exclusions>
				<exclusion>
					<groupId>javax.mail</groupId>
					<artifactId>mail</artifactId>
				</exclusion>
				<exclusion>
					<groupId>javax.jms</groupId>
					<artifactId>jms</artifactId>
				</exclusion>
				<exclusion>
					<groupId>com.sun.jdmk</groupId>
					<artifactId>jmxtools</artifactId>
				</exclusion>
				<exclusion>
					<groupId>com.sun.jmx</groupId>
					<artifactId>jmxri</artifactId>
				</exclusion>
			</exclusions>
			<scope>runtime</scope>
		</dependency>

		<!-- @Inject -->
		<dependency>
			<groupId>javax.inject</groupId>
			<artifactId>javax.inject</artifactId>
			<version>1</version>
		</dependency>
				
		<!-- Servlet -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>3.1.0</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet.jsp</groupId>
			<artifactId>jsp-api</artifactId>
			<version>2.1</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jstl</artifactId>
			<version>1.2</version>
		</dependency>
	
		<!-- Test -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.7</version>
			<scope>test</scope>
		</dependency>        
	</dependencies>
    <build>
        <plugins>
            <plugin>
                <artifactId>maven-eclipse-plugin</artifactId>
                <version>2.9</version>
                <configuration>
                    <additionalProjectnatures>
                        <projectnature>org.springframework.ide.eclipse.core.springnature</projectnature>
                    </additionalProjectnatures>
                    <additionalBuildcommands>
                        <buildcommand>org.springframework.ide.eclipse.core.springbuilder</buildcommand>
                    </additionalBuildcommands>
                    <downloadSources>true</downloadSources>
                    <downloadJavadocs>true</downloadJavadocs>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.5.1</version>
                <configuration>
                    <source>1.8</source>
                    <target>1.8</target>
                    <compilerArgument>-Xlint:all</compilerArgument>
                    <showWarnings>true</showWarnings>
                    <showDeprecation>true</showDeprecation>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>exec-maven-plugin</artifactId>
                <version>1.2.1</version>
                <configuration>
                    <mainClass>org.test.int1.Main</mainClass>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>










##############################################################################
13)tomcat 서버에 프로젝트 이관하기 및 context root 찾아서 접근하기

context root를 찾기위해
	-이걸알아야 서버에 접근해서 특정 페이지를 보기위해

-톰캣서버가 SpringWebBasic 프로젝트를 관리하도록해라
	-servers 탭의 생성한 9.0서버 우클릭 add and remove -> project 클릭 후 add finish
	-그 후 설정반영버튼 클릭
-Servers project 클릭 
	-내부 톰캣 9.0 폴더 아래 보이기
	-server.xml 열기 : context root 등록을 하는 곳이 이곳이다.
		-젤아래 context 태그에 docBase는 SpringWebBasic이고 path는 /artifactid 형태로초기에
			설정되며 이게 context root다.
			-이 context root는 바꿔도 된다. 없애도됨.
				-근데 왜필요한가?
				-톰켓이 여러개의 어플리케이션(docBase)을 관리할수 있는데 걔들을 구분하기 위해서
				 context root를 두고 톰켓 하나가 하나의 어플리케이션만 관리할 경우(서비스를 제공할경우)
				 없애는 경우가 많다.
-위 server.xml에서 context root를 알아냈으면 크롬에서 http://localhost:8080/web 을 검색해서 
	Hello world!
	The time on the server is 2022? 2? 5? (?) ?? 4? 32? 47?.
 와 같은 웹페이지가 나오는지 확인해라
	-첨에 페이지 안나오는 에러나오면 아래를 참고해라. jstl이 tomcat의 lib에 없다는 소리임

https://gaga.tistory.com/m/40 -> [500 에러] 절대 URI인 [http://java.sun.com/jsp/jstl/core]을(를), web.xml 또는 이 애플리케이션과 함께 배치된 JAR 파일 내에서 찾을 수 없습니다.
				-위 에러를 해당 페이지에서 고침
				-jstl-1.2.jar를 폴더경로 찾아가서 복사한뒤 tomcat 폴더에 lib로 가서 붙여넣기해주면해결!
					-근데 왜 강사님이랑 학생들은 문제없이 다 됐는데 나만 에러가 됐을까? 슬슬 불안하다.
						후반부에 뭔일날거같다..
##############################################################################


답: 없음 그냥 해보면 됨





















##############################################################################
14)web.xml 설정(mvc관련스프링설정파일,서블릿설정파일,서블릿처리범위)

6번줄 param태그
	- mvc와 관련된 스프링 설정파일의 위치를 적어놓은것임
		- 그쪽(root-context.xml)을 다라가면 bean이 나온다.
	- root-context.xml을 mvc-config.xml로 이름변경
		- 서버 재실행 후 12번에서 잘들어가졌던 홈페이지가 안들어가지는것을 확인
		- 즉 http://localhost:8080/web가 이름바꾸기전엔 hello world하며 나왔는데 그게
			이름바꾸고나선 안됨. 
			- 아 이게 서버 접근과 관련된 것이구나~ 하고 느껴라
				1)이거 안되는 문제를 고쳐라
					-답 : web.xml(of SpringWebBasic)에서 변경된 이름으로
						설정된 파일 위치를 다시 알려주면 됨

20번줄 servlet 태그 : 디스패쳐 서블릿 등록 설정
	-디스패쳐 : mvc패턴에서 브라우저의 모든 요청을 하나의 서블릿이 받는 front controller의 역할을
		하는데 이때 그 서블릿 이름이 디스패쳐
		-그런데 이 디스패쳐는 우리가 만들필요 없이 해당 서블릿 클래스를 이미 스프링프레임워크에서 만들어
			놓았다. 
	-22번줄 <servlet-class> 태그 
	-해당 서블릿의 이름은 appServlet 21번줄
	-27번줄 <load-on-startup>1 : 서블릿중 가장먼저 실행시키겠다는 의미
		-여러개있을때 효과적으로 사용됨 1개 있을땐 사실상 의미 없음
	-<init-param> : 초기화 파라미터
		-서블릿이 실행됐을 때 어떤 설정파일을 읽을 것인가에 대한 내용임
		-<param-value> 태그의 위치를 따라가서 설정파일엔 뭐가 있는가 확인하자
			-여기도 beans가 있네(servlet-context.xml) 즉 bean을 등록하는 역할을 하는 곳이란 것이다.
			-해당 파일의이름 변경
				-servlet-context.xml -> servlet-config.xml
			-해당 파일의 경로변경
				-appServlet내에 있던 해당파일을 상위폴더인 spring내부로 옮기고 appServlet 폴더를
					삭제
			2)이렇게 했을때 인터넷연결안되는데 문제를 해결하라
			-답:web.xml에서 param-value의 경로를 
			<param-value>/WEB-INF/spring/appServlet/servlet-context.xml</param-value>
			에서 
			<param-value>/WEB-INF/spring/servlet-config.xml</param-value>
			로 바꾸면 됨

30번줄 <servlet-mapping>태그
	-<servlet-name> 태그의 appServlet은 위의 서블렛 네임을 뜻한다.
		-3)<servlet>태그의 <servlet-name>을 banana로 변경한뒤 연결문제를 해결하라
			답: mapping의 servlet-name 태그의 이름도 banana로 바꾸면 됨

	-<url-pattern>태그 : url들어오는것중 여기서 설정한 url 부분을 현재 servlet mapping된 banana가 처리하도록
		하겠다라는 의미
		즉 <url-pattern>/</url-pattern> 면 /로 오는 모든걸 처리하겠다는 뜻임. 즉 디스패쳐 서블릿이니까 모든걸
		처리하겠다는것이고 그렇기에 front controller를 만들 필요가 없는 것임
			-회원관리든 게시판관련 요청이든 모두 ㅇ디스패쳐 서블릿으로 오는 것이다.
		-ex)
			<url-pattern>/hello</url-pattern> : /hello url을 banana 서블릿이 처리하게 하겠다.
			<url-pattern>*.do</url-pattern> : .do로 끝나는걸 banana 서블릿이 처리하게 하겠다.

	-해당 줄 변경이 끝나면 바나나는 실습을 위해 변경한것이니 원래이름인 appServlet으로 변경해라 다시
##############################################################################


답:






#web.xml

<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">

	<!-- mvc와 관련된 스프링 설정파일의 위치를 지정하는 태그 -->
	<!-- The definition of the Root Spring Container shared by all Servlets and Filters -->
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/spring/mvc-config.xml</param-value>
	</context-param>
	
	<!-- Creates the Spring Container shared by all Servlets and Filters -->
	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>

	<!--  디스패쳐 서블릿 등록 설정 -->
	<!-- Processes application requests -->
	<servlet>
		<servlet-name>appServlet</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>/WEB-INF/spring/servlet-config.xml</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>
		
	<servlet-mapping>
		<servlet-name>appServlet</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping>

</web-app>











##############################################################################
15)서블릿설정파일 개념파악

#src.main.webapp.WEB-INF.spring의 servlet-config.xml 파일임

<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/mvc"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:beans="http://www.springframework.org/schema/beans"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd
		http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

	<!-- DispatcherServlet Context: defines this servlet's request-processing infrastructure -->
	
	
	<!--  DispatcherServlet 관련 설정 -->
	<!-- Enables the Spring MVC @Controller programming model -->
	
	<annotation-driven />
		<!-- 아노테이션을 통한 자동 빈 주입 명령을 처리하는 태그  -->
		<!-- 위 아노테이션드라이븐이 <context:annotaion-config /> 랑 똑같은거임-->
		
	<!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources directory -->
	<!--  정적자원(html, css, img, js)을 절대경로로 쉽게 매핑하는 태그 -->
	<resources mapping="/resources/**" location="/resources/" />


	<!-- 뷰 리졸버 빈 등록 설정 -->
	<!-- Resolves views selected for rendering by @Controllers to .jsp resources in the /WEB-INF/views directory -->
	<beans:bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<beans:property name="prefix" value="/WEB-INF/views/" />
		<beans:property name="suffix" value=".jsp" />
	</beans:bean>
	
	<!--  아노테이션을 사용하여 자동으로 빈 등록을 하게 해주는 설정 태그 -->
	<context:component-scan base-package="com.spring.web" />
		
	
	
</beans:beans>


##############################################################################


답: 위에 한글주석내용은 다 추가로 달린것이니 눈으로 확인하고 넘어가라























##############################################################################
16)context root 입력했을시 출력되는 화면 원리(mvc패턴 흐름)

*****인터넷의 context root(http://localhost:8080/web)을 입력했을때 정보가 출력되게하는 핵심개념은
 com.spring.web의 HomeController, src.main.webapp.WEB-INF.views의 home.jsp임

****연결된 우리서버내 SpringWebBsic 홈페이지의 페이지소스보기를 하면 home.jsp 거의 똑같음

1-1)HomeController.java 와 home.jsp를 동시에 켜놓고 class의 method home()의 리턴값 "home"
	을 "test"로 변경한 뒤 새로고침 해보시오.
	-그리하면 /WEB-INF/views/test.jsp를 찾을수없다고 나온다. 즉 여기서 리턴하는 값뒤에 .jsp를 붙여서
		해당 파일을 찾아가는 것이다. HomeController.java가 먼저 실행되고 리턴값에 .jsp를통해
		home.jsp를 실행하고 home에서는 12번줄에서 serverTime으로 세션처럼 값을 전해받아서 현재시각을 뛰우는 원리이다.

1-2)위 문제를 해결하시오
	-단, homecontroller.java는 손대지말고 home.jsp 파일을 이용해서 처리하시오
		답: home.jsp 파일의 이름을 test.jsp로 변경하면 됨

*문제를 푼 뒤엔 다시 home으로 돌려두시오 둘다


2)homecontroller.java 파일의 @RequestMapping(value = "/", method = RequestMethod.GET)에서
						// cf) 슬러쉬로 겟요청이 들어올시 해당 메서드를 작동시킨다는의미임
	@RequestMapping(value = "/test", method = RequestMethod.GET)
	로 변경한뒤 서버재시작후 http://localhost:8080/web 해보면 안될것이고
		http://localhost:8080/web/test하면 나오는 것을 확인하라
			즉 value의 값은 url에서 context root값 뒤에서부터 나오는 경로에 따라 반응을 하는 것이다.

*문제를 푼 뒤엔 다시 value를 /로 돌려나라


3)homecontroller가 동작을 수행하고나면 view 리절버로 "home" 값을 리턴한다.
	뷰리절버에 관련한 설정은 servlet-config에 있다. 
	<beans:bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<beans:property name="prefix" value="/WEB-INF/views/" />
		<beans:property name="suffix" value=".jsp" />
	</beans:bean>

	위에서 prefix는 ViewResorver로 반환된 값에 대한 접두어를 정의해놓은 것이고 suffix는 접미어를 정의해놓은 것으로
	최종적으로 /WEB-INF/views/home.jsp가 된다.
	그래서 home.jsp에 관한 bean을 생성한다는 것을 이해해라(view를 뷰리절브가 생성한 것이다)
	그후 view인 bean 객체가 브라우저(클라이언트)에게 답변한다.

	**젤첨엔 handle adapter가 uri를 보고 해당 uri를 처리하는 controller가 뭔지 알려주고
		그걸 handle mapping이 컨트롤러에 직접 연결한다.

4)그렇다면 디스패처 서블릿이 homecontroller를 어떻게 찾았을까? 
	-둘사이에 의존성이 있기 때문이다.의존관계가 있다.
	-어딘가에서 의존성 주입을 해야한다.
	-의존성주입이 되려면 homecontroller를 bean 객체로 만들어야하고 디스패쳐도 bean객체로 만들어야한다.		

4-1)beans graph 확인

	-그렇다면 두놈이 bean 객체로 만들어졌는지 함 보자! servlet-config.xml을 spring config editor로 들어가서 
		beans graph를 클릭하라
		-이클립스 20.6월버전하면 자바8에 호환되는 최신버전이긴하다만 spring config editor를 지원하지 않아서
			beans graph를 볼수 없다. 그러니 아랫버전사용해야하는데 나는 18.09버전을 사용했다.

4-2)beans graph 구성요소
	1)InternalResourceViewResolver
		-이놈은 servelet-config.xml의 27번쯤의 코드에서 bean을 등록하는 코드가 있으니 미래에 bean객체로
			 생겨난다는 의미이다.
			-참고로 어디다 의존성 주입할거아니면 27번쯤의 코드처럼 id를 생략해도 된다.
	2)homeController
		-이걸 디스패쳐가 찾을수 있었던 이유는 디스패쳐와 homecontroller가 의존성관계에 있기 때문이다.
		-이놈이 어덯게 빈으로 만들어 졌는가?
			-servlet-config.xml의 
				<context:component-scan base-package="com.spring.web" />
			 를 보면 요소 스캔을 하되 com.spring.web pacage에서 해라고 되어있고
			 com.spring.web.HomeController.java에 보면 @Controller라는 annotation이 있다.
			 즉 원래라면 <bean id = "home" class = "com.spring.web.HomeController" />
			 라고 있어야하는 빈등록코드가 위 context 태그와 아노테이션 controller덕분에 대체되었다는 뜻이다.

	3)annotation-driven mvcUriComponentsContributor




##############################################################################


답: 답이너무 간단해서 문제에 적어둠
















##############################################################################
17)context root 입력했을시 출력되는 화면 원리(mvc패턴 흐름)2

views 폴더에 test.jsp 생성

#test.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>안녕안녕 메렁메렁 ~~ </h2>
<p>
	오늘은 2022년 2월 7일 일요일 스프링 수업이야 ~~ <br>
	완전 재밌다!!
</p>

</body>
</html>




1)위상태에서 서버키고 http://localhost:8080/web/test를 하면 에러난다.
	컨텍스트루트 뒤에 /로 들어오는 놈은 home()메서드에서 다 처리하도록 해놨지만 /test를 처리할
	메서드를 만들지 않았기 때문이다.
	그럼 이제 위에 만든 test.jsp가 보여질수있도록 클라이언트가 검색했을때 /test를 HomeController에서 처리할수 
	있도록 하여라

##############################################################################


답: helloController만 손보면됨
	-그럼 리턴하는거 views폴더에서 출력하는거는 이미 설계되어있으니(servlet-config.xml) helloController만 만지면됨



package com.spring.web;

import java.text.DateFormat;
import java.util.Date;
import java.util.Locale;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

/**
 * Handles requests for the application home page.
 */
@Controller
public class HomeController {
	
	private static final Logger logger = LoggerFactory.getLogger(HomeController.class);
	
	/**
	 * Simply selects the home view to render by returning its name.
	 */
	@RequestMapping(value = "/", method = RequestMethod.GET)
	public String home(Locale locale, Model model) {
		logger.info("Welcome home! The client locale is {}.", locale);
		
		Date date = new Date();
		DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, locale);
		
		String formattedDate = dateFormat.format(date);
		
		//session.setAttribute //request.setAttribute 형태와 비슷함
		model.addAttribute("serverTime", formattedDate );
		
		
		return "home";
	}
	
	
	//test.jsp를 열기 위한 요청 메서드 구성
	@RequestMapping(value = "/test", method = RequestMethod.GET)
	// '/test'라는 요청이 get으로 들어오면 바로아래 메서드가 좀 처리해줘라고
	// 디스패쳐 서블릿에게 부탁하는 문구임
	public String test() { // 이름은 맘대로
		System.out.println("/test 요청이 들어옴 : GET방식!!!");
		return "test";
	}
}



















##############################################################################
18)클라이언트 측에서 요청을 보냈을때 그것을 처리하는 컨트롤러 만들기


packge 생성 : src/main/java에 com.spring.web.controller
controller 내부에 1번 class 생성

1)자동으로 스프링 컨테이너에 해당 클래스의 빈을 등록하는 아노테이션을 이용하여 spring container에 bean을 등록해라
	-등록하고나서 beans graph로 등록됐는지 확인하라

Class : RequestController
//디스패쳐서블릿이라는 프론트 컨트롤러가 RequestController를 찾게하려면
//디스패쳐서블릿과 requestController의 의존관계를 설정을 해야한다.
//의존관계설정을 우리가 따로할 필요는 없고 해당 클래스에 대한 빈객체를 실행시 만들어지게만 하면된다.
//근데 helloController는 빈등록 코드를 자동으로 이루어지게 했으니 다른 컨트롤러들도 
//자동 빈등록 코드와 아노테이션을 이용하여 만들면 된다.


2)http://localhost:8080/web/test/request/test로 검색했을때 test.jsp가 출력되도록 하라




	//RequestMapping은 어떤 URI로 이 메서드를 동작시킬 것인가에 대한 설정임
	//이거 value = "", GET 이런 설정안하면 post든 get이든 모두 받겠다는 의미임

<출력결과> uri가 /test일경우와 /request/test일 경우의 내부 출력결과
/test 요청이 들어옴 : GET방식!!!
/request/test 요청이 들어옴!

재밌는것이 controller가 homecontroller에서 test.jsp를 출력할수있고 RequestController에서도 test.jsp를 출력할수있다.

##############################################################################


답: RequestController.java만 만지면됨 


1)자동으로 스프링 컨테이너에 해당 클래스의 빈을 등록하는 아노테이션을 이용하여 spring container에 bean을 등록해라
	-등록하고나서 beans graph로 등록됐는지 확인하라

package com.spring.web.controller;

import org.springframework.stereotype.Controller;

@Controller	
public class RequestController {

}



2)http://localhost:8080/web/test/request/test로 검색했을때 test.jsp가 출력되도록 하라

package com.spring.web.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller	
public class RequestController {

	//RequestMapping은 어떤 URI로 이 메서드를 동작시킬 것인가에 대한 설정임
	//이거 value = "", GET 이런 설정안하면 post든 get이든 모두 받겠다는 의미임
	@RequestMapping("/request/test")
	public String testCall() {
		System.out.println("/request/test 요청이 들어옴!");
		return "test";
	}
}
















##############################################################################
19)uri에 따라서 특정 controller의 반환값 조절하여 jsp 파일 view로 응답하기

views 폴더 안에 request 폴더만들어라
request 폴더안에 req-ex01.jsp 만들어라

#req-ex01.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>Request컨트롤러를 이용한 요청 처리 작업</h2>
<p>- 컨틀롤러 테스트중입닏. </p>

</body>
</html>



1)만약 /request/req 요청이 들어왔을때 views폴더 아래에 있는 request 폴더 아래에 req-ex01.jsp파일을 열도록 메서드를
	구성해 보세요
	-단 RequestController.java를 이용한다
		-메서드이름: req

##############################################################################


답: 이것도 servlet-config.xml은 안만지고 RequestController만 만지면 된다




package com.spring.web.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

//클라이언트 측에서 요청을 보냈을때 그것을 처리하는 컨트롤러
//디스패쳐서블릿이라는 프론트 컨트롤러가 RequestController를 찾게하려면
//디스패쳐서블릿과 requestController의 의존관계를 설정을 해야한다.
//의존관계설정을 우리가 따로할 필요는 없고 해당 클래스에 대한 빈객체를 실행시 만들어지게만 하면된다.
//근데 helloController는 빈등록 코드를 자동으로 이루어지게 했으니 다른 컨트롤러들도 
//자동 빈등록 코드와 아노테이션을 이용하여 그러헥 만들면 된다.

@Controller	
public class RequestController {

	//RequestMapping은 어떤 URI로 이 메서드를 동작시킬 것인가에 대한 설정임
	//이거 value = "", GET 이런 설정안하면 post든 get이든 모두 받겠다는 의미임
	@RequestMapping("/request/test")
	public String testCall() {
		System.out.println("/request/test 요청이 들어옴!");
		return "test";
	}
	
	@RequestMapping("/request/req")
	public String req() {
		System.out.println("/request/req 요청이 들어옴~!");
		return "request/req-ex01";
	}
	
}







##############################################################################
20)하나의 uri로 두개의 결과물을 내는법
	-하나의 uri지만 get 또는 post전송방식의 차이에 따라서 두개의 결과물을 낼수 있다.

req-ex01.jsp에 코드를 추가해라
버튼 두개를 만들어서 GET요청누르면 get방식으로 /web/request/basic01이라는 uri로 보내고
POST요청누르면 post방식으로 /web/request/basic01라는 uri로 보내려한다.

1)이때 RquestController.java를 이용해서 두 메서드를 만들고 각각의 로그를 남기며 해당 페이지로 다시 보내라
	-이때 아노테이션을 스프링 4버전에서부터 나온 신기술을 사용해서도 풀어봐라
	-메서드이름 : basicGet(), basicPost()
		-원래는 두개다 이름같이해도되는데(get방식과 post방식의 매개변수가다르기때문에)
			지금은 실습이니까 그냥 이렇게 해라

	-내부로그
		-"/request/basic01요청이 들어옴: GET"
		-"/request/basic01요청이 들어옴: POST"


#/views/request/req-ex01.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>Request컨트롤러를 이용한 요청 처리 작업</h2>
<p>- 컨틀롤러 테스트중입닏. </p>

<form action = "/web/request/basic01" method = "get" >
	<p><input type = "submit" value = "GET요청!!"></p>
</form>

<form action = "/web/request/basic01" method = "post" >
	<p><input type = "submit" value = "POST요청!!"></p>
</form>

</body>
</html>


/request/basic




##############################################################################


답: 





package com.spring.web.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

//클라이언트 측에서 요청을 보냈을때 그것을 처리하는 컨트롤러
//디스패쳐서블릿이라는 프론트 컨트롤러가 RequestController를 찾게하려면
//디스패쳐서블릿과 requestController의 의존관계를 설정을 해야한다.
//의존관계설정을 우리가 따로할 필요는 없고 해당 클래스에 대한 빈객체를 실행시 만들어지게만 하면된다.
//근데 helloController는 빈등록 코드를 자동으로 이루어지게 했으니 다른 컨트롤러들도 
//자동 빈등록 코드와 아노테이션을 이용하여 그러헥 만들면 된다.

@Controller	
public class RequestController {

	//RequestMapping은 어떤 URI로 이 메서드를 동작시킬 것인가에 대한 설정임
	//이거 value = "", GET 이런 설정안하면 post든 get이든 모두 받겠다는 의미임
	@RequestMapping("/request/test")
	public String testCall() {
		System.out.println("/request/test 요청이 들어옴!");
		return "test";
	}
	
	@RequestMapping("/request/req")
	public String req() {
		System.out.println("/request/req 요청이 들어옴~!");
		return "request/req-ex01";
	}
	
//	@RequestMapping(value = "/request/basic01", method = RequestMethod.GET)
	@GetMapping("/request/basic01")
	public String basicGet() {
		System.out.println("/request/basic01요청이 들어옴: GET");
		return "request/req-ex01";
	}
	
//	@RequestMapping(value = "/request/basic01", method = RequestMethod.POST)
	@PostMapping("/request/basic01") 
	public String basicPost() {
		System.out.println("/request/basic01요청이 들어옴: POST");
		return "request/req-ex01";
	}
	
}









##############################################################################
21)요청파라미터 받아보기

1)http://localhost:8080/web/request/param(이하uri생략_파라미터입력부분)을 입력해서 접속시도 시에
	view로 보낼 .jsp는 만들지말고(이말은 controller의 return값을 ""로 두라는거임, 브라우저요청시 응답화면은 에러가 나겠고!)
	아래 시스템로그를 남기도록 하여라
get방식이니 uri입력시에 파라미터를 입력해서 접속해라
	-파라미터 입력시 field명 2개
		-name
		-age 
	-RequestController.java를 이용한다.

request/param 요청: GET
이름 : 박영희
나이 : 22


##############################################################################




답: 






package com.spring.web.controller;

import javax.servlet.http.HttpServletRequest;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

//클라이언트 측에서 요청을 보냈을때 그것을 처리하는 컨트롤러
//디스패쳐서블릿이라는 프론트 컨트롤러가 RequestController를 찾게하려면
//디스패쳐서블릿과 requestController의 의존관계를 설정을 해야한다.
//의존관계설정을 우리가 따로할 필요는 없고 해당 클래스에 대한 빈객체를 실행시 만들어지게만 하면된다.
//근데 helloController는 빈등록 코드를 자동으로 이루어지게 했으니 다른 컨트롤러들도 
//자동 빈등록 코드와 아노테이션을 이용하여 그러헥 만들면 된다.

@Controller	
public class RequestController {

	//RequestMapping은 어떤 URI로 이 메서드를 동작시킬 것인가에 대한 설정임
	//이거 value = "", GET 이런 설정안하면 post든 get이든 모두 받겠다는 의미임
	@RequestMapping("/request/test")
	public String testCall() {
		System.out.println("/request/test 요청이 들어옴!");
		return "test";
	}
	
	@RequestMapping("/request/req")
	public String req() {
		System.out.println("/request/req 요청이 들어옴~!");
		return "request/req-ex01";
	}
	
//	@RequestMapping(value = "/request/basic01", method = RequestMethod.GET)
	@GetMapping("/request/basic01")
	public String basicGet() {
		System.out.println("/request/basic01요청이 들어옴: GET");
		return "request/req-ex01";
	}
	
//	@RequestMapping(value = "/request/basic01", method = RequestMethod.POST)
	@PostMapping("/request/basic01") 
	public String basicPost() {
		System.out.println("/request/basic01요청이 들어옴: POST");
		return "request/req-ex01";
	}
	
	// 요청 파라미터 받아보기
	@GetMapping("/request/param")
	public String paramTest(HttpServletRequest request) {
		System.out.println("request/param 요청: GET");
		
		String name = request.getParameter("name");
		String age = request.getParameter("age");
		System.out.println("이름 : " + name);
		System.out.println("이름 : " + age);
		
		return "";
	}
	
}





















































































































21.02.07.4회차
===============================================================================
*Controller메소드반환값x,context root매칭,톰캣한글설정,공통uri매핑,파라미터처리,model(@ModelAttribute(),ModelAndView)
===============================================================================











































































































##############################################################################
22)공통 uri 매핑, 반환값 없는 메소드, context root 매칭시키기, 톰캣한글설정

1)RequestController나 혹은 다른 컨트롤러 내부에서 특정 uri를 공통으로 매핑하여라
	모든 uri를 받는 아노테이션들에 /request를 하지 않아도 /request를 포함한 uri로 아노테이션이
	수신받도록 하여라
	*String형으로 반환할때는 /request를 붙여줘야함
		-다만 void형으로 자동 반환되게할때는 /request가 붙음
	*그리고 반환할때 / 붙여도 되고 안붙여도됨

-----------------------------------------------------------

2)아래 req-ex02.jsp를 만들고 RequestController에서 특정 메소드를 반환값없도록 만들었지만
	viewResolver에는 값이 잘 전달되도록 만드시오.
	-homeController에서 /test uri가 요청된 경우에 void로 메서드를 구성해서 test.jsp페이지가
		열리도록 해보시오.

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	<h2>req-ex02.jsp 파일입니다!</h2>
</body>
</html>

-----------------------------------------------------------
3)jsp만 만지면 되는 문제이다.

3-1)아래 join.jsp를 이용하여 반환값 void일때 공통uri 포함하여 반환
uri로 /request/join이(/web/request/join) 들어왔을때 Controller 메소드 register()
	를 만든뒤 반환값을 void로 하여 views/request/join.jsp가 열리도록 하세요.

3-2)아래 join.jsp를 이용하여 context root 매칭시키기

	-c태그의 특정속성을 이용하여 path 변수를 만들어서 변수에 context root 집어넣은뒤 사용하기
		-path변수는 해당 프로젝트내의 어디서든 사용될수 있도록하여라
	-c태그의 특정속성을 이용하여 변수를 만들지 않고 context root 사용하기


<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
    
<%--
	#컨텍스트 루트 경로가 변경될 경우 처리방법
	1.컨텍스트 루트 경로를 변수로 지정함
	2.<c:url> 태그를 사용
 --%>
 
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>요청 파라미터값 테스트!!</h2>

<form action = "" method = "post"> 	
	<fieldset>
		<legend>회원가입 양식</legend>
		<p>
			- ID : <input type = "text" name = "userId" size = "10"> <br>
			- PW : <input type = "password" name = "userPw" size = "10"> <br>
			- NAME : <input type = "text" name = "userName" size = "10"> <br>
			- HOBY :
			<input type = "checkbox" name = "hobby" value = "soccer" > 축구&nbsp;
			<input type = "checkbox" name = "hobby" value = "book" > 독서&nbsp;
			<input type = "checkbox" name = "hobby" value = "music" > 음악&nbsp;
			<br>
			<input type = "submit" value = "회원가입" />
		</p>
	</fieldset>
</form>

</body>
</html>

****컨텍스트 루트 경로가 변경될 경우 처리방법 : 유지보수가 편하다.

-----------------------------------------------------------
4)4-1, 4-2의 답은 같다. 둘중하나라도 처리하면 모두 해결이 된다.
	문제를 해결하라(톰캣설정과 관련된 web.xml을 이용하라)

4-1)컨텍스트 루트만포함한 url을 요청했을때 한국언어가 깨지는데 그걸해결해라
http://localhost:8080/web/

4-2)아래 url을 요청했을때 id등 post로 보낼 입력값에 한글을치면 깨지는데 그걸 해결해라
http://localhost:8080/web/request/join
	-4-2)는 사실 아래문제에서 파라미터 처리를 해야 확인가능하니까 4-1)로만 확인해라


	<!-- 한글 인코딩 필터 설정(톰캣 내부의 한글처리) -->
	<filter>
	    <filter-name>encodingFilter</filter-name>
	    <filter-class>
				org.springframework.web.filter.CharacterEncodingFilter
			</filter-class>
	    <init-param>
	      <param-name>encoding</param-name>
	      <param-value>UTF-8</param-value>
	    </init-param>
	    <init-param>
	      <param-name>forceEncoding</param-name>
	      <param-value>true</param-value>
	    </init-param>
    </filter>
    <!-- 위에 지정한  encodingFilter이름을 모든 패턴에 적용-->
    <filter-mapping>
	    <filter-name>encodingFilter</filter-name>
	    <url-pattern>/*</url-pattern>
    </filter-mapping>


##############################################################################




답: 



#RequestController.java

package com.spring.web.controller;

import javax.servlet.http.HttpServletRequest;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import com.spring.web.model.UserVO;
import com.spring.web.model.UserVO2;

//클라이언트 측에서 요청을 보냈을때 그것을 처리하는 컨트롤러
//디스패쳐서블릿이라는 프론트 컨트롤러가 RequestController를 찾게하려면
//디스패쳐서블릿과 requestController의 의존관계를 설정을 해야한다.
//의존관계설정을 우리가 따로할 필요는 없고 해당 클래스에 대한 빈객체를 실행시 만들어지게만 하면된다.
//근데 helloController는 빈등록 코드를 자동으로 이루어지게 했으니 다른 컨트롤러들도 
//자동 빈등록 코드와 아노테이션을 이용하여 그러헥 만들면 된다.

@Controller	
@RequestMapping("/request") // 공통 uri 떼놓기
public class RequestController {

	//RequestMapping은 어떤 URI로 이 메서드를 동작시킬 것인가에 대한 설정임
	//이거 value = "", GET 이런 설정안하면 post든 get이든 모두 받겠다는 의미임
//	@RequestMapping("/request/test")
	@RequestMapping("/test") // 원래 위에처럼 해야하지만 클래스선언분위에 일괄매핑을 했어서 괜찮다.
	public String testCall() {
		System.out.println("/request/test 요청이 들어옴!");
		return "test";
	}
	
//	@RequestMapping("/request/req") // 이대로 두면 /request/request/req 해야지 온다.
	@RequestMapping("/req")
	public String req() {
		System.out.println("/request/req 요청이 들어옴~!");
		return "request/req-ex01";
	}
	
	@GetMapping("/req-ex02")
	public void reqEx02() {
		System.out.println("/reqeust/req-ex02 요청!");
	}
	
//	@RequestMapping(value = "/request/basic01", method = RequestMethod.GET)
//	@GetMapping("/request/basic01")
	@GetMapping("/basic01")
	
	public String basicGet() {
		System.out.println("/request/basic01요청이 들어옴: GET");
		return "request/req-ex01";
	}
	
//	@RequestMapping(value = "/request/basic01", method = RequestMethod.POST)
//	@PostMapping("/request/basic01")
	@PostMapping("/basic01")
	public String basicPost() {
		System.out.println("/request/basic01요청이 들어옴: POST");
		return "request/req-ex01";
	}

	// 요청 파라미터 받아보기
//	@GetMapping("/request/param")
	@GetMapping("/param")
	public String paramTest(HttpServletRequest request) {
		System.out.println("request/param 요청: GET");
		
		String name = request.getParameter("name");
		String age = request.getParameter("age");
		System.out.println("이름 : " + name);
		System.out.println("나이 : " + age);
		
		return "";
	}
	
	
	/////////////////////////////////////////////////////////////////////
	@GetMapping("/join")
	public void register() {
		System.out.println("/request/join : GET");
	}
	
}




#./views/request/join.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
    
    
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>
    
<%--
	#컨텍스트 루트 경로가 변경될 경우 처리방법
	1.컨텍스트 루트 경로를 변수로 지정함
	2.<c:url> 태그를 사용
 --%>
 
 <c:set var = "path" value = "<%= request.getContextPath() %>" scope = "application"/>
    
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>요청 파라미터값 테스트!!</h2>
<%--
# 1번방식
<form action = "${path}/request/join" method = "post">
 --%>
 <%-- #2번방식 --%>
<form action = "<c:url value = '/request/join' />" method = "post"> 	
	<fieldset>
		<legend>회원가입 양식</legend>
		<p>
			- ID : <input type = "text" name = "userId" size = "10"> <br>
			- PW : <input type = "password" name = "userPw" size = "10"> <br>
			- NAME : <input type = "text" name = "userName" size = "10"> <br>
			- HOBY :
			<input type = "checkbox" name = "hobby" value = "soccer" > 축구&nbsp;
			<input type = "checkbox" name = "hobby" value = "book" > 독서&nbsp;
			<input type = "checkbox" name = "hobby" value = "music" > 음악&nbsp;
			<br>
			<input type = "submit" value = "회원가입" />
		</p>
	</fieldset>
</form>

</body>
</html>




#./WEB-INF/web.xml


<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">

	<!-- mvc와 관련된 스프링 설정파일의 위치를 지정하는 태그 -->
	<!-- The definition of the Root Spring Container shared by all Servlets and Filters -->
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/spring/mvc-config.xml</param-value>
	</context-param>
	
	<!-- Creates the Spring Container shared by all Servlets and Filters -->
	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>

	<!--  디스패쳐 서블릿 등록 설정 -->
	<!-- Processes application requests -->
	<servlet>
		<servlet-name>appServlet</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>/WEB-INF/spring/servlet-config.xml</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>
		
	<servlet-mapping>
		<servlet-name>appServlet</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping>


	<!-- 한글 인코딩 필터 설정(톰캣 내부의 한글처리) -->
	<filter>
	    <filter-name>encodingFilter</filter-name>
	    <filter-class>
				org.springframework.web.filter.CharacterEncodingFilter
			</filter-class>
	    <init-param>
	      <param-name>encoding</param-name>
	      <param-value>UTF-8</param-value>
	    </init-param>
	    <init-param>
	      <param-name>forceEncoding</param-name>
	      <param-value>true</param-value>
	    </init-param>
    </filter>
    <!-- 위에 지정한  encodingFilter이름을 모든 패턴에 적용-->
    <filter-mapping>
	    <filter-name>encodingFilter</filter-name>
	    <url-pattern>/*</url-pattern>
    </filter-mapping>

</web-app>




























##############################################################################
23)post 혹은 get으로 오는 파라미터를 Controller에서 처리하기

<가 문제>

1.전통적인 jsp/servlet의 파라미터 읽기처리방법

2.아노테이션을 이용한 요청 파라미터 처리

3.커맨드 객체를 활용한 파라미터 처리(UserVO)
	pacakge com.spring.web.model 생성


*join을 이용해서 파라미터 처리 3가지방식으로 풀어라(join.jsp는 수정할필요없거 RequestController에서
		join.jsp가 보내주는 파라미터를 처리만 하면 된다)
	-ID, PW, HOBBY 값을 입력받았을때 그걸 출력해라
		-2번방법(아노테이션)을 이용한경우 HOBBY가 없을시에  
			에러가 난다. 두개의 에러원인이 있는데 f3을 써가면서 고쳐라
		-HOBBY가 없을시에는 "no hobby person"이 출력되게 하라
		-HOBBY를 담을때는 List<String>을 이용하라

<출력방식코드>
		System.out.println("ID : " + id);
		System.out.println("PW : " + pw);
		System.out.println("HOBBY : " + hobbys.toString());








<나 문제>


class이용 : RequestController.java

# 문제
	1. RequestController에 현재 파일을 열어주는 메서드 생성
	 - url: /request/quiz : GET
	 - views: /request/req-quiz.jsp
		-이놈은 아래 코드참고
	 - method-name: quiz()
	2. RequestController에 전송된 아이디, 비밀번호 파라미터를
	  받아 로그인을 처리하는 메서드 생성
	 - url: /request/quiz : POST
	 - views: 
	 	성공시: /request/login-success.jsp
			-그냥 성공입니다만 띄워라
	 	실패시: /request/login-fail.jsp
			-그냥 실패입니다만 띄워라
	 - method-name: quiz()
	3. 로그인 성공조건: 
	 - id값이 : abc1234 , pw: xxx4321
	 
	 -리퀘스트 파람이나 커맨드객체를 사용해라


위 #문제를 3가지 방법으로 풀어라

1.전통적인 jsp/servlet의 파라미터 읽기처리방법

2.아노테이션을 이용한 요청 파라미터 처리

3.커맨드 객체를 활용한 파라미터 처리(UserVO)
	pacakge com.spring.web.model 생성


#req-quiz.jsp



<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<%--
	# 문제
	1. RequestController에 현재 파일을 열어주는 메서드 생성
	 - url: /request/quiz : GET
	 - views: /request/req-quiz.jsp
	 - method-name: quiz()
	2. RequestController에 전송된 아이디, 비밀번호 파라미터를
	  받아 로그인을 처리하는 메서드 생성
	 - url: /request/quiz : POST
	 - views: 
	 	성공시: /request/login-success.jsp
	 	실패시: /request/login-fail.jsp
	 - method-name: quiz()
	3. 로그인 성공조건: 
	 - id값이 : abc1234 , pw: xxx4321
	 
	 -리퀘스트 파람이나 커맨드객체를 사용해라
 --%>

<h3>파라미터값 처리하기 문제~</h3>

<form action="<c:url value='/request/quiz'/>" method="post">
	<p>
		# ID: <input type="text" name="userId" size="10"><br>
		# PW: <input type="password" name="userPw" size="10"><br>
		<input type="submit" value="로그인">
	</p>
</form>

</body>
</html>




##############################################################################




답: 


#RequestController.java만 만지고 나머지는 그냥 만들면됨

package com.spring.web.controller;

import javax.servlet.http.HttpServletRequest;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import com.spring.web.model.UserVO;
import com.spring.web.model.UserVO2;

//클라이언트 측에서 요청을 보냈을때 그것을 처리하는 컨트롤러
//디스패쳐서블릿이라는 프론트 컨트롤러가 RequestController를 찾게하려면
//디스패쳐서블릿과 requestController의 의존관계를 설정을 해야한다.
//의존관계설정을 우리가 따로할 필요는 없고 해당 클래스에 대한 빈객체를 실행시 만들어지게만 하면된다.
//근데 helloController는 빈등록 코드를 자동으로 이루어지게 했으니 다른 컨트롤러들도 
//자동 빈등록 코드와 아노테이션을 이용하여 그러헥 만들면 된다.

@Controller	
@RequestMapping("/request") // 공통 uri 떼놓기
public class RequestController {

	//RequestMapping은 어떤 URI로 이 메서드를 동작시킬 것인가에 대한 설정임
	//이거 value = "", GET 이런 설정안하면 post든 get이든 모두 받겠다는 의미임
//	@RequestMapping("/request/test")
	@RequestMapping("/test") // 원래 위에처럼 해야하지만 클래스선언분위에 일괄매핑을 했어서 괜찮다.
	public String testCall() {
		System.out.println("/request/test 요청이 들어옴!");
		return "test";
	}
	
//	@RequestMapping("/request/req") // 이대로 두면 /request/request/req 해야지 온다.
	@RequestMapping("/req")
	public String req() {
		System.out.println("/request/req 요청이 들어옴~!");
		return "request/req-ex01";
	}
	
	@GetMapping("/req-ex02")
	public void reqEx02() {
		System.out.println("/reqeust/req-ex02 요청!");
	}
	
//	@RequestMapping(value = "/request/basic01", method = RequestMethod.GET)
//	@GetMapping("/request/basic01")
	@GetMapping("/basic01")
	
	public String basicGet() {
		System.out.println("/request/basic01요청이 들어옴: GET");
		return "request/req-ex01";
	}
	
//	@RequestMapping(value = "/request/basic01", method = RequestMethod.POST)
//	@PostMapping("/request/basic01")
	@PostMapping("/basic01")
	public String basicPost() {
		System.out.println("/request/basic01요청이 들어옴: POST");
		return "request/req-ex01";
	}
	
	// 요청 파라미터 받아보기
//	@GetMapping("/request/param")
	@GetMapping("/param")
	public String paramTest(HttpServletRequest request) {
		System.out.println("request/param 요청: GET");
		
		String name = request.getParameter("name");
		String age = request.getParameter("age");
		System.out.println("이름 : " + name);
		System.out.println("나이 : " + age);
		
		return "";
	}
	
	
	/////////////////////////////////////////////////////////////////////
	@GetMapping("/join")
	public void register() {
		System.out.println("/request/join : GET");
	}
	
	/*
	 # 1.전통적인 jsp/servlet의 파라미터 읽기처리방법
	 	-HttpServletRequest객체를 사용
	 
	
	@PostMapping("/join")
	public String register(HttpServletRequest request) {
		System.out.println("/request/join : POST");
		System.out.println("ID : " + request.getParameter("userId"));
		System.out.println("PW : " + request.getParameter("userPw"));
		System.out.println("HOBBY : " 
				+ Arrays.toString(request.getParameterValues("hobby")));
		return "request/join";
	}
	*/
	
	/* 
	 # 2.@RequestParam 아노테이션을 이용한 요청 파라미터 처리
	 	-1번 안쓰는 이유 : 받아야할 파라미터가 많다면 request함수를 넘많이써야함. 나이가 들어오면
	 		변환처리를 해야한다. request의 리턴타입은 항상 String이기때문에 변환과정이 추가돼서 별로다.
	 		즉 형변환 처리의 귀찮음을 막아주는 법
	 	-2번단점 : 현재경우 hobby취미를 선택하지 않으면 에러난다. 즉 매개변수로 hobby값이 null이 오면 에러다
	 		@RequestParam(value = "hobby", required = false) List<String> hobbys) {
	 		위처럼하면 해결됨 f3보면 required가 true로 되어있어서에러인거다
	 		근데 이렇게해도 null이 들어오니까 문법에러가 나긴함 왜냐면 아래 .toString()을 했기때문
	 		그럼 @RequestParam(value = "hobby", required = false, defaultValue = "no hobby person") List<String> hobbys) {
	 		하면 됨
	 		
	 	**별개로 한글로 입력하면 깨진다. 톰캣이 한글을 못알아먹어서 그렇다.
	 		톰캣한글처리에 대해 편하게 할수있는 방법을 spring에서 제공한다.
	 		
	 
	@PostMapping("/join")
	public void register(@RequestParam("userId") String id,
							@RequestParam("userPw") String pw,
							@RequestParam(value = "hobby", required = false, defaultValue = "no hobby person") List<String> hobbys) {
			//String id = request.getParameter("userId"); 를 한번에 처리해주는 것임
			//int라면 형변환도 int로 해서 알아서 됨
			
		System.out.println("ID : " + id);
		System.out.println("PW : " + pw);
		System.out.println("HOBBY : " + hobbys.toString());
	}
	
	*/
	
	/*
	 # 3.커맨드 객체를 활용한 파라미터 처리
	 	-UserVO의 필드명과 jsp의 파라미터명이 같고 UserVo라는 객체에 setter getter가 있다면 그대로 바로 형변환
	 	될건 되면서 알아서 다 들어간다. 자동화의 신세계!
	 */
	@PostMapping("/join")
	public void register(UserVO user) {
		System.out.println("ID : " + user.getUserId());
		System.out.println("PW : " + user.getUserPw());
		System.out.println("NAME : " + user.getUserName());
		System.out.println("HOBBY : " + user.getHobby());
	}
	
	@GetMapping("/quiz")
	public String quiz() {
		System.out.println("/request/req-quiz 요청됨 : GET");
		return "/request/req-quiz"; // / 붙여도 되고 안붙여도 됨
	}
	
	
//	@RequestMapping(value = "/quiz", method = RequestMethod.POST)
//	public String quiz(HttpServletRequest request) {
//		String id = request.getParameter("userId");
//		String pw = request.getParameter("userPw");
//		
//		if (id.equals("abc1234") && pw.equals("xxx4321")) {			
//			return "request/login-success";
//		}
//		
//		return "request/login-fail";
//	}
	
//	@RequestMapping(value = "/quiz", method = RequestMethod.POST)
//	public String quiz(@RequestParam("userId") String id,
//						@RequestParam("userPw") String pw) {
//		if (id.equals("abc1234") && pw.equals("xxx4321")) {
//			return "request/login-success";			
//		}
//		return "request/login-fail";
//	}

	@PostMapping("/quiz")
	public String quiz(UserVO2 user) {
		System.out.println("/request/req-quiz 요청됨 : POST");
		
		if (user.getUserId().equals("abc1234") 
				&& user.getUserPw().equals("xxx4321")) {
			return "request/login-success";	
		}
		
		return "request/login-fail";
	}
	
}



























##############################################################################
24)bean id 설정, model사용

<package생성> : package com.spring.web.controller;
<class 생성> : ResponseController.java
<views>
폴더생성 : response
jsp생성 : res-ex01.jsp, test.jsp, test2.jsp

1)아노테이션을 통한 자동빈등록시 bean id 따로 지정하는법
	-따로지정한뒤 beans graph를 이용하여 bean id가 바꼈나 봐라
		-원래 자동생성시 beanid는 기본값으로 해당 클래스이름에서 첫글자를 소문자로 한 것이다.
	-bean id는 responseController에서 resCon으로 바꿔라



답: @Controller("resCon")



2)동적으로 jsp에 값을 넘겨주기위해 model 사용하기

1.아노테이션과 Model 객체를 사용하여 매개변수받기
2.1번의 것을 특정 아노테이션을 이용하여 매개변수에서 한번에 처리하기

	1,2번문제는 test.jsp로 해결(아래 테스트1페이지와 관련)
3.model 관련 class 타입을 반환하여 얻기
	-3번문제는 test2.jsp로 해결
	-특정 객체를 반환하여 viewResolver에게 문자열을 전달하면서 동시에
		데이터 세트도 전달하기
	-데이터세트 : "userName", "박영희"
	-viewResolver에게 전달할 문자열 : "/response/test2"


#res-ex01.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>    

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>Model 객체에 대해 알아보기</h2>

<a href = ""> 테스트 1페이지로~</a>
	<%-- 여기서 get으로 보내는건데(아래도 get인건 마찬가지) 나이에 대해서를 링크에 ?붙여서(30으로)
		보내고 별명은 nick, 뽀삐로 Controller에서 model에 담은뒤 보내라 
		즉 나이는 jsp에서 파라미터로 보내고 별명은 controller에서 model에 담아서 보낸걸
		받아서 사용해라
--%>
<a href = ""> 테스트 2페이지로~</a>

</body>
</html>

#test.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>test.jsp 페이지입니다.</h2>

<p> 지정된 별명은 ??입니다. 그리고 나이는 ??세 입니다.</p>

</body>
</html>


#test2.jsp



<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>test2.jsp 페이지입니다.</h2>
<p>
	컨트롤러가 전달한 데이터 : ??
</p>

</body>
</html>
##############################################################################




답: 


#ResponseController.java

package com.spring.web.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

@Controller("resCon")
@RequestMapping("/response")

public class ResponseController {
	
	public ResponseController() {
		// TODO Auto-generated constructor stub
	}
	
	@GetMapping("/res-ex01")
	public void resEx01() {
		
	}
	
	//1.Model 객체를 사용하여 화면에 데이터 전송하기
	/*
	@GetMapping("/test")
	public void test(@RequestParam("age") int age,
						Model model) {
		model.addAttribute("nick", "뽀삐");
		model.addAttribute("age", age);
	}
	*/
	
	//@ModelAttribute : @RequestParam("age") int age + model.addAttribute("age", age)
					//와 같은 것이다. 포함관계
	//2.@ModelAttribute를 사용한 화면에 데이터 전송처리
	@GetMapping("/test")
	public void test(@ModelAttribute("age") int age,
			Model model) {
		model.addAttribute("nick", "뽀삐");
//		model.addAttribute("age", age);
	}
	
	//3.ModelAndView 객체를 활용한 처리
	@GetMapping("/test2")
	public ModelAndView test2() {
//		ModelAndView mv = new ModelAndView();
//		mv.addObject("userName", "박영희"); //화면에 전달할 데이터 래핑
//		mv.setViewName("/response/test2"); //viewResolver에게 전달할 문자열
//		return mv;
		
		return new ModelAndView("/response/test2", "userName", "박영희");
	}
}



#res-ex01.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>    

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>Model 객체에 대해 알아보기</h2>

<%--
	<c:url value='' />
		-value 속성안에 컨텍스트 루트 경로를 제외한 절대경로를 작성
		-그러면 컨텍스트 루트를 제외하고 연결가능
		<a href = "/web/response/test">테스트페이지로~</a>
		위에 놈을 아래로 전환
		<a href = "<c:url value = '/response/test' />"> 테스트페이지로~</a>
		
		
 --%>

<a href = "<c:url value = '/response/test?age=30' />"> 테스트 1페이지로~</a>
<a href = "<c:url value = '/response/test2' />"> 테스트 2페이지로~</a>

</body>
</html>



#test.jsp


<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>test.jsp 페이지입니다.</h2>
<%--
	<p> 지정된 별명은 ??입니다. 그리고 나이는 ??세 입니다.</p>
 --%>
<p> 지정된 별명은 ${nick}입니다. 그리고 나이는 ${age}세 입니다.</p>
</body>
</html>



#test2.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>test2.jsp 페이지입니다.</h2>
<p>
	컨트롤러가 전달한 데이터 : ${userName}
</p>

</body>
</html>


































































































































































21.02.08.5회차
===============================================================================
*jstl, EL, 커맨드객체 생성원리(setter이용), form에서 action 없는경우, 재전송요청, model, session한계, 재전송시 효율높은 scope 객체
===============================================================================































































































##############################################################################
25)jstl, EL, 커맨드객체 생성원리(setter이용)

1)아래 흐름과 조건을 지켜서 정상적으로 회원정보를 출력하라
	-회원정보 EL로 넣을떼는 해당 클래스에서 toString을 재정의해야한다.
	-test3에서 hobby 출력시에는 jstl로 조건문과 for문을 이용한다.

res-ex02.jsp생성
test3.jsp 생성
ResponseController.java 이용

순서 : 클라이언트 uri요청 -> Controller -> res-ex02.jsp -> Controller -> test3.jsp 
client uri 요청 : /response/res-ex02
res-ex02.jsp에서 요청 uri : /response/join

메소드 : resEx02(), join()

 
#res-ex02.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<form action = "" method = "post"> 	
	<fieldset>
		<legend>회원가입 양식</legend>
		<p>
			- ID : <input type = "text" name = "userId" size = "10"> <br>
			- PW : <input type = "password" name = "userPw" size = "10"> <br>
			- NAME : <input type = "text" name = "userName" size = "10"> <br>
			- HOBY :
			<input type = "checkbox" name = "hobby" value = "soccer" > 축구&nbsp;
			<input type = "checkbox" name = "hobby" value = "book" > 독서&nbsp;
			<input type = "checkbox" name = "hobby" value = "music" > 음악&nbsp;
			<br>
			<input type = "submit" value = "회원가입" />
		</p>
	</fieldset>
</form>

</body>
</html>


#test3
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
  
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>회원가입정보 출력하기</h2>
<p>
	# 회원정보 : ${} <br>
	# 아이디 : ${} <br>
	# 비밀번호 : ${} <br>
	# 이름 : ${} <br>
	# 취미 :
	<%-- 자바코드를 html코드처럼 일관성있게 쓰는 방법이 jstl이다. --%>

		이 사람은 취미가 없는 사람입니다.

	<br>
</p>

</body>
</html>

	

##############################################################################



답:

-----------------------------------------------

#res-ex02.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<form action = "<c:url value = '/response/join' />" method = "post"> 	
	<fieldset>
		<legend>회원가입 양식</legend>
		<p>
			- ID : <input type = "text" name = "userId" size = "10"> <br>
			- PW : <input type = "password" name = "userPw" size = "10"> <br>
			- NAME : <input type = "text" name = "userName" size = "10"> <br>
			- HOBY :
			<input type = "checkbox" name = "hobby" value = "soccer" > 축구&nbsp;
			<input type = "checkbox" name = "hobby" value = "book" > 독서&nbsp;
			<input type = "checkbox" name = "hobby" value = "music" > 음악&nbsp;
			<br>
			<input type = "submit" value = "회원가입" />
		</p>
	</fieldset>
</form>

</body>
</html>






-----------------------------------------------



#test3.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
    
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>    
    
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>회원가입정보 출력하기</h2>
<p>
	# 회원정보 : ${user} <br>
	# 아이디 : ${user.getUserId()} <br>
	# 비밀번호 : ${user.userPw} <br>
	# 이름 : ${user.userName} <br>
	# 취미 :
	<%-- 자바코드를 html코드처럼 일관성있게 쓰는 방법이 jstl이다. --%>
	<c:if test = "${user.hobby.size() != 0}" >
		<c:forEach var="h" items="${user.hobby}">
			${h} &nbsp;
		</c:forEach>
	</c:if>
	<c:if test = "${user.hobby.size() == null}" >
	
		이 사람은 취미가 없는 사람입니다.
	</c:if>
	<br>
</p>

</body>
</html>


-----------------------------------------------


#ResponseController.java

package com.spring.web.controller;

import javax.servlet.http.HttpSession;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.spring.web.model.UserVO;
import com.spring.web.model.UserVO2;

@Controller("resCon")
@RequestMapping("/response")

public class ResponseController {
	
	public ResponseController() {
		// TODO Auto-generated constructor stub
	}
	
	@GetMapping("/res-ex01")
	public void resEx01() {
		
	}
	
	//1.Model 객체를 사용하여 화면에 데이터 전송하기
	/*
	@GetMapping("/test")
	public void test(@RequestParam("age") int age,
						Model model) {
		model.addAttribute("nick", "뽀삐");
		model.addAttribute("age", age);
	}
	*/
	
	//@ModelAttribute : @RequestParam("age") int age + model.addAttribute("age", age)
					//와 같은 것이다. 포함관계
	//2.@ModelAttribute를 사용한 화면에 데이터 전송처리
	@GetMapping("/test")
	public void test(@ModelAttribute("age") int age,
			Model model) {
		model.addAttribute("nick", "뽀삐");
//		model.addAttribute("age", age);
	}
	
	//3.ModelAndView 객체를 활용한 처리
	@GetMapping("/test2")
	public ModelAndView test2() {
//		ModelAndView mv = new ModelAndView();
//		mv.addObject("userName", "박영희"); //화면에 전달할 데이터 래핑
//		mv.setViewName("/response/test2"); //viewResolver에게 전달할 문자열
//		return mv;
		
		return new ModelAndView("/response/test2", "userName", "박영희");
	}
	
	
	//res-ex02.jsp파일을 열람하는 요청메서드 작성
	@GetMapping("/res-ex02")
	public void resEx02() {
		
	}
	
	
	/*
	@PostMapping("/join")
	public String join(UserVO user, Model model) {
		model.addAttribute("user", user);
		return "response/test3";
	}
	*/
	@PostMapping("/join")
	public String join(@ModelAttribute("user") UserVO user) {
		return "response/test3";
	}
	
	@GetMapping("/res-quiz")
	public void resQuiz() {
		
	}
	
	@PostMapping("/res-login")
	public String resLogin(@ModelAttribute("user") UserVO2 user) {
		String id = user.getUserId();
		String pw = user.getUserPw();
		
		if (id.equals("kim123") && pw.equals("kkk1234")) {
			return "response/res-quiz-success";			
		}
		
		return "response/res-quiz-fail";
	}
	
	
	///////////////////////////////////////////////////////////////////
	//Redirect처리 
	//원래는 viewResolver에게 보내는 방식이 포워드 방식이다.
	//글쓰기 요청이 끝난다음에 글목록 페이지가 떠야하는데 포워드면 요청끝나고 디스패쳐왔다가 다시 db에 가야함
	//글쓰기 요청(insert)가 되고나면 다시 돌아오지않고 재요청으로  select하여 목록을 가져오면 좋다.
	//그 재요청방법이 Redirect처리다.
	//글 삭제같은경우도 delete로 게시글 지우고 목록을 보여줄때 디스패쳐까지 돌아오지않고 재요청을해서 바로 db에서 목록을
	//가져오는 것도 포워드로는 않되고 Redirect로 가능하다.
	
	//로그인 화면 요청처리
	@GetMapping("/login")
	public String login() {
		System.out.println("/response/login 요청 발생 : GET");
		return "response/res-redirect-form";
	}
	
	//로그인 검증처리
	/*
	@PostMapping("/login")
	public String login(@ModelAttribute("userId") String id
							, @RequestParam("userPw") String pw
							, @RequestParam("userPwChk") String pwChk
							, Model model
							//, HttpServletResponse response)원래 이게 jsp방식인데 spirng에선 이렇게 안해도됨
							, HttpSession session
							){
		System.out.println("/response/login 요청 발생 : POST");
		System.out.println("id : " + id); 
		System.out.println("pw : " + pw);
		System.out.println("pwChk : " + pwChk);
		
		
		
		if (id.equals("")) { // 아이디 입력하지 않은 경우
//			response.sendRedirect(); 원래 이게 jsp방식인데 spirng에선 이렇게 안해도됨
			System.out.println("아이디가 비었습니다.");
//			model.addAttribute("msg", "아이디는 필수 값이에요!");
			session.setAttribute("msg", "아이디는 필수 값이에요!");
			return "redirect:/response/login"; // jsp를 열러가지않고 바로 다시 controller의 
												// /resposne/login uri를 받을수있는 메서드를
												// 찾는다.
												//이때 redirect로 보내면 무조건 get요청이다.
												//그래서 위에 로그인화면요청처리로 간다.
		} else if (!pw.equals(pwChk)) { // 비번과 확인비번이 다른 경우
			System.out.println("두 비밀번호가 같지 않습니다.");
//			model.addAttribute("msg", "비밀번호 확인란을 체크하세요!");
			session.setAttribute("msg", "두 비밀번호가 같지 않습니다.");
			return "redirect:/response/login";
		} else if (id.equals("abc123") && pw.equals("1234")) {
			System.out.println("로그인성공!");
			return "response/res-quiz-success";
		} else { // 안전빵
			System.out.println("그런 아이디와 비번은 등록되지 않았습니다.");
//			model.addAttribute("msg", "그런 아이디와 비번은 등록되지 않았습니다.");
			return null;
		}
	}
	*/
	@PostMapping("/login")
	public String login(@ModelAttribute("userId") String id
							, @RequestParam("userPw") String pw
							, @RequestParam("userPwChk") String pwChk
							, RedirectAttributes ra
//							, HttpSession session
							, Model model
							){
		System.out.println("/response/login 요청 발생 : POST");
		System.out.println("id : " + id); 
		System.out.println("pw : " + pw);
		System.out.println("pwChk : " + pwChk);
		
		
		
		if (id.equals("")) { // 아이디 입력하지 않은 경우
			System.out.println("아이디가 비었습니다.");
			ra.addFlashAttribute("msg2", "아이디는 필수 값이에요!");
//			session.setAttribute("msg1", "아이디는 필수 값이에요!");
//			model.
			return "redirect:/response/login"; 
		} else if (!pw.equals(pwChk)) { // 비번과 확인비번이 다른 경우
			System.out.println("두 비밀번호가 같지 않습니다.");
			ra.addFlashAttribute("msg2", "두 비밀번호가 같지 않습니다.");
//			session.setAttribute("msg1", "두 비밀번호가 같지 않습니다.");
			return "redirect:/response/login";
		} else if (id.equals("abc123") && pw.equals("1234")) {
			System.out.println("로그인성공!");
			
			return "response/res-quiz-success";
		} else { // 안전빵
			System.out.println("그런 아이디와 비번은 등록되지 않았습니다.");
			return null;
		}
	}
	
	
}











##############################################################################
26)jstl, EL, 커맨드객체 생성원리(setter이용)

1. res-quiz 파일의 화면처리를 할 수 있는 메서드를 생성하세요.(res-quiz 맵핑)
2. 폼태그의 액션URL은 res-login 으로 설정하세요.
3. ID:kim123, PW:kkk1234 라면 res-quiz-success.jsp페이지로 
     이동해서 "로그인 성공" "(회원ID)님 환영합니다" 출력
4. 아니라면 res-quiz-fail.jsp페이지로 이동해서 
   "로그인 실패" "(회원ID)는 회원이 아닙니다" 출력
	-이때 id만 실어서 보내는방법과 idpw를 보내는방법 모두이용해라
		1.커맨드객체와 Model을 사용한 방식
		2.아노테이션을 사용한 방식
			2-1)userId는 아노테이션으로 받고, userPw는 아노테이션 requestParam으로 받는다
				-어차피 userId만 넘기면되니까!
			2-2)userVO를 아노테이션으로 받아서 한번에 attribute까지 처리한다.





#res-quiz.jsp

<form action="#" method="post">
	<p>
		# ID: <input type="text" name="userId" size="10"><br>
		# PW: <input type="password" name="userPw" size="10"><br>
		<input type="submit" value="로그인">
	</p>
</form>


</body>
</html>
##############################################################################



답:





#res-quiz.jsp


<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<%--
1. res-quiz 파일의 화면처리를 할 수 있는 메서드를 생성하세요.(res-quiz 맵핑)
2. 폼태그의 액션URL은 res-login 으로 설정하세요.
3. ID:kim123, PW:kkk1234 라면 res-quiz-success.jsp페이지로 
     이동해서 "로그인 성공" "(회원ID)님 환영합니다" 출력
4. 아니라면 res-quiz-fail.jsp페이지로 이동해서 
   "로그인 실패" "(회원ID)는 회원이 아닙니다" 출력
	
--%>

<form action="<c:url value = '/response/res-login'/>" method="post">
	<p>
		# ID: <input type="text" name="userId" size="10"><br>
		# PW: <input type="password" name="userPw" size="10"><br>
		<input type="submit" value="로그인">
	</p>
</form>


</body>
</html>




#res-quiz-success.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

	<h2>로그인 성공!!</h2>
	<p>
		( ${userId} )님 환영합니다!!!!!!
	</p>

</body>
</html>


#ResponseController.java : 25코드와 같음



package com.spring.web.controller;

import javax.servlet.http.HttpSession;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.spring.web.model.UserVO;
import com.spring.web.model.UserVO2;

@Controller("resCon")
@RequestMapping("/response")

public class ResponseController {
	
	public ResponseController() {
		// TODO Auto-generated constructor stub
	}
	
	@GetMapping("/res-ex01")
	public void resEx01() {
		
	}
	
	//1.Model 객체를 사용하여 화면에 데이터 전송하기
	/*
	@GetMapping("/test")
	public void test(@RequestParam("age") int age,
						Model model) {
		model.addAttribute("nick", "뽀삐");
		model.addAttribute("age", age);
	}
	*/
	
	//@ModelAttribute : @RequestParam("age") int age + model.addAttribute("age", age)
					//와 같은 것이다. 포함관계
	//2.@ModelAttribute를 사용한 화면에 데이터 전송처리
	@GetMapping("/test")
	public void test(@ModelAttribute("age") int age,
			Model model) {
		model.addAttribute("nick", "뽀삐");
//		model.addAttribute("age", age);
	}
	
	//3.ModelAndView 객체를 활용한 처리
	@GetMapping("/test2")
	public ModelAndView test2() {
//		ModelAndView mv = new ModelAndView();
//		mv.addObject("userName", "박영희"); //화면에 전달할 데이터 래핑
//		mv.setViewName("/response/test2"); //viewResolver에게 전달할 문자열
//		return mv;
		
		return new ModelAndView("/response/test2", "userName", "박영희");
	}
	
	
	//res-ex02.jsp파일을 열람하는 요청메서드 작성
	@GetMapping("/res-ex02")
	public void resEx02() {
		
	}
	
	
	/*
	@PostMapping("/join")
	public String join(UserVO user, Model model) {
		model.addAttribute("user", user);
		return "response/test3";
	}
	*/
	@PostMapping("/join")
	public String join(@ModelAttribute("user") UserVO user) {
		return "response/test3";
	}
	
	@GetMapping("/res-quiz")
	public void resQuiz() {
		
	}
	
	@PostMapping("/res-login")
	public String resLogin(@ModelAttribute("user") UserVO2 user) {
		String id = user.getUserId();
		String pw = user.getUserPw();
		
		if (id.equals("kim123") && pw.equals("kkk1234")) {
			return "response/res-quiz-success";			
		}
		
		return "response/res-quiz-fail";
	}
	
	
	///////////////////////////////////////////////////////////////////
	//Redirect처리 
	//원래는 viewResolver에게 보내는 방식이 포워드 방식이다.
	//글쓰기 요청이 끝난다음에 글목록 페이지가 떠야하는데 포워드면 요청끝나고 디스패쳐왔다가 다시 db에 가야함
	//글쓰기 요청(insert)가 되고나면 다시 돌아오지않고 재요청으로  select하여 목록을 가져오면 좋다.
	//그 재요청방법이 Redirect처리다.
	//글 삭제같은경우도 delete로 게시글 지우고 목록을 보여줄때 디스패쳐까지 돌아오지않고 재요청을해서 바로 db에서 목록을
	//가져오는 것도 포워드로는 않되고 Redirect로 가능하다.
	
	//로그인 화면 요청처리
	@GetMapping("/login")
	public String login() {
		System.out.println("/response/login 요청 발생 : GET");
		return "response/res-redirect-form";
	}
	
	//로그인 검증처리
	/*
	@PostMapping("/login")
	public String login(@ModelAttribute("userId") String id
							, @RequestParam("userPw") String pw
							, @RequestParam("userPwChk") String pwChk
							, Model model
							//, HttpServletResponse response)원래 이게 jsp방식인데 spirng에선 이렇게 안해도됨
							, HttpSession session
							){
		System.out.println("/response/login 요청 발생 : POST");
		System.out.println("id : " + id); 
		System.out.println("pw : " + pw);
		System.out.println("pwChk : " + pwChk);
		
		
		
		if (id.equals("")) { // 아이디 입력하지 않은 경우
//			response.sendRedirect(); 원래 이게 jsp방식인데 spirng에선 이렇게 안해도됨
			System.out.println("아이디가 비었습니다.");
//			model.addAttribute("msg", "아이디는 필수 값이에요!");
			session.setAttribute("msg", "아이디는 필수 값이에요!");
			return "redirect:/response/login"; // jsp를 열러가지않고 바로 다시 controller의 
												// /resposne/login uri를 받을수있는 메서드를
												// 찾는다.
												//이때 redirect로 보내면 무조건 get요청이다.
												//그래서 위에 로그인화면요청처리로 간다.
		} else if (!pw.equals(pwChk)) { // 비번과 확인비번이 다른 경우
			System.out.println("두 비밀번호가 같지 않습니다.");
//			model.addAttribute("msg", "비밀번호 확인란을 체크하세요!");
			session.setAttribute("msg", "두 비밀번호가 같지 않습니다.");
			return "redirect:/response/login";
		} else if (id.equals("abc123") && pw.equals("1234")) {
			System.out.println("로그인성공!");
			return "response/res-quiz-success";
		} else { // 안전빵
			System.out.println("그런 아이디와 비번은 등록되지 않았습니다.");
//			model.addAttribute("msg", "그런 아이디와 비번은 등록되지 않았습니다.");
			return null;
		}
	}
	*/
	@PostMapping("/login")
	public String login(@ModelAttribute("userId") String id
							, @RequestParam("userPw") String pw
							, @RequestParam("userPwChk") String pwChk
							, RedirectAttributes ra
//							, HttpSession session
							, Model model
							){
		System.out.println("/response/login 요청 발생 : POST");
		System.out.println("id : " + id); 
		System.out.println("pw : " + pw);
		System.out.println("pwChk : " + pwChk);
		
		
		
		if (id.equals("")) { // 아이디 입력하지 않은 경우
			System.out.println("아이디가 비었습니다.");
			ra.addFlashAttribute("msg2", "아이디는 필수 값이에요!");
//			session.setAttribute("msg1", "아이디는 필수 값이에요!");
//			model.
			return "redirect:/response/login"; 
		} else if (!pw.equals(pwChk)) { // 비번과 확인비번이 다른 경우
			System.out.println("두 비밀번호가 같지 않습니다.");
			ra.addFlashAttribute("msg2", "두 비밀번호가 같지 않습니다.");
//			session.setAttribute("msg1", "두 비밀번호가 같지 않습니다.");
			return "redirect:/response/login";
		} else if (id.equals("abc123") && pw.equals("1234")) {
			System.out.println("로그인성공!");
			
			return "response/res-quiz-success";
		} else { // 안전빵
			System.out.println("그런 아이디와 비번은 등록되지 않았습니다.");
			return null;
		}
	}
	
	
}























##############################################################################
27)jstl, EL, 커맨드객체 생성원리(setter이용)

views: birth 폴더생성
	-birth-form.jsp
	-birth-result.jsp

class : BirthController.java 생성


	1. 다음 생년월일을 받아서 콘솔에 출력하는 
	   메서드를 생성 (url: /birth : POST)
          조건) BirthVO 커맨드객체 사용, 
          콘솔에 전송된 값을 붙여서 출력합니다 ex)20180615
	2. birth-result.jsp 페이지에 
	"당신의 생일은 ~~~~년 ~~월 ~~일입니다." 을 출력하세요

-option에 value?였나? 를 넣으면 2월에서 2값만 보낼수 있다.
-유의할점:커맨드 객체를 이용하여 파라미터 처리할때 setter가 작동된다.
	-0을 추가로 붙이는 작업을 setter에서 하라는 소리다.
	-월입력시 버튼으로 1~12월중선택할수있게하고 그 선택한 값에 월을 붙이지않고 숫자만 파라미터로 보내게
		설정해라





#birth-form.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>


<form action = "#" method = "post" >
	<fieldset>
		<legend>생일 등록 양식</legend>
		<p>
			# 생년월일 :
			<input type = "text" name = "year" size = "6" maxlength = "4" placeholder = "연도(4자리)"/>
			<select name = "month">
	
					<option>${m}월</option>
	
			</select>
			<input type = "text" name = "day" maxlength = "2" size = "4" placeholder = "일(1-31)" />
			<input type = "submit" value = "확인" />
		</p>
	</fieldset>
</form>

</body>
</html>




#birth-result.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	당신의 생일은 ?년 ?월 ?일입니다.
</body>
</html>

##############################################################################



답:






#birth-form.jsp


<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>


<form action = "<c:url value = '/birth'/>" method = "post" >
	<fieldset>
		<legend>생일 등록 양식</legend>
		<p>
			# 생년월일 :
			<input type = "text" name = "year" size = "6" maxlength = "4" placeholder = "연도(4자리)"/>
			<select name = "month">
				<c:forEach var = "m" begin = "1" end = "12" step = "1">
					<option value = "${m}">${m}월</option>
				</c:forEach>
			</select>
			<input type = "text" name = "day" maxlength = "2" size = "4" placeholder = "일(1-31)" />
			<input type = "submit" value = "확인" />
		</p>
	</fieldset>
</form>

</body>
</html>





#birth-result.jsp


<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	당신의 생일은 ${birth.year}년 ${birth.month}월 ${birth.day}일입니다.
</body>
</html>





#BirthController.java
package com.spring.web.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import com.spring.web.model.BirthVO;

@Controller("birC")
public class BirthController {
	@RequestMapping(value = "/birth", method = RequestMethod.GET)
	public String birth() {
		return "birth/birth-form";
	}
	
	@RequestMapping(value = "/birth", method = RequestMethod.POST)
	public String birth(@ModelAttribute("birth") BirthVO birth) {
		System.out.println(birth.getYear()+birth.getMonth()+birth.getDay());
		return "birth/birth-result";
	}
}









#BirthVO
package com.spring.web.model;

public class BirthVO {
	private String year;
	private String month;
	private String day;
	
	
	public BirthVO() {
		// TODO Auto-generated constructor stub
	}


	public String getYear() {
		return year;
	}


	public void setYear(String year) {
		this.year = year;
	}


	public String getMonth() {
		return month;
	}


	public void setMonth(String month) {
		if (Integer.valueOf(month) < 10) {
			this.month = 0 + month;
			return;
		}
		this.month = month;
	}


	public String getDay() {
		return day;
	}


	public void setDay(String day) {
		this.day = day;
	}
	
	
	
}

























##############################################################################
28)form에서 action 없는경우, 재전송요청, null반환

#res-redirect-form.jsp 생성
#res-quiz-success.jsp 생성
#ResponseController.java 이용
	-method : login()
		


사용자입력 uri : /web/response/login
흐름 : client uri -> CM -> /response/res-redirect-form.jsp -> CM
	-> 2가지
		-/resposne/login uri로 재전송요청(get으로들어감)
		-/response/res-quiz-success 열기

	1)id 입력하지 않은경우 처리해라
		-이거 졸라이상함.. post보내면 다시 get으로 받고 로그인누르면 다시 post 가는데 기존 post보낸 userId가 살아
			있음 계속.. 그래서 uri의 파라미터부분을 지워서 직접 get방식으로 다시 접근해서 아이디비번비번확인쳐야됨
	2)비번 다른경우처리
	3)위 abc123 1234와 같은경우 처리
	4)위 abc123 1234와 같지않은경우 처리
		-같지않으면 null을 리턴해서 null 리턴한경우 viewResolver로 뭐가 반환되서 가는지봐라
			-답: null이면 null에 .jsp를 붙일순없으니 Mapping된 uri를 반환한다.
						즉 /response/login.jsp가 되는 것이다. 하지만 우리파일에
						이런 경로와 jsp파일은 없다. 그래서 에러가 날것인데 그게 맞다.
				-근데 나중에 뒤에서 RedirectAttributes하면 또 null.jsp로 됨
					ㅋㅋ 좀더 지켜보자이건.
		**핵심개념은 redirect:/response/login을 반환할경우 (즉 redierect:이 있을경우)
			viewResolver로 보내서 .jsp등을 붙이지않고 viewResolver가기전에 바로 다시 Controller에게 
			오는 것이다.
		**추가 핵심은 redirect될때는 반드시 get방식으로 된다. post방식이 아니다.






#res-redirect-form.jsp 생성

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<%-- ResponseController 사용 --%>


<form method = "post">
<p>
	# ID : <input type = "text" name = "userId" size = "10"> <br>
	# 비밀번호 : <input type = "password" name = "userPw" size = "10"> <br>
	# 비밀번호 확인 : <input type = "password" name = "userPwChk" size = "10"> <br>
	<input type = "submit" value = "로그인">
</p>
</form>

</body>
</html>




#res-quiz-success.jsp 생성

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

	<h2>로그인 성공!!</h2>
	<p>
		( ? )님 환영합니다!!!!!!
	</p>

</body>
</html>



##############################################################################



답:



#res-quiz-success.jsp 생성

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

	<h2>로그인 성공!!</h2>
	<p>
		( ${userId} )님 환영합니다!!!!!!
	</p>

</body>
</html>










#ResponseController.java 이용 : 앞 ResponseController.java와 같음

package com.spring.web.controller;

import javax.servlet.http.HttpSession;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.spring.web.model.UserVO;
import com.spring.web.model.UserVO2;

@Controller("resCon")
@RequestMapping("/response")

public class ResponseController {
	
	public ResponseController() {
		// TODO Auto-generated constructor stub
	}
	
	@GetMapping("/res-ex01")
	public void resEx01() {
		
	}
	
	//1.Model 객체를 사용하여 화면에 데이터 전송하기
	/*
	@GetMapping("/test")
	public void test(@RequestParam("age") int age,
						Model model) {
		model.addAttribute("nick", "뽀삐");
		model.addAttribute("age", age);
	}
	*/
	
	//@ModelAttribute : @RequestParam("age") int age + model.addAttribute("age", age)
					//와 같은 것이다. 포함관계
	//2.@ModelAttribute를 사용한 화면에 데이터 전송처리
	@GetMapping("/test")
	public void test(@ModelAttribute("age") int age,
			Model model) {
		model.addAttribute("nick", "뽀삐");
//		model.addAttribute("age", age);
	}
	
	//3.ModelAndView 객체를 활용한 처리
	@GetMapping("/test2")
	public ModelAndView test2() {
//		ModelAndView mv = new ModelAndView();
//		mv.addObject("userName", "박영희"); //화면에 전달할 데이터 래핑
//		mv.setViewName("/response/test2"); //viewResolver에게 전달할 문자열
//		return mv;
		
		return new ModelAndView("/response/test2", "userName", "박영희");
	}
	
	
	//res-ex02.jsp파일을 열람하는 요청메서드 작성
	@GetMapping("/res-ex02")
	public void resEx02() {
		
	}
	
	
	/*
	@PostMapping("/join")
	public String join(UserVO user, Model model) {
		model.addAttribute("user", user);
		return "response/test3";
	}
	*/
	@PostMapping("/join")
	public String join(@ModelAttribute("user") UserVO user) {
		return "response/test3";
	}
	
	@GetMapping("/res-quiz")
	public void resQuiz() {
		
	}
	
	@PostMapping("/res-login")
	public String resLogin(@ModelAttribute("user") UserVO2 user) {
		String id = user.getUserId();
		String pw = user.getUserPw();
		
		if (id.equals("kim123") && pw.equals("kkk1234")) {
			return "response/res-quiz-success";			
		}
		
		return "response/res-quiz-fail";
	}
	
	
	///////////////////////////////////////////////////////////////////
	//Redirect처리 
	//원래는 viewResolver에게 보내는 방식이 포워드 방식이다.
	//글쓰기 요청이 끝난다음에 글목록 페이지가 떠야하는데 포워드면 요청끝나고 디스패쳐왔다가 다시 db에 가야함
	//글쓰기 요청(insert)가 되고나면 다시 돌아오지않고 재요청으로  select하여 목록을 가져오면 좋다.
	//그 재요청방법이 Redirect처리다.
	//글 삭제같은경우도 delete로 게시글 지우고 목록을 보여줄때 디스패쳐까지 돌아오지않고 재요청을해서 바로 db에서 목록을
	//가져오는 것도 포워드로는 않되고 Redirect로 가능하다.
	
	//로그인 화면 요청처리
	@GetMapping("/login")
	public String login() {
		System.out.println("/response/login 요청 발생 : GET");
		return "response/res-redirect-form";
	}
	
	//로그인 검증처리
	/*
	@PostMapping("/login")
	public String login(@ModelAttribute("userId") String id
							, @RequestParam("userPw") String pw
							, @RequestParam("userPwChk") String pwChk
							, Model model
							//, HttpServletResponse response)원래 이게 jsp방식인데 spirng에선 이렇게 안해도됨
							, HttpSession session
							){
		System.out.println("/response/login 요청 발생 : POST");
		System.out.println("id : " + id); 
		System.out.println("pw : " + pw);
		System.out.println("pwChk : " + pwChk);
		
		
		
		if (id.equals("")) { // 아이디 입력하지 않은 경우
//			response.sendRedirect(); 원래 이게 jsp방식인데 spirng에선 이렇게 안해도됨
			System.out.println("아이디가 비었습니다.");
//			model.addAttribute("msg", "아이디는 필수 값이에요!");
			session.setAttribute("msg", "아이디는 필수 값이에요!");
			return "redirect:/response/login"; // jsp를 열러가지않고 바로 다시 controller의 
												// /resposne/login uri를 받을수있는 메서드를
												// 찾는다.
												//이때 redirect로 보내면 무조건 get요청이다.
												//그래서 위에 로그인화면요청처리로 간다.
		} else if (!pw.equals(pwChk)) { // 비번과 확인비번이 다른 경우
			System.out.println("두 비밀번호가 같지 않습니다.");
//			model.addAttribute("msg", "비밀번호 확인란을 체크하세요!");
			session.setAttribute("msg", "두 비밀번호가 같지 않습니다.");
			return "redirect:/response/login";
		} else if (id.equals("abc123") && pw.equals("1234")) {
			System.out.println("로그인성공!");
			return "response/res-quiz-success";
		} else { // 안전빵
			System.out.println("그런 아이디와 비번은 등록되지 않았습니다.");
//			model.addAttribute("msg", "그런 아이디와 비번은 등록되지 않았습니다.");
			return null;
		}
	}
	*/
	@PostMapping("/login")
	public String login(@ModelAttribute("userId") String id
							, @RequestParam("userPw") String pw
							, @RequestParam("userPwChk") String pwChk
							, RedirectAttributes ra
//							, HttpSession session
							, Model model
							){
		System.out.println("/response/login 요청 발생 : POST");
		System.out.println("id : " + id); 
		System.out.println("pw : " + pw);
		System.out.println("pwChk : " + pwChk);
		
		
		
		if (id.equals("")) { // 아이디 입력하지 않은 경우
			System.out.println("아이디가 비었습니다.");
			ra.addFlashAttribute("msg2", "아이디는 필수 값이에요!");
//			session.setAttribute("msg1", "아이디는 필수 값이에요!");
//			model.
			return "redirect:/response/login"; 
		} else if (!pw.equals(pwChk)) { // 비번과 확인비번이 다른 경우
			System.out.println("두 비밀번호가 같지 않습니다.");
			ra.addFlashAttribute("msg2", "두 비밀번호가 같지 않습니다.");
//			session.setAttribute("msg1", "두 비밀번호가 같지 않습니다.");
			return "redirect:/response/login";
		} else if (id.equals("abc123") && pw.equals("1234")) {
			System.out.println("로그인성공!");
			
			return "response/res-quiz-success";
		} else { // 안전빵
			System.out.println("그런 아이디와 비번은 등록되지 않았습니다.");
			return null;
		}
	}
	
	
}




















##############################################################################
29)model, session한계, 재전송시 효율높은 scope 객체


1)위 문제 res-redirect를 아래 설명처럼 살짝 손봐서 화면에 추가내용을 넣음으로
	model의 한계와 session의 단점과 재전송시 가장 효율적인 데이터전송방법을 알아보시오.

매개변수 Model model 추가
msg라는 모델id에 대해서 각상황이오면 상황에맞게 아래 3개 중 하나를 넣어라
	-"비밀번호 확인란을 체크하세요!"
	-"그런 아이디와 비번은 등록되지 않았습니다."
	-"아이디는 필수 값이에요!"
그후 모델 id에 대한 값을 res-redirect-form에서 실패한경우(3가지)에 대해서 model value를 빨간글자로 
출력하게하라
	-빨간글자 안뜬다 그 이유는 model이 request객체와같이 재전송시에는 데이터를 잃어버리기때문이다.
		즉 바로다음 영역으로 갔을때는 살아있고 거기서 다시 다른영역으로 가면 사라진다.
		그럼 최초 get() 상태에서 로그인눌러스 post()방식으로 파라미터를 login()에 보냈고
		해당 파라미터를 login()에서 모델에 담았고 여기서 2가지다
		ㄱ.원래방식
			-모델이 담고 String값을 viewResolver에게 반환하여 .jsp를 찾아가서 거기서 model값을 활용한다.
		ㄴ.재전송방식
			-모델이 담고 .jsp로 가는게 아니라 바로 다시 컨트롤러로 오니까 영역이 바껴서 컨트롤러에서는 model 사용
				가능하지만 거기서 다시 jsp를 열었을때는 이미 소실되고 난이후다. 두영역을 갔으니까

	
model을 잠시 주석처리하고 session처럼 여러영역을 돌아다닐수있는놈들은 어떤가 보자.
session을 이용해서 똑같이 msg에 담아봐라
그럼 msg 내용이 계속 남아있고 f5할때마다 변하지 않는다.
그렇기때문에 잠깐 재전송할때만 쓰는걸 사용해서 풀어라.
	-f5할때 그때그때 변하도록해라

	-근데 진짜 희한한게 msg를 msg1 msg2 msg3안바꿔주면 나중에 했던 값들이 계속 남아있는데 그게 세션값인듯하고(주석번갈아끼우면서
											생긴세션값)
		그놈을 없애려고 브라우저도 껐다키고 서버도 껏다켰는데 안사라진다.
	-그리고 세션을 해도 userId가 계속 붙는걸 해결함. 왜 @ModelAttribute 문제를 session과 얘들 msg를 세팅하는걸로
		해결이 되는가?
		-session에 한번담기고나면 msg1 msg2 식으로 이름바꾸는게 편하다.


##############################################################################



답:


#res-redirect-form.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<%-- ResponseController 사용 --%>


<form method = "post">
<p>
	# ID : <input type = "text" name = "userId" size = "10"> <br>
	# 비밀번호 : <input type = "password" name = "userPw" size = "10"> <br>
	# 비밀번호 확인 : <input type = "password" name = "userPwChk" size = "10"> <br>
	<input type = "submit" value = "로그인">
</p>
</form>


<p style="color:red;">${msg2}</p>

</body>
</html>



#ResponseController.java
package com.spring.web.controller;

import javax.servlet.http.HttpSession;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.spring.web.model.UserVO;
import com.spring.web.model.UserVO2;

@Controller("resCon")
@RequestMapping("/response")

public class ResponseController {
	
	public ResponseController() {
		// TODO Auto-generated constructor stub
	}
	
	@GetMapping("/res-ex01")
	public void resEx01() {
		
	}
	
	//1.Model 객체를 사용하여 화면에 데이터 전송하기
	/*
	@GetMapping("/test")
	public void test(@RequestParam("age") int age,
						Model model) {
		model.addAttribute("nick", "뽀삐");
		model.addAttribute("age", age);
	}
	*/
	
	//@ModelAttribute : @RequestParam("age") int age + model.addAttribute("age", age)
					//와 같은 것이다. 포함관계
	//2.@ModelAttribute를 사용한 화면에 데이터 전송처리
	@GetMapping("/test")
	public void test(@ModelAttribute("age") int age,
			Model model) {
		model.addAttribute("nick", "뽀삐");
//		model.addAttribute("age", age);
	}
	
	//3.ModelAndView 객체를 활용한 처리
	@GetMapping("/test2")
	public ModelAndView test2() {
//		ModelAndView mv = new ModelAndView();
//		mv.addObject("userName", "박영희"); //화면에 전달할 데이터 래핑
//		mv.setViewName("/response/test2"); //viewResolver에게 전달할 문자열
//		return mv;
		
		return new ModelAndView("/response/test2", "userName", "박영희");
	}
	
	
	//res-ex02.jsp파일을 열람하는 요청메서드 작성
	@GetMapping("/res-ex02")
	public void resEx02() {
		
	}
	
	
	/*
	@PostMapping("/join")
	public String join(UserVO user, Model model) {
		model.addAttribute("user", user);
		return "response/test3";
	}
	*/
	@PostMapping("/join")
	public String join(@ModelAttribute("user") UserVO user) {
		return "response/test3";
	}
	
	@GetMapping("/res-quiz")
	public void resQuiz() {
		
	}
	
	@PostMapping("/res-login")
	public String resLogin(@ModelAttribute("user") UserVO2 user) {
		String id = user.getUserId();
		String pw = user.getUserPw();
		
		if (id.equals("kim123") && pw.equals("kkk1234")) {
			return "response/res-quiz-success";			
		}
		
		return "response/res-quiz-fail";
	}
	
	
	///////////////////////////////////////////////////////////////////
	//Redirect처리 
	//원래는 viewResolver에게 보내는 방식이 포워드 방식이다.
	//글쓰기 요청이 끝난다음에 글목록 페이지가 떠야하는데 포워드면 요청끝나고 디스패쳐왔다가 다시 db에 가야함
	//글쓰기 요청(insert)가 되고나면 다시 돌아오지않고 재요청으로  select하여 목록을 가져오면 좋다.
	//그 재요청방법이 Redirect처리다.
	//글 삭제같은경우도 delete로 게시글 지우고 목록을 보여줄때 디스패쳐까지 돌아오지않고 재요청을해서 바로 db에서 목록을
	//가져오는 것도 포워드로는 않되고 Redirect로 가능하다.
	
	//로그인 화면 요청처리
	@GetMapping("/login")
	public String login() {
		System.out.println("/response/login 요청 발생 : GET");
		return "response/res-redirect-form";
	}
	
	//로그인 검증처리
	/*
	@PostMapping("/login")
	public String login(@ModelAttribute("userId") String id
							, @RequestParam("userPw") String pw
							, @RequestParam("userPwChk") String pwChk
							, Model model
							//, HttpServletResponse response)원래 이게 jsp방식인데 spirng에선 이렇게 안해도됨
							, HttpSession session
							){
		System.out.println("/response/login 요청 발생 : POST");
		System.out.println("id : " + id); 
		System.out.println("pw : " + pw);
		System.out.println("pwChk : " + pwChk);
		
		
		
		if (id.equals("")) { // 아이디 입력하지 않은 경우
//			response.sendRedirect(); 원래 이게 jsp방식인데 spirng에선 이렇게 안해도됨
			System.out.println("아이디가 비었습니다.");
//			model.addAttribute("msg", "아이디는 필수 값이에요!");
			session.setAttribute("msg", "아이디는 필수 값이에요!");
			return "redirect:/response/login"; // jsp를 열러가지않고 바로 다시 controller의 
												// /resposne/login uri를 받을수있는 메서드를
												// 찾는다.
												//이때 redirect로 보내면 무조건 get요청이다.
												//그래서 위에 로그인화면요청처리로 간다.
		} else if (!pw.equals(pwChk)) { // 비번과 확인비번이 다른 경우
			System.out.println("두 비밀번호가 같지 않습니다.");
//			model.addAttribute("msg", "비밀번호 확인란을 체크하세요!");
			session.setAttribute("msg", "두 비밀번호가 같지 않습니다.");
			return "redirect:/response/login";
		} else if (id.equals("abc123") && pw.equals("1234")) {
			System.out.println("로그인성공!");
			return "response/res-quiz-success";
		} else { // 안전빵
			System.out.println("그런 아이디와 비번은 등록되지 않았습니다.");
//			model.addAttribute("msg", "그런 아이디와 비번은 등록되지 않았습니다.");
			return null;
		}
	}
	*/
	@PostMapping("/login")
	public String login(@ModelAttribute("userId") String id
							, @RequestParam("userPw") String pw
							, @RequestParam("userPwChk") String pwChk
							, RedirectAttributes ra
//							, HttpSession session
							, Model model
							){
		System.out.println("/response/login 요청 발생 : POST");
		System.out.println("id : " + id); 
		System.out.println("pw : " + pw);
		System.out.println("pwChk : " + pwChk);
		
		
		
		if (id.equals("")) { // 아이디 입력하지 않은 경우
			System.out.println("아이디가 비었습니다.");
			ra.addFlashAttribute("msg2", "아이디는 필수 값이에요!");
//			session.setAttribute("msg1", "아이디는 필수 값이에요!");
//			model.
			return "redirect:/response/login"; 
		} else if (!pw.equals(pwChk)) { // 비번과 확인비번이 다른 경우
			System.out.println("두 비밀번호가 같지 않습니다.");
			ra.addFlashAttribute("msg2", "두 비밀번호가 같지 않습니다.");
//			session.setAttribute("msg1", "두 비밀번호가 같지 않습니다.");
			return "redirect:/response/login";
		} else if (id.equals("abc123") && pw.equals("1234")) {
			System.out.println("로그인성공!");
			
			return "response/res-quiz-success";
		} else { // 안전빵
			System.out.println("그런 아이디와 비번은 등록되지 않았습니다.");
			return null;
		}
	}
	
	
}
























































































21.02.09.6회차
===============================================================================
*SpringFrameWork를 이용하여 학생들의 점수를 관리하는 웹어플리케이션 제작(db는 list로 대체)
===============================================================================

































































##############################################################################
30)MVC패턴으로 점수등록, 점수확인, 삭제, 개별조회
	-MVC패턴  흐름 (Controller -> Service -> Repository(DAO) -> DB)
		-각각 의존성이다. Controller는 service가 있어야하고 등등
	


1)학생들의 점수를 등록하고 삭제할수있으며 list.jsp 출력하였을때 전체학생의 점수를 볼수있도록 mvc 패턴으로 웹어플리케이션을 만드시오.
	-각 클래스 이름에 맞는 아노테이션 사용하여 디스패쳐가 자동빈등록할수 있도록 하고 
		차후 스캔해서 singleton형식의 객체들을 사용한다.(autowired)

client uri : http/localhost:8080/web/score/register

<controller>
ScoreController.java
	-/score/delete 요청시에는 해당 학번의 학생정보 삭제처리한뒤에
		웹창에서 바로 삭제된결과가 보여야한다.

<model>
ScoreVO.java

<repository> : (DAO)
IScoreDAO.java // interface
ScoreDAO.java
	-현재 db가 없으니 scoreList라는 list 변수 만들어서 사용
	-삭제시 deleteScore()를 사용하라
<service>
IScoreService.java
ScoreService.java

<views/score>
write-form.jsp
	-post 요청 uri : /web/score/register
write-result.jsp
list.jsp
	-학번만 list.jsp에서 생성하여 넣어라.
		-학번을 jstl이용해서 변수 stuNum만들고 1번부터 한놈당 부여. 전체 리스트 조회할때 한놈나올때마다 제일앞에
				-이때 인덱스는 0부터 나오니 1더해야함
<IScoreDAO, IScoreService 메소드>
		// 매개변수의 ?는 공백일수도, 존재할수도 있다.
	//점수 등록 기능 
	void insertScore(?);
	
	//점수 전체 조회 기능
	List<ScoreVO> selectAllScores(?);
	
	//점수 삭제기능
	void deleteScore(?); // stuNum을 사용
	
<write-form.jsp 출력화면>
시험 점수 등록
# 이름 : 
	
# 국어 : 

# 영어 : 

# 수학 : 

확인

<write-result.jsp 출력화면>
점수 등록 성공!
다른 점수 등록하기 점수 전체 조회 점수 개별 조회(이놈은 이문제에서 만드는게 아니니까 uri #으로 해놔라)


<최종결과> : list.jsp페이지 출력화면
학생들의 전체 성적 조회
# 학번 : 1, 이름 : 박여으히, 국어 : 50, 영어 : 39, 수학 : 99, 총점 : 188, 평균 : 62.67   [삭제]

# 학번 : 2, 이름 : 김철수, 국어 : 55, 영어 : 99, 수학 : 23, 총점 : 177, 평균 : 59.0   [삭제]

다른 점수 등록하기

<위의 김철수의 삭제 클릭시 최종결과> : 삭제 완료하면 아래 결과에다가 위에 팝업을 js로 띄워서 점수 삭제 완료! 
				라고 표시해라. f12하면 나오는곳의 console에는 delSuccess가 뜨게하라
					-중간에 만들어야할 변수 이름들은 자유롭게
학생들의 전체 성적 조회
# 학번 : 1, 이름 : 박여으히, 국어 : 50, 영어 : 39, 수학 : 99, 총점 : 188, 평균 : 62.67   [삭제]

다른 점수 등록하기









2)위의 상황에서 개별점수 조회기능이 돌아가도록 mvc패턴에 입각하여 앱을 설계하라
-/selectOne 요청을 통해 해당 학번을 가진 학생의 성적정보를 조회하여 search-result.jsp에서 해당 정보를
	화면에 출력하세요.
	-아래 제공된 search.jsp를 이용하시오
		-조회할 학번에 존재하지 않는 학번입력시 아래에 학번정보가 없습니다. 라고 빨간글씨띄워라
		-search.jsp로 가기위한 uri : /score/search
				-근데 그냥 selectOne()메소드로 통일해서
					/score/selectOne 으로 해도 됨 자유
-기존 service, dao의 메서드에서 추가로 더 만들어야함
	-이름은 자유롭게 혹은 selectOneScore(?)
-아래 메세지가 출력될 상황이 나면 search.jsp에서 조회할 학번 아래에 빨간글자로 아래 메세지를 출력하라.
	-없는 학번을 입력할시 : 학번정보가 없습니다.
	-숫자가아닌 문자를 입력할시 : 숫자로만 입력하세요!


#search.jsp 

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>개별 점수 조회</h2>
<form action = "/web/score/selectOne">
	<p>
		#조회할 학번 : <input type = "text" name = "stuNum" size = "5">
				   <input type = "submit" value = "조회">
	</p>
</form>

</body>
</html>

##############################################################################



답:

---------------------------------------

<controller>
ScoreController.java

package com.spring.web.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.spring.web.model.ScoreVO;
import com.spring.web.service.IScoreService;

@Controller
@RequestMapping("/score")
public class ScoreController {
	@Autowired
	private IScoreService service;
	
	//점수 등록 화면을 열어주는 처리를 하는 요청메서드
	@GetMapping("/register")
	public String register() {
		System.out.println("/score/register: GET");
		return "score/write-form";
	}
	
	//점수 등록을 처리하는 요청 메서드
	@PostMapping("/register")
	public String register(ScoreVO scores) {
		System.out.println("/score/register: POST");
		System.out.println("Controller param: " + scores);
		
		service.insertScore(scores);
		return "score/write-result";
	}
	
	//점수 전체 조회를 처리하는 요청 메서드
	@GetMapping("/list")
	public void list(Model model) {
		System.out.println("/score/list: GET");
		List<ScoreVO> list = service.selectAllScores();
		model.addAttribute("sList", list);
		
	}
	
	//점수 삭제 요청 처리 메서드
	@GetMapping("/delete")
	public String delete(@RequestParam("stuNum") int stuNum, RedirectAttributes ra) {
		List<ScoreVO> list = service.selectAllScores();
		service.deleteScore(stuNum);
		ra.addFlashAttribute("message", "delSuccess");
		return "redirect:/score/list";
	}
	
	//점수 개별 조회 화면 열람요청 메서드
	@GetMapping("/search")
	public void search() {
		System.out.println("/score/search: GET");
		
	}
	
	@PostMapping("/selectOne")
	public String selectOne(String stuNum, Model model, RedirectAttributes ra) {
		
		/*
		try {
			ScoreVO stu = service.selectOneScore(Integer.parseInt(stuNum));			
			model.addAttribute("stu", stu);
			return "/score/select-result";
		} catch(NumberFormatException e) {
			ra.addFlashAttribute("message", "숫자로만 입력하세요!");
			return "redirect:/score/search"; 
		} catch(IndexOutOfBoundsException e) {
			ra.addFlashAttribute("message", "학번정보가 없습니다.");
			return "redirect:/score/search";
		} 
		*/
		List<ScoreVO> list = service.selectAllScores();
		
		try {
			int n = Integer.parseInt(stuNum);
			if (n > list.size()) {
				ra.addFlashAttribute("message", "학번정보가 없습니다.");
				return "redirect:/score/search";
			}
			
			ScoreVO stu = service.selectOneScore(n);			
			model.addAttribute("stu", stu);
			return "score/select-result";
		} catch(NumberFormatException e) {
			ra.addFlashAttribute("message", "숫자로만 입력하세요!");
			return "redirect:/score/search"; 
		} 
	}
}




---------------------------------------


<model>
ScoreVO.java


package com.spring.web.model;

public class ScoreVO {
	private String stuName;
	private Integer kor;
	private Integer eng;
	private Integer math;
	private Integer total;
	private Double average;
	
	
	public ScoreVO() {
		// TODO Auto-generated constructor stub
	}
	
	
	//총점 평균을 구하는 메서드
	public void calcData() {
		this.total = this.kor + this.eng + this.math;
		this.average = Math.round((this.total / 3.0) * 100) / 100.0;
		
	}
	
	public String getStuName() {
		return stuName;
	}
	public void setStuName(String stuName) {
		this.stuName = stuName;
	}
	public Integer getKor() {
		return kor;
	}
	public void setKor(Integer kor) {
		this.kor = kor;
	}
	public Integer getEng() {
		return eng;
	}
	public void setEng(Integer eng) {
		this.eng = eng;
	}
	public Integer getMath() {
		return math;
	}
	public void setMath(Integer math) {
		this.math = math;
	}
	public Integer getTotal() {
		return total;
	}
	public void setTotal(Integer total) {
		this.total = total;
	}
	public Double getAverage() {
		return average;
	}
	public void setAverage(Double average) {
		this.average = average;
	}


	@Override
	public String toString() {
		return "ScoreVO [stuName=" + stuName + ", kor=" + kor + ", eng=" + eng + ", math=" + math + ", total=" + total
				+ ", average=" + average + "]";
	}
	
	
	
	
}


---------------------------------------



<repository> : (DAO)

#IScoreDAO.java // interface

package com.spring.web.repository;

import java.util.List;

import com.spring.web.model.ScoreVO;

public interface IScoreDAO {
	//점수 등록 기능
	void insertScore(ScoreVO scores);
	
	//점수 전체 조회 기능
	List<ScoreVO> selectAllScores();
	
	//점수 삭제기능
	void deleteScore(int stuNum);
	
	ScoreVO selectOneScore(int stuNum);
}




#ScoreDAO.java
	-현재 db가 없으니 scoreList라는 list 변수 만들어서 사용
	-삭제시 deleteScore()를 사용하라


package com.spring.web.repository;

import java.util.ArrayList;
import java.util.List;

import org.springframework.stereotype.Repository;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.spring.web.model.ScoreVO;

@Repository
public class ScoreDAO implements IScoreDAO {
	//학생들의 점수정보를 저장할 리스트 생성(DB대용)_ DB대용 : scoreList
	private List<ScoreVO> scoreList = new ArrayList<>();
	
	@Override
	public void insertScore(ScoreVO scores) {
		// TODO Auto-generated method stub
		System.out.println("Repository param: " + scores);
		scoreList.add(scores);
	}

	@Override
	public List<ScoreVO> selectAllScores() {
		// TODO Auto-generated method stub
		return scoreList;
	}

	@Override
	public void deleteScore(int stuNum) {
		// TODO Auto-generated method stub
		scoreList.remove(stuNum - 1);
	}

	public ScoreVO selectOneScore(int stuNum) {
		return scoreList.get(stuNum - 1);
	}
}


---------------------------------------




<service>
#IScoreService.java

package com.spring.web.service;

import java.util.List;

import com.spring.web.model.ScoreVO;

public interface IScoreService {
	//점수 등록 기능
	void insertScore(ScoreVO scores);
	
	//점수 전체 조회 기능
	List<ScoreVO> selectAllScores();
	
	//점수 삭제기능
	void deleteScore(int stuNum);
	
	ScoreVO selectOneScore(int stuNum);
	
}





#ScoreService.java

package com.spring.web.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.spring.web.model.ScoreVO;
import com.spring.web.repository.IScoreDAO;


@Service
public class ScoreService implements IScoreService {

	@Autowired
	private IScoreDAO dao;
	
	@Override
	public void insertScore(ScoreVO scores) {
		// TODO Auto-generated method stub
		scores.calcData();
		dao.insertScore(scores);
	}

	@Override
	public List<ScoreVO> selectAllScores() {
		// TODO Auto-generated method stub
		return dao.selectAllScores();
	}

	@Override
	public void deleteScore(int stuNum) {
		// TODO Auto-generated method stub
		dao.deleteScore(stuNum);
	}
	
	public ScoreVO selectOneScore(int stuNum) {
		return dao.selectOneScore(stuNum);
	}

}


---------------------------------------




<views/score>
#write-form.jsp


<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>시험 점수 등록</h2>
<form method = "post">
	<p>
		# 이름 : <input type = "text" name = "stuName"><br>
		# 국어 : <input type = "text" name = "kor"><br>
		# 영어 : <input type = "text" name = "eng"><br>
		# 수학 : <input type = "text" name = "math"><br>
		<input type = "submit" value = "확인">
	</p>
</form>

</body>
</html>



#write-result.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	<h2>점수 등록 성공!</h2>
	<a href = "/web/score/register">다른 점수 등록하기</a>
	<a href = "/web/score/list">점수 전체 조회</a>
	<a href = "/web/score/search">점수 개별 조회</a>

</body>
</html>


#list.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>    
    
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>학생들의 전체  성적 조회</h2>
<c:forEach var = "stu" items = "${sList}" varStatus = "stuNum">
	<p>
		# 학번 : ${stuNum.index + 1}, 이름 : ${stu.stuName}, 국어 : ${stu.kor}, 영어 : ${stu.eng},
		 수학 : ${stu.math}, 총점 : ${stu.total}, 평균 : ${stu.average}
		&nbsp;
		<a href = "/web/score/delete?stuNum=${stuNum.index + 1}">[삭제]</a>	
	</p>
</c:forEach>

<a href = "/web/score/register">다른 점수 등록하기</a> 
<a href = "/web/score/list">점수 전체 조회</a>
<a href = "/web/score/search">점수 개별 조회</a>

<script type = "text/javascript">
	const msg = "${message}";
	console.log(msg);
	if (msg === "delSuccess") {
		alert("점수 삭제 완료!");
	}
</script>


</body>
</html>




#search.jsp


<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>개별 점수 조회</h2>
<form action = "/web/score/selectOne" method = "post">
	<p>
		#조회할 학번 : <input type = "text" name = "stuNum" size = "5">
				   <input type = "submit" value = "조회">
	</p>
</form>

<p style = "color:red;">
	${message}
</p>

</body>
</html>



#select-result.jsp




<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>${stu.stuName}학생 성적 정보 조회</h2>

<p>	
	# 국어 : ${stu.kor} <br>
	# 영어 : ${stu.eng} <br>
	# 수학 : ${stu.math} <br>
	# 총점 : ${stu.total} <br>
	# 평균 : ${stu.average} 
</p>

<a href = "/web/score/register">다른 점수 등록하기</a> 
<a href = "/web/score/list">점수 전체 조회</a>
<a href = "/web/score/search">점수 개별 조회</a>

</body>
</html>
















































21.02.10.7회차
===============================================================================
*SpringFrameWork를 이용한 게시판 만들기(DB없음)
===============================================================================

















































##############################################################################
31)SpringFrameWork를 통한 게시판 웹어플리케이션 구현(DB없는상태)
	-기존 SpringWebBasic 프로젝트 이용
<model>
BoardVO
	-String writer
	-String title
	-Sring content
	-toString() 재정의해서 내부 전체내용 파악이 용이하게하라
	
<controller>
BoardController

<service>
IBoardService
BoardService

<repository>
IBoardDAO
BoardDAO

<views/board>
write.jsp
list.jsp
content.jsp
modify.jsp


1)글 등록, 목록보기, 삭제기능 구현
	-bean등록 주입 등 필요한건알아서 채운다.
	-write에서 게시글등록후 확인으로 post 보내면 바로 list.jsp열리도록해라
		-이렇게하면 write-resultl.jsp 만들필요없다.
	-list.jsp에서는 아래조건이 지켜져야함
		<%-- 컨트롤러가 가져온 게시글 데이터를 반복하여 출력 --%>
		<%-- 게시물 개수가 0개일 경우 목록대신 "게시물이 존재하지 않습니다." 출력--%>
	-DB는 list로 대체 (articles)
		-하나의 게시물은 article로 표현하며 
			getContent()는 content인 내용만 
			가져오는게 아니라
			content를 확인하기위해서 article 객체를 
			반환하는 기능임
	-사용자 uri : http://localhost:8080/web/write

<model>
BoardVO

<controller>
BoardController

<service>
IBoardService
BoardService

<repository>
IBoardDAO
BoardDAO




<IBoardService method>
	//게시글 목록 가져오기
	List<BoardVO> getArticles();
	
	//게시글 등록
	void insertArticle(BoardVO article);
	
	//게시글 삭제
	void deleteArticle(int boardNo);
	
	//게시글 내용보기
	BoardVO getContent(int boardNO);
	
	//게시글 수정
	void modifyArticle(BoardVO article, int boardNo);

<IBoardDAO method> : int 매개변수이름만다르다. 데이터베이스로가야하니 그렇다
	//게시글 목록 가져오기
	List<BoardVO> getArticles();
	
	//게시글 등록
	void insertArticle(BoardVO article);
	
	//게시글 삭제
	void deleteArticle(int index);
	
	//게시글 내용보기
	BoardVO getContent(int index);
	
	//게시글 수정
	void modifyArticle(BoardVO article, int boardNo);




<views/board>
write.jsp
list.jsp


#write.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>게시글 등록</h2>

<form action = "#" method="post">

	<p>
		# 작성자: <input type="text" name="writer"><br>
		# 제목: <input type="text" name="title"><br>
		# 내용: <textarea rows="3" name="content"></textarea>
		<br>
		<input type="submit" value="등록">
	</p>
</form>

<a href="#">글 목록보기</a>
</body>
</html>




#list.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>게시글 목록</h2>
<table border = "1">

	<tr>
		<td>번호</td>
		<td>작성자</td>
		<td>제목</td>
		<td>비고</td>
	</tr>
	
	<%-- 컨트롤러가 가져온 게시글 데이터를 반복하여 출력 --%>
	<%-- 게시물 개수가 0개일 경우 목록대신 "게시물이 존재하지 않습니다." 출력--%>
	<tr>
		<td>1</td>
		<td>홍길동</td>
		<td>
			<a href = "#">메롱메롱</a>
		</td>
		<td>
			<a href = "#">[삭제]</a>
		</td>
	</tr>
</table>

<p>
	<a href = "#">게시글 작성하기</a>
</p>



</body>
</html>



2.게시글 내용보기 기능과 게시글 수정하기 기능을 추가하여 아래 jsp가 잘 출력되도록하라.
	-글번호는 VO에 없다 이걸유념해서해야함. vo에 글번호추가하란뜻이아님
	-글을 수정(수정버튼 클릭)하고나면 게시물 내용이 보여야한다.



<views/board>
#content.jsp 추가
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>?번 게시물 내용</h2>

<p>
	# 글번호: ?<br>
	# 작성자: ?<br>
	# 제목: ?<br>
	# 내용: <textarea rows="3" disabled>?</textarea>	
</p>

<a href="#">글 목록보기</a>&nbsp;
<a href="#">글 수정하기</a>

</body>
</html>



#modify.jsp 추가
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>${boardNo}번 게시물 내용 수정</h2>
<form action = "#" method="post">
	<p>
		# 글번호: ?<br>
		# 작성자: <input type="text" name="writer" value="?"><br>
		# 제목: <input type="text" name="title" value="?"><br>
		# 내용: <textarea rows="3" name="content">?</textarea>	
		<br>
		<input type="submit" value="수정">
	</p>
</form>

<a href="#">글 목록보기</a>&nbsp;


</body>
</html>

##############################################################################


답:

<model>
BoardVO

<controller>
BoardController

<service>
IBoardService
BoardService

<repository>
IBoardDAO
BoardDAO

<views/board>
write.jsp
list.jsp
content.jsp
modify.jsp



-------------------------------------------

<model>

#BoardVO


package com.spring.web.model;

public class BoardVO {
	private String writer;
	private String title;
	private String content;
	
	public BoardVO() {
		// TODO Auto-generated constructor stub
	}

	public String getWriter() {
		return writer;
	}

	public void setWriter(String writer) {
		this.writer = writer;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	@Override
	public String toString() {
		return "BoardVO [writer=" + writer + ", title=" + title + ", content=" + content + "]";
	}
	
	
	

}



-------------------------------------------
<controller>


#BoardController

package com.spring.web.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import com.spring.web.model.BoardVO;
import com.spring.web.service.IBoardService;

@Controller
@RequestMapping("/board")
public class BoardController {
	@Autowired
	private IBoardService service;
	
	//등록
	@RequestMapping(value = "/write", method = RequestMethod.GET)
	public void write() {
		System.out.println("/board/write 요청됨 : GET");
	}
	
	@RequestMapping(value = "/write", method = RequestMethod.POST)
	public String write(BoardVO article) {
		System.out.println("/board/write 요청됨 : POST");
		service.insertArticle(article);
		return "redirect:/board/list";
	}
	
	//목록보기
	@RequestMapping(value = "/list", method = RequestMethod.GET)
	public void list(Model model) {
		List<BoardVO> articles = service.getArticles();
		model.addAttribute("articles", articles);
	}
	
	//삭제
	@RequestMapping(value = "/delete", method = RequestMethod.GET)
	public String delete(int boardNo) {
		System.out.println("/board/delete?boardNo=" + boardNo + " 요청됨 : GET");
		service.deleteArticle(boardNo);
		return "redirect:/board/list";
	}
	
	//게시글확인(상세보기)
	@RequestMapping(value = "/content", method = RequestMethod.GET)
	public void content(@ModelAttribute("boardNo") int boardNo, Model model) {
		System.out.println("/board/content 요청됨 : GET");
		BoardVO article = service.getContent(boardNo);
		model.addAttribute("article", article);
	}
	
	//게시글 수정
	@RequestMapping(value = "/modify", method = RequestMethod.GET)
	public void modify(@ModelAttribute("boardNo") int boardNo,
			Model model) {
		System.out.println("/board/modify 요청됨 : GET");
		BoardVO article = service.getContent(boardNo);
		model.addAttribute("article", article);
	}
	
	@RequestMapping(value = "/modify", method = RequestMethod.POST)
	public String modify(BoardVO article, int boardNo) {
		System.out.println("/board/modify 요청됨 : POST");
		service.modifyArticle(article, boardNo);
		return "redirect:/board/content?boardNo=" + boardNo;
	}
	
	
}



-------------------------------------------
<service>



#IBoardService

package com.spring.web.service;

import java.util.List;

import com.spring.web.model.BoardVO;

public interface IBoardService {
	//게시글 목록 가져오기
	List<BoardVO> getArticles();
	
	//게시글 등록
	void insertArticle(BoardVO article);
	
	//게시글 삭제
	void deleteArticle(int boardNo);
	
	//게시글 내용보기
	BoardVO getContent(int boardNo);
	
	//게시글 수정
	void modifyArticle(BoardVO article, int boardNo);
}



#BoardService



package com.spring.web.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.spring.web.model.BoardVO;
import com.spring.web.repository.IBoardDAO;

@Service
public class BoardService implements IBoardService {
	@Autowired
	private IBoardDAO dao;
	
	@Override
	public List<BoardVO> getArticles() {
		// TODO Auto-generated method stub
		return dao.getArticles();
	}

	@Override
	public void insertArticle(BoardVO article) {
		// TODO Auto-generated method stub
		dao.insertArticle(article);
	}

	@Override
	public void deleteArticle(int boardNo) {
		// TODO Auto-generated method stub
		dao.deleteArticle(boardNo - 1);
	}

	@Override
	public BoardVO getContent(int boardNo) {
		// TODO Auto-generated method stub
		return dao.getContent(boardNo - 1);
	}

	@Override
	public void modifyArticle(BoardVO article, int boardNo) {
		// TODO Auto-generated method stub
		dao.modifyArticle(article, boardNo - 1);
	}

}

-------------------------------------------
<repository>



#IBoardDAO


package com.spring.web.repository;

import java.util.List;

import com.spring.web.model.BoardVO;

public interface IBoardDAO {
	//게시글 목록 가져오기
	List<BoardVO> getArticles();
	
	//게시글 등록
	void insertArticle(BoardVO article);
	
	//게시글 삭제
	void deleteArticle(int index);
	
	//게시글 내용보기
	BoardVO getContent(int index);
	
	//게시글 수정
	void modifyArticle(BoardVO article, int boardNo);
}




#BoardDAO


package com.spring.web.repository;

import java.util.ArrayList;
import java.util.List;

import org.springframework.stereotype.Repository;

import com.spring.web.model.BoardVO;

@Repository
public class BoardDAO implements IBoardDAO {
	//게시글을 저장할 리스트: DB대용
	private List<BoardVO> articles = new ArrayList<>();
	
	
	@Override
	public List<BoardVO> getArticles() {
		// TODO Auto-generated method stub
		return articles;
	}

	@Override
	public void insertArticle(BoardVO article) {
		// TODO Auto-generated method stub
		articles.add(article);
		System.out.println(article); // 로그찍기
		System.out.println("게시글 저장 완료!!");
	}

	@Override
	public void deleteArticle(int index) {
		// TODO Auto-generated method stub
		articles.remove(index);
		System.out.println((index + 1) + "번 삭제 완료!");
	}

	@Override
	public BoardVO getContent(int index) {
		// TODO Auto-generated method stub
		return articles.get(index);
	}

	@Override
	public void modifyArticle(BoardVO article, int index) {
		// TODO Auto-generated method stub
		articles.set(index, article);
	}

}


-------------------------------------------
<views/board>



#write.jsp


<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>게시글 등록</h2>

<form method="post">

	<p>
		# 작성자: <input type="text" name="writer"><br>
		# 제목: <input type="text" name="title"><br>
		# 내용: <textarea rows="3" name="content"></textarea>
		<br>
		<input type="submit" value="등록">
	</p>
</form>
<a href = "<c:url value = '/board/list'/>">글 목록보기</a>

</body>
</html>







#list.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<c:if test = "${articles.size() <= 0}">
	<p>게시물이 존재하지 않습니다.</p>
</c:if>

<c:if test = "${articles.size() > 0}">
	<h2>게시글 목록</h2>
	<table border = "1">
	
		<tr>
			<td>번호</td>
			<td>작성자</td>
			<td>제목</td>
			<td>비고</td>
		</tr>
		
		<%-- 컨트롤러가 가져온 게시글 데이터를 반복하여 출력 --%>
		<%-- 게시물 개수가 0개일 경우 목록대신 "게시물이 존재하지 않습니다." 출력--%>
	
		
		<c:forEach var = "article" items = "${articles}" varStatus = "num">
			<tr>
				<td>${num.index + 1}</td>
				<td>${article.writer}</td>
				<td>
					<a href = "<c:url value = '/board/content?boardNo=${num.index + 1}'/>">${article.title}</a>
				</td>
				<td>
					<a href = "<c:url value = '/board/delete?boardNo=${num.index + 1}'/>">[삭제]</a>
				</td>
			</tr>
		</c:forEach>
		
	</table>
</c:if>
<p>
	<a href = "<c:url value = '/board/write'/>">게시글 작성하기</a>
</p>



</body>
</html>

#content.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>${boardNo}번 게시물 내용</h2>

<p>
	# 글번호: ${boardNo}<br>
	# 작성자: ${article.writer}<br>
	# 제목: ${article.title}<br>
	# 내용: <textarea rows="3" disabled>${article.content}</textarea>	
</p>

<a href="<c:url value = '/board/list'/>">글 목록보기</a>&nbsp;
<a href="<c:url value = '/board/modify?boardNo=${boardNo}'/>">글 수정하기</a>

</body>
</html>





#modify.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>${boardNo}번 게시물 내용 수정</h2>
<form method="post">
	<input type = "hidden" name = "boardNo" value = "${boardNo}">
	<p>
		# 글번호: ${boardNo}<br>
		# 작성자: <input type="text" name="writer" value="${article.writer}"><br>
		# 제목: <input type="text" name="title" value="${article.title}"><br>
		# 내용: <textarea rows="3" name="content">${article.content}</textarea>
		<br>
		<input type="submit" value="수정">
	</p>
</form>

<a href="<c:url value = '/board/list'/>">글 목록보기</a>&nbsp;


</body>
</html>






##############################################################################
32)MySQL 설치
	-mysql.com
mySQL 8.0.11.0
	-custom
		-server
		-workbench
환경설정
C:\Program Files\MySQL\MySQL Server 8.0\bin //혹은 command 머시기 아이콘눌러서 들어가면
						//비번만 쳐도 됨
에서 mysql -u root -p
비번(설치할때 쓴거): mysql
SELECT NOW();
해서 현재시간나오면 문제없이 잘된거임

workbench 확인
root사람모양있는거 들어가서 새 sql파일 만들고 SELECT NOW(); 입력후 번개모양아니면
ctrl enter해서 현재시각 나오면 이상없는것임

##############################################################################

답: 없음 위에 있는거 그대로 하면 됨



































































































21.02.14.8회차
===============================================================================
*단위테스트(junit), spring-jdbc환경구축, MySQL을 이용한 점수관리 프로그램 실습
===============================================================================



























































































##############################################################################
33) Spring-JDBC 사용을 위한 환경구축 및 spring 단위테스트

*db생성
	-이름: spring
		-새로고침해야 생성된게 보임
	-set as default Schema

*springlegacy project 생성
	-이름: SpringDBAccess
	-com.spring.database


*톰캣서버추가

*버전변경(pom.xml)
	-artifactId : database에서 db로 변경(database로 하면 설정충돌난데)
	-자바버전
	-서블릿설정
		-3.1.0
		-artifactId javax.
	-컴파일러플러그인
		-3.5.1
		-자바버전 1.8
	-junit 4.7 -> 4.12
	-art f5해서 메이븐 업데이트 적용

*한글 인코딩 필터설정(web.xml)

*서버 돌려서 문제없는가 확인

*maven(pom.xml 의존성파일)
-spring-jdbc 검색
	-5.1.5 버전 복사
	-<AspectJ> 위에다가 붙여넣기
		-메이븐에 의존성파일 설치해야하는거 소스 복사붙여넣기하는 곳에 붙여넣기 ㄱㄱ
	-버전 5.1.5로 되어있는거 <version>5.1.5.RELEASE</version> 를 아래처럼 변경
		    <version>${org.springframework-version}</version> 
		-왜 변경하는지 : 제일위에 springframework에 대한 설정한부분에서 version을 5.1.5로 했기때문에
			그아래 spring 관련 프로그램(라이브러리)들도 버전을 똑같이 5.1.5로 해주어야하고 차후 springframework
			의 버전을 높혔을때 관련 프로그램들도 자동으로 올라가게 하기위해서 버전을 일치포매팅 해주는 것이다.

-MySQL Connector/J 검색
	-8.0.15 버전 복사


-HikariCP 검색
	-2.7.8 버전 복사


*클래스 생성 : 위에 db 관련된 설정들 또는 jdbc가 잘 되는지 테스트하기 위함이다.
	-package com.spring.database.test;
	-클래스이름 : DbConnectTest 
		-내부 메소드 이름 : connectTest()
	-여기서 driver, url, uid(root), upw(mysql)를 이용하여 전통적인 jdbc 방법을 테스트하기위한 작업을 해야함(코드작성)
		-try,catch에서 conn 만들고 해당 conn의 주소값을 넣어라
		-conn객체를 제거하기도 해야한다

*spring 단위테스트
	-위에거 테스트하려면 객체만들고 귗낳아지는데 아래처럼 하면 걍 겜 끝!
	-@Test
	-<출력내용>
		DB 커넥션 성공!
		conn : com.mysql.cj.jdbc.ConnectionImpl@10db82ae
##############################################################################


답:




#pom.xml

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/maven-v4_0_0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>com.spring</groupId>
	<artifactId>db</artifactId>
	<name>SpringDBAccess</name>
	<packaging>war</packaging>
	<version>1.0.0-BUILD-SNAPSHOT</version>
	<properties>
		<java-version>1.8</java-version>
		<org.springframework-version>5.1.5.RELEASE</org.springframework-version>
		<org.aspectj-version>1.6.10</org.aspectj-version>
		<org.slf4j-version>1.6.6</org.slf4j-version>
	</properties>
	<dependencies>
		<!-- Spring -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
			<version>${org.springframework-version}</version>
			<exclusions>
				<!-- Exclude Commons Logging in favor of SLF4j -->
				<exclusion>
					<groupId>commons-logging</groupId>
					<artifactId>commons-logging</artifactId>
				 </exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>${org.springframework-version}</version>
		</dependency>
				
		<!-- spring-jdbc -->
		<dependency>
		    <groupId>org.springframework</groupId>
		    <artifactId>spring-jdbc</artifactId>
		    <version>${org.springframework-version}</version>
		</dependency>
		
		<!--  MySQL Connector/J  -->
		<dependency>
		    <groupId>mysql</groupId>
		    <artifactId>mysql-connector-java</artifactId>
		    <version>8.0.15</version>
		</dependency>
		
		<!--  HikariCP : Connection pool -->
		<!-- https://mvnrepository.com/artifact/com.zaxxer/HikariCP -->
		<dependency>
		    <groupId>com.zaxxer</groupId>
		    <artifactId>HikariCP</artifactId>
		    <version>2.7.8</version>
		</dependency>
				
		<!-- AspectJ -->
		<dependency>
			<groupId>org.aspectj</groupId>
			<artifactId>aspectjrt</artifactId>
			<version>${org.aspectj-version}</version>
		</dependency>	
		
		<!-- Logging -->
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-api</artifactId>
			<version>${org.slf4j-version}</version>
		</dependency>
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>jcl-over-slf4j</artifactId>
			<version>${org.slf4j-version}</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-log4j12</artifactId>
			<version>${org.slf4j-version}</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>log4j</groupId>
			<artifactId>log4j</artifactId>
			<version>1.2.15</version>
			<exclusions>
				<exclusion>
					<groupId>javax.mail</groupId>
					<artifactId>mail</artifactId>
				</exclusion>
				<exclusion>
					<groupId>javax.jms</groupId>
					<artifactId>jms</artifactId>
				</exclusion>
				<exclusion>
					<groupId>com.sun.jdmk</groupId>
					<artifactId>jmxtools</artifactId>
				</exclusion>
				<exclusion>
					<groupId>com.sun.jmx</groupId>
					<artifactId>jmxri</artifactId>
				</exclusion>
			</exclusions>
			<scope>runtime</scope>
		</dependency>

		<!-- @Inject -->
		<dependency>
			<groupId>javax.inject</groupId>
			<artifactId>javax.inject</artifactId>
			<version>1</version>
		</dependency>
				
		<!-- Servlet -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>3.1.0</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet.jsp</groupId>
			<artifactId>jsp-api</artifactId>
			<version>2.1</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jstl</artifactId>
			<version>1.2</version>
		</dependency>
	
		<!-- Test -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.12</version>
			<scope>test</scope>
		</dependency>        
	</dependencies>
    <build>
        <plugins>
            <plugin>
                <artifactId>maven-eclipse-plugin</artifactId>
                <version>2.9</version>
                <configuration>
                    <additionalProjectnatures>
                        <projectnature>org.springframework.ide.eclipse.core.springnature</projectnature>
                    </additionalProjectnatures>
                    <additionalBuildcommands>
                        <buildcommand>org.springframework.ide.eclipse.core.springbuilder</buildcommand>
                    </additionalBuildcommands>
                    <downloadSources>true</downloadSources>
                    <downloadJavadocs>true</downloadJavadocs>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.5.1</version>
                <configuration>
                    <source>1.8</source>
                    <target>1.8</target>
                    <compilerArgument>-Xlint:all</compilerArgument>
                    <showWarnings>true</showWarnings>
                    <showDeprecation>true</showDeprecation>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>exec-maven-plugin</artifactId>
                <version>1.2.1</version>
                <configuration>
                    <mainClass>org.test.int1.Main</mainClass>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>



#web.xml

<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">

	<!-- The definition of the Root Spring Container shared by all Servlets and Filters -->
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/spring/root-context.xml</param-value>
	</context-param>
	
	<!-- Creates the Spring Container shared by all Servlets and Filters -->
	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>

	<!-- Processes application requests -->
	<servlet>
		<servlet-name>appServlet</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>/WEB-INF/spring/appServlet/servlet-context.xml</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>
		
	<servlet-mapping>
		<servlet-name>appServlet</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping>


	<!-- 한글 인코딩 필터 설정(톰캣 내부의 한글처리) -->
	<filter>
	    <filter-name>encodingFilter</filter-name>
	    <filter-class>
				org.springframework.web.filter.CharacterEncodingFilter
			</filter-class>
	    <init-param>
	      <param-name>encoding</param-name>
	      <param-value>UTF-8</param-value>
	    </init-param>
	    <init-param>
	      <param-name>forceEncoding</param-name>
	      <param-value>true</param-value>
	    </init-param>
    </filter>
    <!-- 위에 지정한  encodingFilter이름을 모든 패턴에 적용-->
    <filter-mapping>
	    <filter-name>encodingFilter</filter-name>
	    <url-pattern>/*</url-pattern>
    </filter-mapping>
</web-app>



#DbConnectTest.java

package com.spring.database.test;

import java.sql.Connection;
import java.sql.DriverManager;

import org.junit.Test;

public class DbConnectTest {
	private String driver = "com.mysql.cj.jdbc.Driver";
	private String url = "jdbc:mysql://localhost:3306/spring?serverTimezone=Asia/Seoul";
		//8버전 커넥터에서만 서버시간과 장소를알려줘야함
	private String uid = "root";
	private String upw = "mysql";
	
	//DB연결 테스트
	@Test
	public void connectTest() {
		Connection conn = null;
		try {
			Class.forName(driver);
			conn = DriverManager.getConnection(url, uid, upw);
			System.out.println("DB 커넥션 성공!");
			System.out.println("conn : " + conn);
			
		} catch(Exception e) {
			e.printStackTrace();
		} finally {
			try {
				conn.close();
			} catch (Exception e) {}
		}
	}
}










##############################################################################
34) JDBC 사용을 위한 bean 객체 등록 


*root-context.xml : JDBC, DB관련 빈을 등록하고 관리하는 설정파일 이용
	-히카리 커넥션 풀 빈 등록 : 배달원들 중개업소
		-id : hikariConfig
		-class위치 : 메이븐의 hikariCP 파일보고 찾아서 적어라
		-eclipse 이름완성기능 
			참고해서 커넥션 풀 빈을 등록할때 setter를 이용하여 의존성 주입 실시		


	-히카리 데이터 소스 빈 등록 : 배달원들이 쓰는 가방 중개업소. 가방 만들때 배달원 지문등록해야해서 배달원들 중개업소를 의존성지님
		-id : ds
		-class위치 : 메이븐 보고 알아서적어라
		
			
	
	-JDBC 템플릿 클래스 빈 등록 : 배달원들이 쓰는 가방 중개업소를 가지고 있으면 자동으로 배달원들도 연결되니까 그걸 총지휘해서 적재적소
				에 사용할 지휘부
		-id : jdbcTemplate
		-class 위치 : ? (메이븐의 템플릿경로보고 적어라)



*서버 잘실행되는가 hello 시간뜨는 컨텍스트 루트 접속
##############################################################################


답:


#root-context.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<!-- JDBC, DB관련 빈을 등록하고 관리하는 설정파일 -->
	<!-- 히카리 커넥션풀 빈 등록  : 이건 우리가만든 클래스가 아니라서 안에서 Repository service로 자동빈등록
		불가하니까 직접 빈등록해줘야함-->
	<bean id = "hikariConfig" class = "com.zaxxer.hikari.HikariConfig">
		<property name = "driverClassName" value = "com.mysql.cj.jdbc.Driver" />
		<property name = "jdbcUrl" value = "jdbc:mysql://localhost:3306/spring?serverTimezone=Asia/Seoul" />
		<property name = "username" value = "root" />
		<property name = "password" value = "mysql" />
	</bean>
	
	<!--  히카리 데이터 소스 빈 등록 -->
	<bean id = "ds" class = "com.zaxxer.hikari.HikariDataSource">
		<constructor-arg ref = "hikariConfig"/> <!--  남이만든 라이브러리는 우리가직접의존성
				주입해야하니까 처음에 이런것들을 배운거다. -->
	</bean>
	
	<!--  JDBC 템플릿 클래스 빈 등록 -->
	<bean id = "jdbcTemplate" class = "org.springframework.jdbc.core.JdbcTemplate">
		<property name = "dataSource" ref = "ds"/>
	</bean>
</beans>









##############################################################################
35)점수관리프로그램과 DB 연결하기위한 구조생성 및 호환성 점검

*DB 테이블 scores 생성 및 확인
	-테이블 필드명 : 
			stu_id
				-int형(학번이라보면됨)
				-중복되지 않는 키 등록
				-자동으로 처음엔 1나오고 그담부터 1식올라가면서 부여되도록
			stu_name
				-문자형 크기 : 60
				-아무것도 입력안하면 안되게끔 설정
			kor
			eng
			math
			total
				-모두 INT 형
			average
				-최대 5자리, 소수점표현은 2자리까지 표현하도록, 100.00을 위해

	-ctrl enter해서 테이블생성
	-생성됐는지 확인 

*ScoreVO.java 클래스 생성
	-package com.spring.database.jdbc.score.model;
	-MySQL의 필드와 대응되는 필드들생성(SpringWebBasic에서의 ScoreVO는 stuId가 없다. 왜냐면 jsp에서 만들게했기때문임
					하지만 이젠 db에서 받아와야하니 stuId 필드를 만들어야 하는 것이다)
		stuId, stuName, kor, eng, math, total, average
	-getter setter 생성
	-toString() 생성
	-총점, 평균 구하는 메서드 붙여넣기
		-SpringWebBasic project -> 이거 사실 그대로 다 긁어와도 됐는데 db랑 연관지어 생각해보라고 다시만들게한거
						아래서부터는 다 복사해올거임

*package생성
	-com.spring.database.jdbc.score.controller
	-com.spring.database.jdbc.score.repository
	-com.spring.database.jdbc.score.service

*SpringWebBasic에 있는 ScoreController 및 DAO, service 관련 인터페이스 및 클래스 복사후 붙여넣기
	-문제있는건 경로문제들이니 그거 import 에러 고쳐주어라

*SpringWebBasic의 jsp파일 가져오기
	-views아래의 score 폴더 자체 복사
		-이러면 나중에 서버 실행해서 찾아가려하면 context root가 /web으로 jsp form이나 a href에 입력되어있을테니
			그걸 /database 로 바꾸어줘야한다.
			-이런문제때문에 c를 이용해서 컨텍스트 루트를 매핑해주는게 좋다

*http://localhost:8080/database/score/register 입력하면 이름등 입력하는 로직 나오는지 확인

*DAO 에서 DB대용으로 썼던 리스트  삭제, method 리턴은 null로 두고 매개변수로 오는 list 없애고 등 다 list 관련된거 없애라
	-실제 DB를 쓸거니까!
	-반환값은 쓰이는것도 있으니 쓸모를 잘생각해서 나두어라


##############################################################################


답:

#MySQL

SELECT NOW();

-- 데이터베이스 스키마 생성
CREATE DATABASE spring;

-- 점수 테이블 생성
CREATE TABLE scores (
	stu_id INT PRIMARY KEY AUTO_INCREMENT,
    stu_name VARCHAR(60) NOT NULL,
    kor INT,
    eng INT,
    math INT,
    total INT,
    average FLOAT(5, 2) -- 다섯자리수까지, 소수점표현은 두번째자리까지 최대수 -> 100.00 5자리에 소수점 2개 99.99면 4자리에 2 
);

SELECT * FROM scores;


#ScoreVO

package com.spring.database.jdbc.score.model;

public class ScoreVO {
/*
 -- 점수 테이블 생성 : DB에 이렇게 작성하면됨 : 이름규칙도 java에서는 카멜인데 db에서는 _를 씀 그래도 다르게설정
CREATE TABLE scores (
	stu_id INT PRIMARY KEY AUTO_INCREMENT,
    stu_name VARCHAR(60) NOT NULL,
    kor INT,
    eng INT,
    math INT,
    total INT,
    average FLOAT(5, 2) -- 다섯자리수까지, 소수점표현은 두번째자리까지 최대수 -> 100.00 5자리에 소수점 2개 99.99면 4자리에 2 
);
 */
	
	private Integer stuId;
	private String stuName;
	private Integer kor;
	private Integer eng;
	private Integer math;
	private Integer total;
	private Double average;
	
	//총점 평균을 구하는 메서드
	public void calcData() {
		this.total = this.kor + this.eng + this.math;
		this.average = Math.round((this.total / 3.0) * 100) / 100.0;
		
	}
	
	
	public Integer getStuId() {
		return stuId;
	}
	public void setStuId(Integer stuId) {
		this.stuId = stuId;
	}
	public String getStuName() {
		return stuName;
	}
	public void setStuName(String stuName) {
		this.stuName = stuName;
	}
	public Integer getKor() {
		return kor;
	}
	public void setKor(Integer kor) {
		this.kor = kor;
	}
	public Integer getEng() {
		return eng;
	}
	public void setEng(Integer eng) {
		this.eng = eng;
	}
	public Integer getMath() {
		return math;
	}
	public void setMath(Integer math) {
		this.math = math;
	}
	public Integer getTotal() {
		return total;
	}
	public void setTotal(Integer total) {
		this.total = total;
	}
	public Double getAverage() {
		return average;
	}
	public void setAverage(Double average) {
		this.average = average;
	}
	
	
	@Override
	public String toString() {
		return "ScoreVO [stuId=" + stuId + ", stuName=" + stuName + ", kor=" + kor + ", eng=" + eng + ", math=" + math
				+ ", total=" + total + ", average=" + average + "]";
	}
	
	
	
}


#수많은 DAO와 Service,Controller의 인터페이스 혹은 클래스 답은 아래 문제에 적어놓을게










##############################################################################
36) 전통방식의 JDBC와 Spring-JDBC의 차이

1) 전통방식의 JDBC로 insertScore() 처리하기
-넘어온 scores의 파라미터를 모두 확인할수있도록 insertScore 첫라인에(함수 블록에서 제일위에)
	System.out.println("Repository param: " + scores); 추가
-conn, pstmt 필드생성 후 try catch에서 객체 참조
-try 문 위에서 sql 구문 만들어서 sql 필드 만들어 저장
	-값은 ?이용하고 try구문에서 pstmt만들어지면 그때 scores를 이용해서 집어넣어라
	-자원해제까지 해라 conn, pstmt

-그후 웹브라우저에서 정보넣어서 db에 등록되는지 확인해라

2) spring-jdbc로 insertScore() 간편하게 처리하기
-빈등록한 객체중 필요한놈을 데려와라.그 데려온놈을 집어넣을 필드 template를 만들어라
						- 타입은 알아서 찾아보고 적어라
-sql문 적고(붙여넣기하던지 알아서하고) 그것과 위 빈객체를 이용해서 insertScore()가 실행되도록 해라
-웹브라우저에서 등록하고 db에서도 등록됐는지 확인하라


3)selectAllScores()가 전통적방식 JDBC로 처리되도록 해봐라
	-중간에 필요없는건 없애라, jsp(varStatus)나 Controller나 등등
		-학번은 db에서 이제 받아올거니까!
	-링크클릭해서 잘 작동하는지 확인해라

4)insert, delete, update 3가지 구문중 하나와 ?에 대응되는 값들을 받아서 db와 연결을 진행하는 빈객체의 특정
	메소드를 이용하여(2번에서 만든 template 필드에 참조된 객체의 메소드) deleteScore()가 정상작동하도록 만들어라
	-String sql = "DELETE FORM scores WHERE stu_id = ?";

5)전통적인 방식으로 개별조회기능(selectOne())메서드가 잘 수행되도록 처리하라


##############################################################################


답:

#IScoreDAO


package com.spring.database.jdbc.score.repository;

import java.util.List;

import com.spring.database.jdbc.score.model.ScoreVO;

public interface IScoreDAO {
	//점수 등록 기능
	void insertScore(ScoreVO scores);
	
	//점수 전체 조회 기능
	List<ScoreVO> selectAllScores();
	
	//점수 삭제기능
	void deleteScore(int stuNum);
	
	ScoreVO selectOneScore(int stuNum);
}









#ScoreDAO


package com.spring.database.jdbc.score.repository;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import com.spring.database.jdbc.score.model.ScoreVO;
@Repository
public class ScoreDAO implements IScoreDAO {
	
	//#전통적 방식의 JDBC
	private String driver = "com.mysql.cj.jdbc.Driver";
	private String url = "jdbc:mysql://localhost:3306/spring?serverTimezone=Asia/Seoul";
		//8버전 커넥터에서만 서버시간과 장소를알려줘야함
	private String uid = "root";
	private String upw = "mysql";
	
	/*
	 * 	
	@Override
	public void insertScore(ScoreVO scores) {
		// TODO Auto-generated method stub
		System.out.println("Repository param: " + scores);
		Connection conn = null;
		PreparedStatement pstmt = null;
		String sql = "INSERT INTO scores "
				+ "(stu_name, kor, eng, math, total, average) "
				+ "VALUES (?, ?, ?, ?, ?, ?)";
		
		try {
			Class.forName(driver);
			conn = DriverManager.getConnection(url, uid, upw);
			pstmt = conn.prepareStatement(sql);
			
			pstmt.setString(1, scores.getStuName());
			pstmt.setInt(2,  scores.getKor());
			pstmt.setInt(3,  scores.getEng());
			pstmt.setInt(4,  scores.getMath());
			pstmt.setInt(5,  scores.getTotal());
			pstmt.setDouble(6,  scores.getAverage());
			
			pstmt.executeUpdate();
			System.out.println("점수 등록 성공!");
			
			
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			try {
				conn.close();
				pstmt.close();
			} catch (Exception e) {}
		}
	}
	*/
	
	//#Spring-JDBC 방식의 처리 : JdbcTemplate 사용!
	@Autowired
	private JdbcTemplate template; // 이거는 빈등록직접했다. 그래서 자동스캔됨
	
	
	@Override
	public void insertScore(ScoreVO scores) {
		// TODO Auto-generated method stub
		String sql = "INSERT INTO scores "
				+ "(stu_name, kor, eng, math, total, average) "
				+ "VALUES (?, ?, ?, ?, ?, ?)";
		template.update(sql, scores.getStuName(), scores.getKor(), 
				scores.getEng(), scores.getMath(), scores.getTotal(),
				scores.getAverage());
		
		System.out.println("점수 등록 성공!");
	}
	
	@Override
	public List<ScoreVO> selectAllScores() {
		// TODO Auto-generated method stub
		List<ScoreVO> list = new ArrayList<>();
		Connection conn = null;
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		
		String sql = "SELECT * FROM scores";
		
		try {
			Class.forName(driver);
			conn = DriverManager.getConnection(url, uid, upw);
			pstmt = conn.prepareStatement(sql);
			rs = pstmt.executeQuery();
			
			while (rs.next()) {
				ScoreVO vo = new ScoreVO();
				vo.setStuId(rs.getInt("stu_id"));
				vo.setStuName(rs.getString("stu_name"));
				vo.setKor(rs.getInt("kor"));
				vo.setEng(rs.getInt("eng"));
				vo.setMath(rs.getInt("math"));
				vo.setTotal(rs.getInt("total"));
				vo.setAverage(rs.getDouble("average"));
				
				
				list.add(vo);
			}
		} catch (Exception e) {
			// TODO: handle exception
		} finally {
			try {
				conn.close();
				pstmt.close();
				rs.close();
			} catch (Exception e2) {
				// TODO: handle exception
			}
		}
		
		return list;
	}

	@Override
	public void deleteScore(int stuNum) {
		// TODO Auto-generated method stub
		String sql = "DELETE FROM scores WHERE stu_id=?";
		template.update(sql, stuNum);
		System.out.println("삭제성공!");
	}

	public ScoreVO selectOneScore(int stuNum) {
		Connection conn = null;
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		
		String sql = "SELECT * FROM scores WHERE stu_id = ?";
		
		
		ScoreVO vo = new ScoreVO();
		try {
			Class.forName(driver);
			conn = DriverManager.getConnection(url, uid, upw);
			pstmt = conn.prepareStatement(sql);
			pstmt.setInt(1, stuNum);
			rs = pstmt.executeQuery();
			
			if (rs.next()) {
				vo.setStuId(rs.getInt("stu_id"));
				vo.setStuName(rs.getString("stu_name"));
				vo.setKor(rs.getInt("kor"));
				vo.setEng(rs.getInt("eng"));
				vo.setMath(rs.getInt("math"));
				vo.setTotal(rs.getInt("total"));
				vo.setAverage(rs.getDouble("average"));
			}
			
		} catch (Exception e) {
			// TODO: handle exception
		} finally {
			try {
				conn.close();
				pstmt.close();
				rs.close();
			} catch (Exception e2) {
				// TODO: handle exception
			}
		}
		return vo;
	}
}





#IScoreService

package com.spring.database.jdbc.score.service;

import java.util.List;

import com.spring.database.jdbc.score.model.ScoreVO;

public interface IScoreService {
	//점수 등록 기능
	void insertScore(ScoreVO scores);
	
	//점수 전체 조회 기능
	List<ScoreVO> selectAllScores();
	
	//점수 삭제기능
	void deleteScore(int stuNum);
	
	ScoreVO selectOneScore(int stuNum);
	
}




#ScoreService



package com.spring.database.jdbc.score.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.spring.database.jdbc.score.model.ScoreVO;
import com.spring.database.jdbc.score.repository.IScoreDAO;


@Service
public class ScoreService implements IScoreService {

	@Autowired
	private IScoreDAO dao;
	
	@Override
	public void insertScore(ScoreVO scores) {
		// TODO Auto-generated method stub
		scores.calcData();
		dao.insertScore(scores);
	}

	@Override
	public List<ScoreVO> selectAllScores() {
		// TODO Auto-generated method stub
		return dao.selectAllScores();
	}

	@Override
	public void deleteScore(int stuNum) {
		// TODO Auto-generated method stub
		dao.deleteScore(stuNum);
	}
	
	public ScoreVO selectOneScore(int stuNum) {
		return dao.selectOneScore(stuNum);
	}

}




#ScoreController.java(??수정있는지 없는지 확인필요)

package com.spring.database.jdbc.score.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.spring.database.jdbc.score.model.ScoreVO;
import com.spring.database.jdbc.score.service.IScoreService;

@Controller
@RequestMapping("/score")
public class ScoreController {
	@Autowired
	private IScoreService service;
	
	//점수 등록 화면을 열어주는 처리를 하는 요청메서드
	@GetMapping("/register")
	public String register() {
		System.out.println("/score/register: GET");
		return "score/write-form";
	}
	
	//점수 등록을 처리하는 요청 메서드
	@PostMapping("/register")
	public String register(ScoreVO scores) {
		System.out.println("/score/register: POST");
		System.out.println("Controller param: " + scores);
		
		service.insertScore(scores);
		return "score/write-result";
	}
	
	//점수 전체 조회를 처리하는 요청 메서드
	@GetMapping("/list")
	public void list(Model model) {
		System.out.println("/score/list: GET");
		List<ScoreVO> list = service.selectAllScores();
		model.addAttribute("sList", list);
		
	}
	
	//점수 삭제 요청 처리 메서드
	@GetMapping("/delete")
	public String delete(@RequestParam("stuNum") int stuNum, RedirectAttributes ra) {
//		List<ScoreVO> list = service.selectAllScores();
		service.deleteScore(stuNum);
		ra.addFlashAttribute("message", "delSuccess");
		return "redirect:/score/list";
	}
	
	//점수 개별 조회 화면 열람요청 메서드
	@GetMapping("/search")
	public void search() {
		System.out.println("/score/search: GET");
		
	}
	
	@PostMapping("/selectOne")
	public String selectOne(String stuNum, Model model, RedirectAttributes ra) {
		
		/*
		try {
			ScoreVO stu = service.selectOneScore(Integer.parseInt(stuNum));			
			model.addAttribute("stu", stu);
			return "/score/select-result";
		} catch(NumberFormatException e) {
			ra.addFlashAttribute("message", "숫자로만 입력하세요!");
			return "redirect:/score/search"; 
		} catch(IndexOutOfBoundsException e) {
			ra.addFlashAttribute("message", "학번정보가 없습니다.");
			return "redirect:/score/search";
		} 
		*/
		List<ScoreVO> list = service.selectAllScores();
		
		try {
			int n = Integer.parseInt(stuNum);
			if (n > list.size()) {
				ra.addFlashAttribute("message", "학번정보가 없습니다.");
				return "redirect:/score/search";
			}
			
			ScoreVO stu = service.selectOneScore(n);			
			model.addAttribute("stu", stu);
			return "score/select-result";
		} catch(NumberFormatException e) {
			ra.addFlashAttribute("message", "숫자로만 입력하세요!");
			return "redirect:/score/search"; 
		} 
	}
}


















































































































































21.02.15.9회차
===============================================================================
*익명클래스, 람다식(람다 간편식), select구문 spring-jdbc형태로 변경하기(score, board)
===============================================================================











































































































































##############################################################################
37)익명클래스, 람다


1)AnonymousTest.java 만들어서(MainClass역할) Car인터페이스를 구현한 식별자 클래스를 만들지않고
익명클래스, 람다식으로 ferrari, sonata, tucson을 만들어서 run()메소드를 실행시킴으로 ~~가 팍팍 달립니다 등등 을 출력해라


com.spring.database.test에 Car interface 생성
	-클래스를 만들어서 구현(일반적인 방식)
	-익명클래스로 interface 구현
	-람다로 interface 구현
package com.spring.database.test;

public interface Car {
	void run();
}







2)더하는 기능을가진 인터페이스 Calculator를 만들고 해당하는놈을 익명클래스, 람다식, 간편람다식으로 n1, n2의 값을 더해봐라
	-람다식에서 매개변수명은 꼭 인터페이스에 있는 매개변수명과 같을 필요가 없다는 것도 인지해라
	-sharp 계산기, casio계산기, shaomi계산기

com.spring.database.test에 Calculator interface 생성
package com.spring.database.test;

public interface Calculator {
	int add(int n1, int n2);
}

##############################################################################

답:


package com.spring.database.test;

public class AnonymousTest {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Car s = new Sonata();
		s.run();
		
		Car ferrari = new Car() {
			@Override
			public void run() {
				// TODO Auto-generated method stub
				System.out.println("페라리가 쌩쌩 달립니다.");
			}
		};
		
		ferrari.run();
		
		new Car() {
			@Override
			public void run() {
				// TODO Auto-generated method stub
				System.out.println("말리부가 팍팍달립니다.");
			}
		}.run();
		
		//lambda식 적용 : 인터페이스 안에 추상메서드가 단 하나일 경우만 가능!
		Car tucson = () -> {System.out.println("투싼이 달립니다.");};
		tucson.run();
		
		
		//////////////////////////////
		
		
		//계산기 인터페이스와 람다식
		Calculator sharp = new Calculator() {
			
			@Override
			public int add(int n1, int n2) {
				// TODO Auto-generated method stub
				System.out.println("샤프 계산기의 덧셈!");
				return n1 + n2;
			}
		};
		
		System.out.println("=========================");
		System.out.println(sharp.add(10, 15));
		
		Calculator casio = (x, y) -> {
			System.out.println("카시오 계산기의 덧셈!");
			return x + y;
		};
		
		System.out.println(casio.add(100, 200));
		
		// 위치럼 람다조건인상황에서 리턴말고 내부 메서드에서 할게 추가로 없을때 이렇게까지도 줄일수 있음
		/*
		Calculator shaomi = (x, y) -> {
			return x + y;
		};
		*/
		Calculator shaomi = (x, y) -> x + y;
		
		System.out.println("샤오미 결과: " + shaomi.add(30,  50));
	}

}



































##############################################################################
38)SelectAllScores spring-jdbc형태로 변경
-일반클래스, 익명클래스, 람다클래스 3가지 방식으로 template.query(sql, new RowMapper<ScoreVO>()); 써보기

com.spring.database.jdbc.score.commons
ScoreMapper
	-일반클래스로구현
		-public ScoreVO mapRow(ResultSet rs, int rowNum) throws SQLException {
	-익명클래스로구현
	-람다로 구현


/database/score/list 되는지 확인

##############################################################################

답: 39번답에 함께 있다. repository(익명,람다), commons(일반클래스)


































##############################################################################
39) 가변인수 또는 Object배열로 ? 채우기, single row뽑기(list형태가아니라), 내부클래스

SelectOneScore string-jdbc형태로 변경

1-1)아래 두가지방법으로 ?를 채운 뒤 ScoreMapper에서 정의한 제너릭타입을 제너릭으로갖는 list 반환받기
	-일반클래스 ScoreMapper()를 import 해서 사용
		-package com.spring.database.jdbc.score.commons;
		-import의 귀찮음을 느껴라
	-multi row 반환

1-2)지금 SelectOneScore의 반환값은 list가 아니니까 query값이 ScoreVO가 되어야함. 이게 되도록 해바라
	-일반클래스 ScoreMapper()를 import 해서 사용
	-single row 반환

2) 아래방식으로 위의 1-2를 다해보고 내부클래스할때는 import된 ScoreMapper를 주석하고 풀어라
일반클래스 : 클래스 파일 다시 만들어야되서 귀찬(import 등)
익명클래스 : 코드가 겹침
	-RowMapper를 한번만쓰면 익명클래스가 편한데 지금 DAO에서는 계속 사용해야해서 코드가 겹치고 더 귀찮아짐
	-그래서 일반클래스를 만들자니 파일도 새로만들어야하고 또 DAO에서 쓸때는 import해야하고 귀찮으니 내부에 클래스만들자! 라는 의미
내부클래스 : 클래스 소스만 적어놓으면 편하게 계속 사용가능
	-어차피 DAO에서밖에 안쓸 클래스이니까

##############################################################################

답:

<model>
#ScoreVO


package com.spring.database.jdbc.score.model;

public class ScoreVO {
/*
 -- 점수 테이블 생성 : DB에 이렇게 작성하면됨 : 이름규칙도 java에서는 카멜인데 db에서는 _를 씀 그래도 다르게설정
CREATE TABLE scores (
	stu_id INT PRIMARY KEY AUTO_INCREMENT,
    stu_name VARCHAR(60) NOT NULL,
    kor INT,
    eng INT,
    math INT,
    total INT,
    average FLOAT(5, 2) -- 다섯자리수까지, 소수점표현은 두번째자리까지 최대수 -> 100.00 5자리에 소수점 2개 99.99면 4자리에 2 
);
 */
	
	private Integer stuId;
	private String stuName;
	private Integer kor;
	private Integer eng;
	private Integer math;
	private Integer total;
	private Double average;
	
	//총점 평균을 구하는 메서드
	public void calcData() {
		this.total = this.kor + this.eng + this.math;
		this.average = Math.round((this.total / 3.0) * 100) / 100.0;
		
	}
	
	
	public Integer getStuId() {
		return stuId;
	}
	public void setStuId(Integer stuId) {
		this.stuId = stuId;
	}
	public String getStuName() {
		return stuName;
	}
	public void setStuName(String stuName) {
		this.stuName = stuName;
	}
	public Integer getKor() {
		return kor;
	}
	public void setKor(Integer kor) {
		this.kor = kor;
	}
	public Integer getEng() {
		return eng;
	}
	public void setEng(Integer eng) {
		this.eng = eng;
	}
	public Integer getMath() {
		return math;
	}
	public void setMath(Integer math) {
		this.math = math;
	}
	public Integer getTotal() {
		return total;
	}
	public void setTotal(Integer total) {
		this.total = total;
	}
	public Double getAverage() {
		return average;
	}
	public void setAverage(Double average) {
		this.average = average;
	}
	
	
	@Override
	public String toString() {
		return "ScoreVO [stuId=" + stuId + ", stuName=" + stuName + ", kor=" + kor + ", eng=" + eng + ", math=" + math
				+ ", total=" + total + ", average=" + average + "]";
	}
	
	
	
}


------------------------------------------------
<controller>
#ScoreController

package com.spring.database.jdbc.score.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.spring.database.jdbc.score.model.ScoreVO;
import com.spring.database.jdbc.score.service.IScoreService;

@Controller
@RequestMapping("/score")
public class ScoreController {
	@Autowired
	private IScoreService service;
	
	//점수 등록 화면을 열어주는 처리를 하는 요청메서드
	@GetMapping("/register")
	public String register() {
		System.out.println("/score/register: GET");
		return "score/write-form";
	}
	
	//점수 등록을 처리하는 요청 메서드
	@PostMapping("/register")
	public String register(ScoreVO scores) {
		System.out.println("/score/register: POST");
		System.out.println("Controller param: " + scores);
		
		service.insertScore(scores);
		return "score/write-result";
	}
	
	//점수 전체 조회를 처리하는 요청 메서드
	@GetMapping("/list")
	public void list(Model model) {
		System.out.println("/score/list: GET");
		List<ScoreVO> list = service.selectAllScores();
		model.addAttribute("sList", list);
		
	}
	
	//점수 삭제 요청 처리 메서드
	@GetMapping("/delete")
	public String delete(@RequestParam("stuNum") int stuNum, RedirectAttributes ra) {
//		List<ScoreVO> list = service.selectAllScores();
		service.deleteScore(stuNum);
		ra.addFlashAttribute("message", "delSuccess");
		return "redirect:/score/list";
	}
	
	//점수 개별 조회 화면 열람요청 메서드
	@GetMapping("/search")
	public void search() {
		System.out.println("/score/search: GET");
		
	}
	
	@PostMapping("/selectOne")
	public String selectOne(String stuNum, Model model, RedirectAttributes ra) {
		
		/*
		try {
			ScoreVO stu = service.selectOneScore(Integer.parseInt(stuNum));			
			model.addAttribute("stu", stu);
			return "/score/select-result";
		} catch(NumberFormatException e) {
			ra.addFlashAttribute("message", "숫자로만 입력하세요!");
			return "redirect:/score/search"; 
		} catch(IndexOutOfBoundsException e) {
			ra.addFlashAttribute("message", "학번정보가 없습니다.");
			return "redirect:/score/search";
		} 
		*/
		List<ScoreVO> list = service.selectAllScores();
		
		try {
			int n = Integer.parseInt(stuNum);
			if (n > list.size()) {
				ra.addFlashAttribute("message", "학번정보가 없습니다.");
				return "redirect:/score/search";
			}
			
			ScoreVO stu = service.selectOneScore(n);			
			model.addAttribute("stu", stu);
			return "score/select-result";
		} catch(NumberFormatException e) {
			ra.addFlashAttribute("message", "숫자로만 입력하세요!");
			return "redirect:/score/search"; 
		} 
	}
}



------------------------------------------------
<service>
#IScoreService
package com.spring.database.jdbc.score.service;

import java.util.List;

import com.spring.database.jdbc.score.model.ScoreVO;

public interface IScoreService {
	//점수 등록 기능
	void insertScore(ScoreVO scores);
	
	//점수 전체 조회 기능
	List<ScoreVO> selectAllScores();
	
	//점수 삭제기능
	void deleteScore(int stuNum);
	
	ScoreVO selectOneScore(int stuNum);
	
}




#ScoreService



package com.spring.database.jdbc.score.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.spring.database.jdbc.score.model.ScoreVO;
import com.spring.database.jdbc.score.repository.IScoreDAO;


@Service
public class ScoreService implements IScoreService {

	@Autowired
	private IScoreDAO dao;
	
	@Override
	public void insertScore(ScoreVO scores) {
		// TODO Auto-generated method stub
		scores.calcData();
		dao.insertScore(scores);
	}

	
	@Override
	public List<ScoreVO> selectAllScores() {
		// TODO Auto-generated method stub
		return dao.selectAllScores();
	}
	
	

	@Override
	public void deleteScore(int stuNum) {
		// TODO Auto-generated method stub
		dao.deleteScore(stuNum);
	}
	
	public ScoreVO selectOneScore(int stuNum) {
		return dao.selectOneScore(stuNum);
	}

}


------------------------------------------------
<repositoty>
#IScoreDAO
package com.spring.database.jdbc.score.repository;

import java.util.List;

import com.spring.database.jdbc.score.model.ScoreVO;

public interface IScoreDAO {
	//점수 등록 기능
	void insertScore(ScoreVO scores);
	
	//점수 전체 조회 기능
	List<ScoreVO> selectAllScores();
	
	//점수 삭제기능
	void deleteScore(int stuNum);
	
	ScoreVO selectOneScore(int stuNum);
}




#ScoreDAO


package com.spring.database.jdbc.score.repository;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

//import com.spring.database.jdbc.score.commons.ScoreMapper;
import com.spring.database.jdbc.score.model.ScoreVO;
@Repository
public class ScoreDAO implements IScoreDAO {
	class ScoreMapper implements RowMapper<ScoreVO>{
		@Override
		public ScoreVO mapRow(ResultSet rs, int rowNum) throws SQLException {
			// TODO Auto-generated method stub
			ScoreVO score = new ScoreVO();
			score.setStuId(rs.getInt("stu_id"));
			score.setStuName(rs.getString("stu_name"));
			score.setKor(rs.getInt("kor"));
			score.setEng(rs.getInt("eng"));
			score.setMath(rs.getInt("math"));
			score.setTotal(rs.getInt("total"));
			score.setAverage(rs.getDouble("average"));
			
			return score;
		}
	}

	
	/*
	//#전통적 방식의 JDBC
	private String driver = "com.mysql.cj.jdbc.Driver";
	private String url = "jdbc:mysql://localhost:3306/spring?serverTimezone=Asia/Seoul";
		//8버전 커넥터에서만 서버시간과 장소를알려줘야함
	private String uid = "root";
	private String upw = "mysql";
	 */
	
	/*
	 * 	
	@Override
	public void insertScore(ScoreVO scores) {
		// TODO Auto-generated method stub
		System.out.println("Repository param: " + scores);
		Connection conn = null;
		PreparedStatement pstmt = null;
		String sql = "INSERT INTO scores "
				+ "(stu_name, kor, eng, math, total, average) "
				+ "VALUES (?, ?, ?, ?, ?, ?)";
		
		try {
			Class.forName(driver);
			conn = DriverManager.getConnection(url, uid, upw);
			pstmt = conn.prepareStatement(sql);
			
			pstmt.setString(1, scores.getStuName());
			pstmt.setInt(2,  scores.getKor());
			pstmt.setInt(3,  scores.getEng());
			pstmt.setInt(4,  scores.getMath());
			pstmt.setInt(5,  scores.getTotal());
			pstmt.setDouble(6,  scores.getAverage());
			
			pstmt.executeUpdate();
			System.out.println("점수 등록 성공!");
			
			
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			try {
				conn.close();
				pstmt.close();
			} catch (Exception e) {}
		}
	}
	*/
	
	//#Spring-JDBC 방식의 처리 : JdbcTemplate 사용!
	@Autowired
	private JdbcTemplate template; // 이거는 빈등록직접했다. 그래서 자동스캔됨
	
	
	@Override
	public void insertScore(ScoreVO scores) {
		// TODO Auto-generated method stub
		String sql = "INSERT INTO scores "
				+ "(stu_name, kor, eng, math, total, average) "
				+ "VALUES (?, ?, ?, ?, ?, ?)";
		template.update(sql, scores.getStuName(), scores.getKor(), 
				scores.getEng(), scores.getMath(), scores.getTotal(),
				scores.getAverage());
		
		System.out.println("점수 등록 성공!");
	}
	
	/*
	@Override
	public List<ScoreVO> selectAllScores() {
		// TODO Auto-generated method stub
		List<ScoreVO> list = new ArrayList<>();
		Connection conn = null;
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		
		String sql = "SELECT * FROM scores";
		
		try {
			Class.forName(driver);
			conn = DriverManager.getConnection(url, uid, upw);
			pstmt = conn.prepareStatement(sql);
			rs = pstmt.executeQuery();
			
			while (rs.next()) {
				ScoreVO vo = new ScoreVO();
				vo.setStuId(rs.getInt("stu_id"));
				vo.setStuName(rs.getString("stu_name"));
				vo.setKor(rs.getInt("kor"));
				vo.setEng(rs.getInt("eng"));
				vo.setMath(rs.getInt("math"));
				vo.setTotal(rs.getInt("total"));
				vo.setAverage(rs.getDouble("average"));
				
				
				list.add(vo);
			}
		} catch (Exception e) {
			// TODO: handle exception
		} finally {
			try {
				conn.close();
				pstmt.close();
				rs.close();
			} catch (Exception e2) {
				// TODO: handle exception
			}
		}
		
		return list;
	}
	*/
	/*
	@Override
	public List<ScoreVO> selectAllScores() {
		// TODO Auto-generated method stub
		String sql = "SELECT * FROM scores";
		
		//인터페이스를 구현한 클래스를 만들어서 template.query 사용하는법
//		List<ScoreVO> list = template.query(sql, new ScoreMapper());
		
		//익명클래스
		
		List<ScoreVO> list = template.query(sql, new RowMapper<ScoreVO>() {
			@Override
			public ScoreVO mapRow(ResultSet rs, int rowNum) throws SQLException {
				// TODO Auto-generated method stub
				ScoreVO score = new ScoreVO();
				score.setStuId(rs.getInt("stu_id"));
				score.setStuName(rs.getString("stu_name"));
				score.setKor(rs.getInt("kor"));
				score.setEng(rs.getInt("eng"));
				score.setMath(rs.getInt("math"));
				score.setTotal(rs.getInt("total"));
				score.setAverage(rs.getDouble("average"));
				
				return score;
			}
		});
		
		

		return list;
	}
	*/

	
	//람다를 이용한 익명클래스
	@Override
	public List<ScoreVO> selectAllScores() {
		String sql = "SELECT * FROM scores";
		
		return template.query(sql, (rs, rowNum) -> {
			{
				ScoreVO score = new ScoreVO();
				score.setStuId(rs.getInt("stu_id"));
				score.setStuName(rs.getString("stu_name"));
				score.setKor(rs.getInt("kor"));
				score.setEng(rs.getInt("eng"));
				score.setMath(rs.getInt("math"));
				score.setTotal(rs.getInt("total"));
				score.setAverage(rs.getDouble("average"));
				
				return score;
			}
		});
	}
	
	
	@Override
	public void deleteScore(int stuNum) {
		// TODO Auto-generated method stub
		String sql = "DELETE FROM scores WHERE stu_id=?";
		template.update(sql, stuNum);
		System.out.println("삭제성공!");
	}

	/*
	public ScoreVO selectOneScore(int stuNum) {
		Connection conn = null;
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		
		String sql = "SELECT * FROM scores WHERE stu_id = ?";
		
		
		ScoreVO vo = new ScoreVO();
		try {
			Class.forName(driver);
			conn = DriverManager.getConnection(url, uid, upw);
			pstmt = conn.prepareStatement(sql);
			pstmt.setInt(1, stuNum);
			rs = pstmt.executeQuery();
			
			if (rs.next()) {
				vo.setStuId(rs.getInt("stu_id"));
				vo.setStuName(rs.getString("stu_name"));
				vo.setKor(rs.getInt("kor"));
				vo.setEng(rs.getInt("eng"));
				vo.setMath(rs.getInt("math"));
				vo.setTotal(rs.getInt("total"));
				vo.setAverage(rs.getDouble("average"));
			}
			
		} catch (Exception e) {
			// TODO: handle exception
		} finally {
			try {
				conn.close();
				pstmt.close();
				rs.close();
			} catch (Exception e2) {
				// TODO: handle exception
			}
		}
		return vo;
	} */
	
	@Override
	public ScoreVO selectOneScore(int stuNum) {
		// TODO Auto-generated method stub
		String sql = "SELECT * FROM scores WHERE stu_id = ?";
		
		
		//아래 두가지방법으로 ?를 채운 뒤 ScoreMapper에서 정의한 제너릭타입을 제너릭으로갖는 list 반환받기
		//1)sql, 오브젝트배열, RowMapper구현한 클래스 형식
		//2)sql, RowMapper구현한 클래스, 가변인수 형식
//		template.query(sql,  new Object[] {stuNum}, new ScoreMapper());
//		template.query(sql, new ScoreMapper(), stuNum);
		
		//queryForObject는 Single row를 리턴할때 사용
				//조회결과가 한줄인걸 single row라함
		//query는 multi row를 리턴할때 사용
				//조회결과가 두개 이상인경우 multi row라하고 이때 list에 담는거임
		template.queryForObject(sql, new ScoreMapper(), stuNum);
				//RowMapper를 구현한 클래스 ScoreMapper의 제너릭이 queryForObject의 반환값을 결정함
		return null;
	}
}


------------------------------------------------
<commons>
#ScoreMapper


package com.spring.database.jdbc.score.commons;

import java.sql.ResultSet;
import java.sql.SQLException;

import org.springframework.jdbc.core.RowMapper;

import com.spring.database.jdbc.score.model.ScoreVO;

//Jdbc Template에서 ResultSet 사용을 편하게 하기위한 클래스 생성
public class ScoreMapper implements RowMapper<ScoreVO>{
	
	@Override
	public ScoreVO mapRow(ResultSet rs, int rowNum) throws SQLException {
		// TODO Auto-generated method stub
		ScoreVO score = new ScoreVO();
		score.setStuId(rs.getInt("stu_id"));
		score.setStuName(rs.getString("stu_name"));
		score.setKor(rs.getInt("kor"));
		score.setEng(rs.getInt("eng"));
		score.setMath(rs.getInt("math"));
		score.setTotal(rs.getInt("total"));
		score.setAverage(rs.getDouble("average"));
		
		return score;
	}
}


------------------------------------------------
<views/score>

#write-form.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>시험 점수 등록</h2>
<form method = "post">
	<p>
		# 이름 : <input type = "text" name = "stuName"><br>
		# 국어 : <input type = "text" name = "kor"><br>
		# 영어 : <input type = "text" name = "eng"><br>
		# 수학 : <input type = "text" name = "math"><br>
		<input type = "submit" value = "확인">
	</p>
</form>

</body>
</html>



#write-result.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	<h2>점수 등록 성공!</h2>
	<a href = "/database/score/register">다른 점수 등록하기</a>
	<a href = "/database/score/list">점수 전체 조회</a>
	<a href = "/database/score/search">점수 개별 조회</a>

</body>
</html>




#list.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>    
    
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>학생들의 전체  성적 조회</h2>
<c:forEach var = "stu" items = "${sList}">
	<p>
		# 학번 : ${stu.stuId}, 이름 : ${stu.stuName}, 국어 : ${stu.kor}, 영어 : ${stu.eng},
		 수학 : ${stu.math}, 총점 : ${stu.total}, 평균 : ${stu.average}
		&nbsp;
		<a href = "/database/score/delete?stuNum=${stu.stuId}">[삭제]</a>	
	</p>
</c:forEach>

<a href = "/database/score/register">다른 점수 등록하기</a> 
<a href = "/database/score/list">점수 전체 조회</a>
<a href = "/database/score/search">점수 개별 조회</a>

<script type = "text/javascript">
	const msg = "${message}";
	console.log(msg);
	if (msg === "delSuccess") {
		alert("점수 삭제 완료!");
	}
</script>


</body>
</html>


#search.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>개별 점수 조회</h2>
<form action = "/database/score/selectOne" method = "post">
	<p>
		#조회할 학번 : <input type = "text" name = "stuNum" size = "5">
				   <input type = "submit" value = "조회">
	</p>
</form>

<p style = "color:red;">
	${message}
</p>

</body>
</html>






#select-result.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>${stu.stuName}학생 성적 정보 조회</h2>

<p>	
	# 국어 : ${stu.kor} <br>
	# 영어 : ${stu.eng} <br>
	# 수학 : ${stu.math} <br>
	# 총점 : ${stu.total} <br>
	# 평균 : ${stu.average} 
</p>

<a href = "/database/score/register">다른 점수 등록하기</a> 
<a href = "/database/score/list">점수 전체 조회</a>
<a href = "/database/score/search">점수 개별 조회</a>

</body>
</html>










































##############################################################################
40) SpringWebBasic project의 Board(게시판만드는 앱)를 위 score처럼 DB에 연결하라

com.spring.database.jdbc.board.model
com.spring.database.jdbc.board.controller
com.spring.database.jdbc.board.repository
com.spring.database.jdbc.board.service

저 패키지에 싹다 붙여넣기 호환성점검
views의 board 폴더도 그대로 붙여넣기 후 호환성점검


1)DB에 jdbc_board table 생성(java의 BoardVO의 필드명을보고 만들면됨)하여 jdbc 프로그래밍하라
	-게시판번호에 관련된 필드명만 알려줌 : board_no
		-score할때랑 똑같은 방식으로 만들면됨
			-작성자, 제목은 아무것도 안넣으면 안되게끔하고 내용은 그냥 기본 변수형으로 하고 Type은 TEXT로 하라

	-게시판번호에 대해 BoardVO의 필드명은 boardNo로 해라

	-list.jsp에서 보여줄때 내림차순으로 보여지도록 DAO에서 sql문을 조작해라
		-7,6,5,4,3 처럼 위에서 아래로 떨어지게 해라
	-글 내용 자세히보기할때 content() 메소드에서 매개변수로 바로 @ModelAttribute하는걸 빼고 int boardNo만 받아서 해봐라
		-당연히된다. 왜냐면 article에 boardNo 필드가 있기때문
		-modify()도 마찬가지
		-추가로 DAO나 service에 매개변수가 줄어야하면 줄여라


2)검색기능 추가
	-왜 서비스에서 굳이 %를 붙이는지 이해해라
		-DAO에서 문자열에 %?% 이렇게하면 프리페어스테이트먼트가 ?에 문자열의 경우 ''를 붙이기때문에(문자열 아닌 숫자에서도
				붙이는게 맘편하다)
			MYSQL로 넘어가면 최종적으로 %'?'% 형태가된다. 우리가 바라는 것은
			'%?%'이니까 서비스에서 붙여야하는 것이다.
	-검색기능 추가하는 jsp페이지는 따로만들지 말고 list에서 바로 검색할수 있도록 하고 아래 나온것처럼 get방식으로 처리해라(이유는 없다)
											-원래 강사님이 값넘길댄 보안상 
											 post로하는거같던데 왜 get으로 했는지는
											 모르겠음
#MySQL
	-김뽀삐 3명정도 같은이름 다른내용으로 추가해라(검색을위해서)
		-박뽀삐도 넣어라 (뽀삐로 검색했을때 4명 나오는걸 보기 위해서)
	-이름이 김뽀삐와 일치하는 레코드(행)를 내림차순으로 출력한다.
		SELECT * FROM jdbc_board
		WHERE writer = '김뽀삐'
		ORDER BY board_no DESC;
		
	-이름중에 뽀삐라는게 들어가있는 레코드(행)을 내림차순으로 출력한다.
		SELECT * FROM jdbc_board
		WHERE writer LIKE '%뽀삐%'
		ORDER BY board_no DESC;

	-제목, 내용 등으로도 검색해서 연습해봐라

#IBoardService, IBoardDAO
	-List<BoardVO> getSearchList(String keyword);

#list.jsp의 </table>과 </c:if> 사이에 넣어라

	</table>

	<br>
	<form action = "<c:url value = '/board/searchList'/>">
		<input type = "text" name = "keyword" placeholder = "작성자 이름을 입력하세요">
		<input type = "submit" value = "검색">	
	</form>
</c:if>

##############################################################################

답:


<MySQL>
-- jdbc 게시판 테이블 생성

CREATE TABLE jdbc_board(
	board_no INT PRIMARY KEY AUTO_INCREMENT,
    writer VARCHAR(100) NOT NULL,
    title VARCHAR(255) NOT NULL,
    content TEXT
);

SELECT * FROM jdbc_board;

------------------------------
<model>
#BoardVO
package com.spring.database.jdbc.board.model;

public class BoardVO {
	private Integer boardNo;
	private String writer;
	private String title;
	private String content;
	
	
	
	public BoardVO() {
		// TODO Auto-generated constructor stub
	}
	
	
	

	public Integer getBoardNo() {
		return boardNo;
	}




	public void setBoardNo(Integer boardNo) {
		this.boardNo = boardNo;
	}




	public String getWriter() {
		return writer;
	}

	public void setWriter(String writer) {
		this.writer = writer;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	@Override
	public String toString() {
		return "BoardVO [writer=" + writer + ", title=" + title + ", content=" + content + "]";
	}
	
	
	

}


------------------------------
<controller>
#BoardController
package com.spring.database.jdbc.board.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import com.spring.database.jdbc.board.model.BoardVO;
import com.spring.database.jdbc.board.service.IBoardService;

@Controller
@RequestMapping("/board")
public class BoardController {
	@Autowired
	private IBoardService service;
	
	//등록
	@RequestMapping(value = "/write", method = RequestMethod.GET)
	public void write() {
		System.out.println("/board/write 요청됨 : GET");
	}
	
	@RequestMapping(value = "/write", method = RequestMethod.POST)
	public String write(BoardVO article) {
		System.out.println("/board/write 요청됨 : POST");
		service.insertArticle(article);
		return "redirect:/board/list";
	}
	
	//목록보기
	@RequestMapping(value = "/list", method = RequestMethod.GET)
	public void list(Model model) {
		List<BoardVO> articles = service.getArticles();
		model.addAttribute("articles", articles);
	}
	
	//삭제
	@RequestMapping(value = "/delete", method = RequestMethod.GET)
	public String delete(int boardNo) {
		System.out.println("/board/delete?boardNo=" + boardNo + " 요청됨 : GET");
		service.deleteArticle(boardNo);
		return "redirect:/board/list";
	}
	
	//게시글확인(상세보기)
	@RequestMapping(value = "/content", method = RequestMethod.GET)
	public void content(int boardNo, Model model) {
		System.out.println("/board/content 요청됨 : GET");
		BoardVO article = service.getContent(boardNo);
		model.addAttribute("article", article);
	}
	
	//게시글 수정
	@RequestMapping(value = "/modify", method = RequestMethod.GET)
	public void modify(int boardNo, Model model) {
		System.out.println("/board/modify 요청됨 : GET");
		BoardVO article = service.getContent(boardNo);
		model.addAttribute("article", article);
	}
	
	@RequestMapping(value = "/modify", method = RequestMethod.POST)
	public String modify(BoardVO article) {
		System.out.println("/board/modify 요청됨 : POST");
		service.modifyArticle(article);
		return "redirect:/board/content?boardNo=" + article.getBoardNo();
	}
	
	
	@RequestMapping(value = "/searchList", method = RequestMethod.GET)
	public String searchList(String keyword, Model model) {
		List<BoardVO> list = service.getSearchList(keyword);
		model.addAttribute("articles", list);
		
		return "board/list";
	}
	
}

------------------------------
<service>
#IBoardService
package com.spring.database.jdbc.board.service;

import java.util.List;

import com.spring.database.jdbc.board.model.BoardVO;

public interface IBoardService {
	//게시글 목록 가져오기
	List<BoardVO> getArticles();
	
	//게시글 등록
	void insertArticle(BoardVO article);
	
	//게시글 삭제
	void deleteArticle(int boardNo);
	
	//게시글 내용보기
	BoardVO getContent(int boardNo);
	
	//게시글 수정
	void modifyArticle(BoardVO article);
	
	//게시글 검색
	List<BoardVO> getSearchList(String keyword);
}



#BoardService
package com.spring.database.jdbc.board.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.spring.database.jdbc.board.model.BoardVO;
import com.spring.database.jdbc.board.repository.IBoardDAO;

@Service
public class BoardService implements IBoardService {
	@Autowired
	private IBoardDAO dao;
	
	@Override
	public List<BoardVO> getArticles() {
		// TODO Auto-generated method stub
		return dao.getArticles();
	}

	@Override
	public void insertArticle(BoardVO article) {
		// TODO Auto-generated method stub
		dao.insertArticle(article);
	}

	@Override
	public void deleteArticle(int boardNo) {
		// TODO Auto-generated method stub
		dao.deleteArticle(boardNo);
	}

	@Override
	public BoardVO getContent(int boardNo) {
		// TODO Auto-generated method stub
		return dao.getContent(boardNo);
	}

	@Override
	public void modifyArticle(BoardVO article) {
		// TODO Auto-generated method stub
		dao.modifyArticle(article);
	}

	@Override
	public List<BoardVO> getSearchList(String keyword) {
		// TODO Auto-generated method stub
		keyword = "%" + keyword + "%";
		return dao.getSearchList(keyword);
	}
}




------------------------------
<repository>
#IBoardDAO
package com.spring.database.jdbc.board.repository;

import java.util.List;

import com.spring.database.jdbc.board.model.BoardVO;

public interface IBoardDAO {
	//게시글 목록 가져오기
	List<BoardVO> getArticles();
	
	//게시글 등록
	void insertArticle(BoardVO article);
	
	//게시글 삭제
	void deleteArticle(int boardNo);
	
	//게시글 내용보기
	BoardVO getContent(int boardNo);
	
	//게시글 수정
	void modifyArticle(BoardVO article);
	
	//게시글 검색
	List<BoardVO> getSearchList(String keyword);
}






#BoardDAO
package com.spring.database.jdbc.board.repository;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import com.spring.database.jdbc.board.model.BoardVO;

@Repository
public class BoardDAO implements IBoardDAO {
	
	class BoardMapper implements RowMapper<BoardVO> {
		
		@Override
		public BoardVO mapRow(ResultSet rs, int rowNum) throws SQLException {
			// TODO Auto-generated method stub
			BoardVO vo = new BoardVO();
			
			vo.setBoardNo(rs.getInt("board_no"));
			vo.setWriter(rs.getString("writer"));
			vo.setTitle(rs.getString("title"));
			vo.setContent(rs.getString("content"));
			
			return vo;
		}
	}
	
	@Autowired
	private JdbcTemplate template;
	
	@Override
	public List<BoardVO> getArticles() {
		// TODO Auto-generated method stub
		String sql = "SELECT * FROM jdbc_board ORDER BY board_no DESC";

		/*
		List<BoardVO> list = template.query(sql, new RowMapper<BoardVO>() {
			@Override
			public BoardVO mapRow(ResultSet rs, int rowNum) throws SQLException {
				// TODO Auto-generated method stub
				BoardVO vo = new BoardVO();
				
				vo.setBoardNo(rs.getInt("board_no"));
				vo.setWriter(rs.getString("writer"));
				vo.setTitle(rs.getString("title"));
				vo.setContent(rs.getString("content"));
				
				return vo;
			}
		});
		*/
		
		List<BoardVO> list = template.query(sql, (rs, rowNum) -> {

				BoardVO vo = new BoardVO();
				
				vo.setBoardNo(rs.getInt("board_no"));
				vo.setWriter(rs.getString("writer"));
				vo.setTitle(rs.getString("title"));
				vo.setContent(rs.getString("content"));
				
				return vo;
		});
		
		
		return list;
	}

	@Override
	public void insertArticle(BoardVO article) {
		// TODO Auto-generated method stub
		String sql = "INSERT INTO jdbc_board "
				+ "(writer, title, content) "
				+ "VALUES (?, ?, ?)";
		
		template.update(sql, article.getWriter(), article.getTitle(), 
				article.getContent());
		
		System.out.println(article); // 로그찍기
		System.out.println("게시글 저장 완료!!");
	}

	@Override
	public void deleteArticle(int boardNo) {
		// TODO Auto-generated method stub
		String sql = "DELETE FROM jdbc_board WHERE board_no = " + boardNo;
		template.update(sql);
		System.out.println(boardNo + "번 삭제 완료!");
	}

	@Override
	public BoardVO getContent(int boardNo) {
		// TODO Auto-generated method stub
		String sql = "SELECT * FROM jdbc_board WHERE board_no = ?";
//		String sql = "SELECT * FROM jdbc_board WHERE board_no = " + boardNo;
		
		BoardVO vo = template.queryForObject(sql, new Object[] {boardNo}, new BoardMapper());
//		template.queryForObject(sql, new BoardMapper(), boardNo);
				
		return vo;
	}

	@Override
	public void modifyArticle(BoardVO article) {
		// TODO Auto-generated method stub
		String sql = "UPDATE jdbc_board "
				+ "SET writer = ?, title = ?, content = ? "
				+ "WHERE board_no = ?";
		
		template.update(sql, article.getWriter(), article.getTitle(),
								article.getContent(), article.getBoardNo());
		System.out.println(article.getBoardNo() + "번 게시글 수정 완료!");
	}

	
	@Override
	public List<BoardVO> getSearchList(String keyword) {
		// TODO Auto-generated method stub
		System.out.println(keyword);
		String sql = "SELECT * FROM jdbc_board "
				+ "WHERE writer LIKE ? "
				+ "ORDER BY board_no DESC";
		
		return template.query(sql, new BoardMapper(), keyword);
	}
}





------------------------------
<views/board>
#write.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>게시글 등록</h2>

<form method="post">

	<p>
		# 작성자: <input type="text" name="writer"><br>
		# 제목: <input type="text" name="title"><br>
		# 내용: <textarea rows="3" name="content"></textarea>
		<br>
		<input type="submit" value="등록">
	</p>
</form>
<a href = "<c:url value = '/board/list'/>">글 목록보기</a>

</body>
</html>











#list.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<c:if test = "${articles.size() <= 0}">
	<p>게시물이 존재하지 않습니다.</p>
</c:if>

<c:if test = "${articles.size() > 0}">
	<h2>게시글 목록</h2>
	<table border = "1">
	
		<tr>
			<td>번호</td>
			<td>작성자</td>
			<td>제목</td>
			<td>비고</td>
		</tr>
		
		<%-- 컨트롤러가 가져온 게시글 데이터를 반복하여 출력 --%>
		<%-- 게시물 개수가 0개일 경우 목록대신 "게시물이 존재하지 않습니다." 출력--%>
	
		
		<c:forEach var = "article" items = "${articles}" >
			<tr>
				<td>${article.boardNo}</td>
				<td>${article.writer}</td>
				<td>
					<a href = "<c:url value = '/board/content?boardNo=${article.boardNo}'/>">${article.title}</a>
				</td>
				<td>
					<a href = "<c:url value = '/board/delete?boardNo=${article.boardNo}'/>">[삭제]</a>
				</td>
			</tr>
		</c:forEach>
		
	</table>
	
	<br>
	<form action = "<c:url value = '/board/searchList'/>">
		<input type = "text" name = "keyword" placeholder = "작성자 이름을 입력하세요">
		<input type = "submit" value = "검색">	
	</form>
</c:if>



<p>
	<a href = "<c:url value = '/board/write'/>">게시글 작성하기</a>
</p>



</body>
</html>






#content.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>${article.boardNo}번 게시물 내용</h2>

<p>
	# 글번호: ${article.boardNo}<br>
	# 작성자: ${article.writer}<br>
	# 제목: ${article.title}<br>
	# 내용: <textarea rows="3" disabled>${article.content}</textarea>	
</p>

<a href="<c:url value = '/board/list'/>">글 목록보기</a>&nbsp;
<a href="<c:url value = '/board/modify?boardNo=${article.boardNo}'/>">글 수정하기</a>

</body>
</html>










#modify.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>${article.boardNo}번 게시물 내용 수정</h2>
<form method="post">

	<p>
		# 글번호: ${article.boardNo}<br>
		# 작성자: <input type="text" name="writer" value="${article.writer}"><br>
		# 제목: <input type="text" name="title" value="${article.title}"><br>
		# 내용: <textarea rows="3" name="content">${article.content}</textarea>
		<br>
		<input type="submit" value="수정">
	</p>
</form>

<a href="<c:url value = '/board/list'/>">글 목록보기</a>&nbsp;


</body>
</html>















































































































































































21.02.16.10회차
===============================================================================
*mybatis환경구축,구문처리(score,board)
===============================================================================












































































































































































##############################################################################
41)mybatis 환경구축

<package>
com.spring.database.mybatis.score.model 
com.spring.database.mybatis.score.controller
com.spring.database.mybatis.score.service
com.spring.database.mybatis.score.repository


<views/score>
이건 score2로 복사해라
그리고 그에따라 변경해야할것들 다 변경해라


1)옮기는거에 대한 호환성점검
	-위 패키지에 repository의 ScoreDAO 빼고 다 붙여놓고 아래조건처럼
		-IScoreDAO의 이름은 IScoreMapper로 변경하라
	-빈등록 id 다 2붙여라
	-controller, service 빈등록 id를 2를 붙여서 다 바꿔줘라 그후 service에서 DAO 안만들었으니까 잠시 autowired 주석처리
		해서 helloword 뜨는지 확인, database/mybatis/score2/register 되는지 확인
					database/score/register도 이상없이 되는지 확인
		-autowired를 안지우면 빈이 안등록됐는데 어떻게 만드냐고 에러뜬다 우리는 지금 1번에서는 IScoreMapper까지만
			만들었으니까 당연히 집어넣을 객체가 없으니 에러나지!
<controller 수정사항>
-controller에서 공용 url에 /mybatis 추가
-void형 String으로 변환(공용url때매)


2)라이브러리추가(pom.xml)
-mybatis 라이브러리 추가
		<dependency>
		    <groupId>org.mybatis</groupId>
		    <artifactId>mybatis</artifactId>
		    <version>3.4.6</version>
		</dependency>

-마이바티스와 스프링을 연동해주는 라이브러리 추가
		<dependency>
		    <groupId>org.mybatis</groupId>
		    <artifactId>mybatis-spring</artifactId>
		    <version>1.3.2</version>
		</dependency>
-저장 후 메이븐적용


3)jdbc템플릿 빈등록한거 밑에 mybatis 핵심객체등록
	-사실 jdbc템플릿은 이제 안쓸꺼니 지워도됨
root-context에서 해라


##############################################################################

답:


#pom.xml

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/maven-v4_0_0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>com.spring</groupId>
	<artifactId>db</artifactId>
	<name>SpringDBAccess</name>
	<packaging>war</packaging>
	<version>1.0.0-BUILD-SNAPSHOT</version>
	<properties>
		<java-version>1.8</java-version>
		<org.springframework-version>5.1.5.RELEASE</org.springframework-version>
		<org.aspectj-version>1.6.10</org.aspectj-version>
		<org.slf4j-version>1.6.6</org.slf4j-version>
	</properties>
	<dependencies>
		<!-- Spring -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
			<version>${org.springframework-version}</version>
			<exclusions>
				<!-- Exclude Commons Logging in favor of SLF4j -->
				<exclusion>
					<groupId>commons-logging</groupId>
					<artifactId>commons-logging</artifactId>
				 </exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>${org.springframework-version}</version>
		</dependency>
				
		<!-- spring-jdbc -->
		<dependency>
		    <groupId>org.springframework</groupId>
		    <artifactId>spring-jdbc</artifactId>
		    <version>${org.springframework-version}</version>
		</dependency>
		
		<!-- 마이바티스 라이브러리 추가 -->
		<dependency>
		    <groupId>org.mybatis</groupId>
		    <artifactId>mybatis</artifactId>
		    <version>3.4.6</version>
		</dependency>
		
		<!-- 마이바티스와 스프링을 연동해주는 라이브러리 -->
		<dependency>
		    <groupId>org.mybatis</groupId>
		    <artifactId>mybatis-spring</artifactId>
		    <version>1.3.2</version>
		</dependency>
		
		
		
		<!--  MySQL Connector/J  -->
		<dependency>
		    <groupId>mysql</groupId>
		    <artifactId>mysql-connector-java</artifactId>
		    <version>8.0.15</version>
		</dependency>
		
		<!--  HikariCP : Connection pool -->
		<!-- https://mvnrepository.com/artifact/com.zaxxer/HikariCP -->
		<dependency>
		    <groupId>com.zaxxer</groupId>
		    <artifactId>HikariCP</artifactId>
		    <version>2.7.8</version>
		</dependency>
				
		<!-- AspectJ -->
		<dependency>
			<groupId>org.aspectj</groupId>
			<artifactId>aspectjrt</artifactId>
			<version>${org.aspectj-version}</version>
		</dependency>	
		
		<!-- Logging -->
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-api</artifactId>
			<version>${org.slf4j-version}</version>
		</dependency>
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>jcl-over-slf4j</artifactId>
			<version>${org.slf4j-version}</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-log4j12</artifactId>
			<version>${org.slf4j-version}</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>log4j</groupId>
			<artifactId>log4j</artifactId>
			<version>1.2.15</version>
			<exclusions>
				<exclusion>
					<groupId>javax.mail</groupId>
					<artifactId>mail</artifactId>
				</exclusion>
				<exclusion>
					<groupId>javax.jms</groupId>
					<artifactId>jms</artifactId>
				</exclusion>
				<exclusion>
					<groupId>com.sun.jdmk</groupId>
					<artifactId>jmxtools</artifactId>
				</exclusion>
				<exclusion>
					<groupId>com.sun.jmx</groupId>
					<artifactId>jmxri</artifactId>
				</exclusion>
			</exclusions>
			<scope>runtime</scope>
		</dependency>

		<!-- @Inject -->
		<dependency>
			<groupId>javax.inject</groupId>
			<artifactId>javax.inject</artifactId>
			<version>1</version>
		</dependency>
				
		<!-- Servlet -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>3.1.0</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet.jsp</groupId>
			<artifactId>jsp-api</artifactId>
			<version>2.1</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jstl</artifactId>
			<version>1.2</version>
		</dependency>
	
		<!-- Test -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.12</version>
			<scope>test</scope>
		</dependency>        
	</dependencies>
    <build>
        <plugins>
            <plugin>
                <artifactId>maven-eclipse-plugin</artifactId>
                <version>2.9</version>
                <configuration>
                    <additionalProjectnatures>
                        <projectnature>org.springframework.ide.eclipse.core.springnature</projectnature>
                    </additionalProjectnatures>
                    <additionalBuildcommands>
                        <buildcommand>org.springframework.ide.eclipse.core.springbuilder</buildcommand>
                    </additionalBuildcommands>
                    <downloadSources>true</downloadSources>
                    <downloadJavadocs>true</downloadJavadocs>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.5.1</version>
                <configuration>
                    <source>1.8</source>
                    <target>1.8</target>
                    <compilerArgument>-Xlint:all</compilerArgument>
                    <showWarnings>true</showWarnings>
                    <showDeprecation>true</showDeprecation>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>exec-maven-plugin</artifactId>
                <version>1.2.1</version>
                <configuration>
                    <mainClass>org.test.int1.Main</mainClass>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>



#root-context.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<!-- JDBC, DB관련 빈을 등록하고 관리하는 설정파일 -->
	<!-- 히카리 커넥션풀 빈 등록  : 이건 우리가만든 클래스가 아니라서 안에서 Repository service로 자동빈등록
		불가하니까 직접 빈등록해줘야함-->
	<bean id = "hikariConfig" class = "com.zaxxer.hikari.HikariConfig">
		<property name = "driverClassName" value = "com.mysql.cj.jdbc.Driver" />
		<property name = "jdbcUrl" value = "jdbc:mysql://localhost:3306/spring?serverTimezone=Asia/Seoul" />
		<property name = "username" value = "root" />
		<property name = "password" value = "mysql" />
	</bean>
	
	<!--  히카리 데이터 소스 빈 등록 -->
	<bean id = "ds" class = "com.zaxxer.hikari.HikariDataSource">
		<constructor-arg ref = "hikariConfig"/> <!--  남이만든 라이브러리는 우리가직접의존성
				주입해야하니까 처음에 이런것들을 배운거다. -->
	</bean>
	
	<!--  JDBC 템플릿 클래스 빈 등록 -->
	<bean id = "jdbcTemplate" class = "org.springframework.jdbc.core.JdbcTemplate">
		<property name = "dataSource" ref = "ds"/>
	</bean>
	
	<!-- mybatis SQL 동작을 위한 핵심객체 SqlSessionFactory 클래스 빈 등록 -->
	<bean id = "sqlSessionFactory" class = "org.mybatis.spring.SqlSessionFactoryBean">
		<property name = "dataSource" ref = "ds" />
	</bean>
</beans>










##############################################################################
42)환경구축 및 insert, select, delete 구문 처리하기

폴더 : mappers-score
xml : ScoreMapper.xml
	-<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
	    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

1)핵심객체에 설정파일 ScoreMapper.xml 위치 알려주기
		-ScoreMapper.xml이 IScoreMapper의 구현클래스 역할을 함
	main resource에 있는 애들은 value 줄때 classpath:으로 알려줌

2)namespaces에서 mybatis-spring 체크해서 추가
	-이러면 root-context.xml의 beans에 mybatis 관련 코드가 추가됨

3)DAO 빈객체 만들기(이름은 IScoreMapper interface를 자동으로 새큰해서 빈등록 코드 적기)
	-beans graph해서 sqlSessionFactory와 IScoreMapper 빈 등록됨을 확인
4)이대로 실행하면 hello 안뜨는거 확인하고 ScoreMapper.xml에서 mapper의 namespace에 인터페이스 절대경로 적어주고나면 
	hello 되는거 확인

5)IScoreMapper.java의 insertScore() 메서드를 ScoreMapper.xml에 재정의하고 service에서는 
	autowired의 주석을 풀어라(앞문제에서 주석했었음) 그리고 hello 잘되는가 확인하라

6)insertScore, selectAllScores 메서드를 ScoreMapper.xml에 넣어서 브라우저에서 정상처리되도록 하라

7)삭제기능 잘되게 만들어라

8)개인조회기능 잘되게 만들어라

##############################################################################

답:






------------------------------
<model>
#ScoreVO

package com.spring.database.mybatis.score.model;

public class ScoreVO {
/*
 -- 점수 테이블 생성 : DB에 이렇게 작성하면됨 : 이름규칙도 java에서는 카멜인데 db에서는 _를 씀 그래도 다르게설정
CREATE TABLE scores (
	stu_id INT PRIMARY KEY AUTO_INCREMENT,
    stu_name VARCHAR(60) NOT NULL,
    kor INT,
    eng INT,
    math INT,
    total INT,
    average FLOAT(5, 2) -- 다섯자리수까지, 소수점표현은 두번째자리까지 최대수 -> 100.00 5자리에 소수점 2개 99.99면 4자리에 2 
);
 */
	
	private Integer stuId;
	private String stuName;
	private Integer kor;
	private Integer eng;
	private Integer math;
	private Integer total;
	private Double average;
	
	//총점 평균을 구하는 메서드
	public void calcData() {
		this.total = this.kor + this.eng + this.math;
		this.average = Math.round((this.total / 3.0) * 100) / 100.0;
		
	}
	
	
	public Integer getStuId() {
		return stuId;
	}
	public void setStuId(Integer stuId) {
		this.stuId = stuId;
	}
	public String getStuName() {
		return stuName;
	}
	public void setStuName(String stuName) {
		this.stuName = stuName;
	}
	public Integer getKor() {
		return kor;
	}
	public void setKor(Integer kor) {
		this.kor = kor;
	}
	public Integer getEng() {
		return eng;
	}
	public void setEng(Integer eng) {
		this.eng = eng;
	}
	public Integer getMath() {
		return math;
	}
	public void setMath(Integer math) {
		this.math = math;
	}
	public Integer getTotal() {
		return total;
	}
	public void setTotal(Integer total) {
		this.total = total;
	}
	public Double getAverage() {
		return average;
	}
	public void setAverage(Double average) {
		this.average = average;
	}
	
	
	@Override
	public String toString() {
		return "ScoreVO [stuId=" + stuId + ", stuName=" + stuName + ", kor=" + kor + ", eng=" + eng + ", math=" + math
				+ ", total=" + total + ", average=" + average + "]";
	}
	
	
	
}

------------------------------
<controller>
#ScoreController
package com.spring.database.mybatis.score.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.spring.database.mybatis.score.model.ScoreVO;
import com.spring.database.mybatis.score.service.IScoreService;

@Controller("scoreController2")
@RequestMapping("/mybatis/score2")
public class ScoreController {
	@Autowired
	@Qualifier("scoreService2")
	private IScoreService service;
	
	//점수 등록 화면을 열어주는 처리를 하는 요청메서드
	@GetMapping("/register")
	public String register() {
		System.out.println("/score/register: GET");
		return "score2/write-form";
	}
	
	//점수 등록을 처리하는 요청 메서드
	@PostMapping("/register")
	public String register(ScoreVO scores) {
		System.out.println("/score/register: POST");
		System.out.println("Controller param: " + scores);
		
		service.insertScore(scores);
		return "score2/write-result";
	}
	
	//점수 전체 조회를 처리하는 요청 메서드
	@GetMapping("/list")
	public String list(Model model) {
		System.out.println("/score/list: GET");
		List<ScoreVO> list = service.selectAllScores();
		model.addAttribute("sList", list);
		return "score2/list";
	}
	
	//점수 삭제 요청 처리 메서드
	@GetMapping("/delete")
	public String delete(@RequestParam("stuNum") int stuNum, RedirectAttributes ra) {
//		List<ScoreVO> list = service.selectAllScores();
		service.deleteScore(stuNum);
		ra.addFlashAttribute("message", "delSuccess");
		return "redirect:/mybatis/score2/list";
	}
	
	//점수 개별 조회 화면 열람요청 메서드
	@GetMapping("/search")
	public String search() {
		System.out.println("/score/search: GET");
		return "score2/search";
	}
	
	@PostMapping("/selectOne")
	public String selectOne(String stuNum, Model model, RedirectAttributes ra) {
		
		/*
		try {
			ScoreVO stu = service.selectOneScore(Integer.parseInt(stuNum));			
			model.addAttribute("stu", stu);
			return "/score/select-result";
		} catch(NumberFormatException e) {
			ra.addFlashAttribute("message", "숫자로만 입력하세요!");
			return "redirect:/score/search"; 
		} catch(IndexOutOfBoundsException e) {
			ra.addFlashAttribute("message", "학번정보가 없습니다.");
			return "redirect:/score/search";
		} 
		*/
		List<ScoreVO> list = service.selectAllScores();
		
		try {
			int n = Integer.parseInt(stuNum);
			if (n > list.size()) {
				ra.addFlashAttribute("message", "학번정보가 없습니다.");
				return "redirect:/mybatis/score2/search";
			}
			
			ScoreVO stu = service.selectOneScore(n);			
			model.addAttribute("stu", stu);
			return "score/select-result";
		} catch(NumberFormatException e) {
			ra.addFlashAttribute("message", "숫자로만 입력하세요!");
			return "redirect:/mybatis/score2/search"; 
		} 
	}
}

------------------------------
<service>
#IScoredService
package com.spring.database.mybatis.score.service;

import java.util.List;

import com.spring.database.mybatis.score.model.ScoreVO;

public interface IScoreService {
	//점수 등록 기능
	void insertScore(ScoreVO scores);
	
	//점수 전체 조회 기능
	List<ScoreVO> selectAllScores();
	
	//점수 삭제기능
	void deleteScore(int stuNum);
	
	ScoreVO selectOneScore(int stuNum);
	
}



#ScoreService
package com.spring.database.mybatis.score.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.spring.database.mybatis.score.repository.IScoreMapper;
import com.spring.database.mybatis.score.model.ScoreVO;


@Service("scoreService2")
public class ScoreService implements IScoreService {

	@Autowired
	private IScoreMapper dao;
	
	@Override
	public void insertScore(ScoreVO scores) {
		// TODO Auto-generated method stub
		scores.calcData();
		dao.insertScore(scores);
	}

	
	@Override
	public List<ScoreVO> selectAllScores() {
		// TODO Auto-generated method stub
		return dao.selectAllScores();
	}
	
	

	@Override
	public void deleteScore(int stuNum) {
		// TODO Auto-generated method stub
		dao.deleteScore(stuNum);
	}
	
	public ScoreVO selectOneScore(int stuNum) {
		return dao.selectOneScore(stuNum);
	}

}

------------------------------
<repository>
#IScoreDAO
package com.spring.database.mybatis.score.repository;

import java.util.List;

import com.spring.database.mybatis.score.model.ScoreVO;

public interface IScoreMapper {
	//점수 등록 기능
	void insertScore(ScoreVO scores);
	
	//점수 전체 조회 기능
	List<ScoreVO> selectAllScores();
	
	//점수 삭제기능
	void deleteScore(int stuNum);
	
	ScoreVO selectOneScore(int stuNum);
}

------------------------------
<main/resource/mappers/score>
#ScoreMapper.xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    
<mapper namespace = "com.spring.database.mybatis.score.repository.IScoreMapper">
	<!-- DB컬럼명과 VO의 필드명을 맞추는 ResultMap 선언 -->
	<resultMap id = "ScoreMap" type = "com.spring.database.mybatis.score.model.ScoreVO">
		<id property = "stuId" column = "stu_id"/> <!--  primary key 매핑 -->
		<result property = "stuName" column = "stu_name" />
		<result property = "kor" column = "kor" />
		<result property = "eng" column = "eng" />
		<result property = "math" column = "math" />
		<result property = "total" column = "total" />
		<result property = "average" column = "average" />
	</resultMap>
	
	
	<!--  점수 등록 기능 -->
	<insert id = "insertScore">
		INSERT INTO scores 
		(stu_name, kor, eng, math, total, average)
		VALUES (#{stuName}, #{kor}, #{eng}, #{math}, #{total}, #{average})
	</insert>
	
	<!--  점수 목록 조회 기능 -->
	<select id = "selectAllScores" resultMap = "ScoreMap">
		SELECT * FROM scores
	</select>
	
	<!--  점수 삭제 기능 -->
	<delete id = "deleteScore">
		DELETE FROM scores WHERE stu_id = #{stuNum}
	</delete>
	
	
	<select id = "selectOneScore" resultMap = "ScoreMap">
		SELECT * FROM scores
		WHERE stu_id = #{stuNum}
	</select>
</mapper>


------------------------------
<views/board>
#write-form.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h2>시험 점수 등록</h2>
<form method = "post">
	<p>
		# 이름 : <input type = "text" name = "stuName"><br>
		# 국어 : <input type = "text" name = "kor"><br>
		# 영어 : <input type = "text" name = "eng"><br>
		# 수학 : <input type = "text" name = "math"><br>
		<input type = "submit" value = "확인">
	</p>
</form>

</body>
</html>

#write-result.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	<h2>점수 등록 성공!</h2>
	<a href = "/database/mybatis/score2/register">다른 점수 등록하기</a>
	<a href = "/database/mybatis/score2/list">점수 전체 조회</a>
	<a href = "/database/mybayis/score2/search">점수 개별 조회</a>

</body>
</html>


#list.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>    
    
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>학생들의 전체  성적 조회</h2>
<c:forEach var = "stu" items = "${sList}">
	<p>
		# 학번 : ${stu.stuId}, 이름 : ${stu.stuName}, 국어 : ${stu.kor}, 영어 : ${stu.eng},
		 수학 : ${stu.math}, 총점 : ${stu.total}, 평균 : ${stu.average}
		&nbsp;
		<a href = "/database/mybatis/score2/delete?stuNum=${stu.stuId}">[삭제]</a>	
	</p>
</c:forEach>

<a href = "/database/mybatis/score2/register">다른 점수 등록하기</a> 
<a href = "/database/mybatis/score2/list">점수 전체 조회</a>
<a href = "/database/mybatis/score2/search">점수 개별 조회</a>

<script type = "text/javascript">
	const msg = "${message}";
	console.log(msg);
	if (msg === "delSuccess") {
		alert("점수 삭제 완료!");
	}
</script>


</body>
</html>


#search.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>개별 점수 조회</h2>
<form action = "/database/mybatis/score2/selectOne" method = "post">
	<p>
		#조회할 학번 : <input type = "text" name = "stuNum" size = "5">
				   <input type = "submit" value = "조회">
	</p>
</form>

<p style = "color:red;">
	${message}
</p>

</body>
</html>


#select-result.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>${stu.stuName}학생 성적 정보 조회</h2>

<p>	
	# 국어 : ${stu.kor} <br>
	# 영어 : ${stu.eng} <br>
	# 수학 : ${stu.math} <br>
	# 총점 : ${stu.total} <br>
	# 평균 : ${stu.average} 
</p>

<a href = "/database/mybatis/score2/register">다른 점수 등록하기</a> 
<a href = "/database/mybatis/score2/list">점수 전체 조회</a>
<a href = "/database/mybatis/score2/search">점수 개별 조회</a>

</body>
</html>

















##############################################################################
43)board 에도 mybatis로 실습하기
	-강사님이 qualifier 경험했으니 jdbc 파일로 그냥 사용하잖다
			-즉 board를 변경시키란 말
			-이렇게하면 repository 측만 변경하면됨
	
1)환경구축
	-repository에 IBoardMapper라는 interface 만들고 해당 interface에 IBoardDAO의 메소드를 모두 붙여넣기
	-service에 빈등록된 객체의 타입을 통해 찾는 autowired의 대상을 IBoardDAO에서 IBoardMapper로 변경
		-기존 auto는 주석
	-그러고 나서 서버실행하면 터짐. 왜냐면 아직 autowired될 타입의 빈객체(BoardDAO 인스턴스)가 등록되어 있지 않기때문임
		-servlet-content.xml파일에 자동등록은 com.spring.database에서 알아서 찾아서 해당 클래스의 인스턴스를
		모두 자동 빈등록하라고 명시해놓은게 있음 하지만 그 자동 빈등록할 클래스조차 없다는 뜻임
		<context:component-scan base-package="com.spring.database" />
	-그래서 auto만 주석으로 두고 다시 실행
		-서버 잘됨 
		-하지만 list를 입력하면 null pointer excetion이 뜸을 확인
		
2)위 1번 마지막에 null pointer가 안뜨도록 xml부터 여러가지 설정하여 list 부터 모든 기능이 잘 동작하도록 만드시오
##############################################################################

답:









------------------------------
<repository>
#IBoardMapper

package com.spring.database.jdbc.board.repository;

import java.util.List;

import com.spring.database.jdbc.board.model.BoardVO;

public interface IBoardMapper {
		//게시글 목록 가져오기
		List<BoardVO> getArticles();
		
		//게시글 등록
		void insertArticle(BoardVO article);
		
		//게시글 삭제
		void deleteArticle(int boardNo);
		
		//게시글 내용보기
		BoardVO getContent(int boardNo);
		
		//게시글 수정
		void modifyArticle(BoardVO article);
		
		//게시글 검색
		List<BoardVO> getSearchList(String keyword);
}




------------------------------
<main/resources/mappers/board>
#BoardMapper.xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    
<mapper namespace = "com.spring.database.jdbc.board.repository.IBoardMapper">

	<resultMap id = "BoardMap" type = "com.spring.database.jdbc.board.model.BoardVO">
		<id property = "boardNo" column = "board_no"/>
		<result property = "writer" column = "writer" />
		<result property = "title" column = "title" />
		<result property = "content" column = "content" />
	</resultMap>

	<!--  게시글 목록 조회 -->
	<select id = "getArticles" resultMap = "BoardMap">
		SELECT * FROM jdbc_board
		ORDER BY board_no DESC
	</select>
	
	<!--  게시글 등록 -->
	<insert id = "insertArticle">
		INSERT INTO jdbc_board 
		(writer, title, content)
		VALUES (#{writer}, #{title}, #{content})
	</insert>
	
	<!--  게시글 삭제 -->
	<delete id = "deleteArticle">
		DELETE FROM jdbc_board
		WHERE board_no = #{boardNo}
	</delete>
	
	<!-- 게시글 내용보기-->
	<select id = "getContent" resultMap = "BoardMap">
		SELECT * FROM jdbc_board
		WHERE board_no = #{boardNo}
	</select>
	
	<!--  게시글 수정 -->
	<update id = "modifyArticle">
		UPDATE jdbc_board
		SET writer = #{writer}, title = #{title}, content = #{content}
		WHERE board_no = #{boardNo}
	</update>
	
	<!-- 게시글 검색 -->
	<select id = "getSearchList" resultMap = "BoardMap">
		SELECT * FROM jdbc_board
		WHERE writer like #{keyword}
		ORDER BY board_no DESC
	</select>
</mapper>


------------------------------
<root-content.xml> : 마지막한줄 추가된거임

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:mybatis-spring="http://mybatis.org/schema/mybatis-spring"
	xsi:schemaLocation="http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring-1.2.xsd
		http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd">
	
	<!-- JDBC, DB관련 빈을 등록하고 관리하는 설정파일 -->
	<!-- 히카리 커넥션풀 빈 등록  : 이건 우리가만든 클래스가 아니라서 안에서 Repository service로 자동빈등록
		불가하니까 직접 빈등록해줘야함-->
	<bean id = "hikariConfig" class = "com.zaxxer.hikari.HikariConfig">
		<property name = "driverClassName" value = "com.mysql.cj.jdbc.Driver" />
		<property name = "jdbcUrl" value = "jdbc:mysql://localhost:3306/spring?serverTimezone=Asia/Seoul" />
		<property name = "username" value = "root" />
		<property name = "password" value = "mysql" />
	</bean>
	
	<!--  히카리 데이터 소스 빈 등록 -->
	<bean id = "ds" class = "com.zaxxer.hikari.HikariDataSource">
		<constructor-arg ref = "hikariConfig"/> <!--  남이만든 라이브러리는 우리가직접의존성
				주입해야하니까 처음에 이런것들을 배운거다. -->
	</bean>
	
	<!--  JDBC 템플릿 클래스 빈 등록 -->
	<bean id = "jdbcTemplate" class = "org.springframework.jdbc.core.JdbcTemplate">
		<property name = "dataSource" ref = "ds"/>
	</bean>
	
	<!-- mybatis SQL 동작을 위한 핵심객체 SqlSessionFactory 클래스 빈 등록 -->
	<bean id = "sqlSessionFactory" class = "org.mybatis.spring.SqlSessionFactoryBean">
		<property name = "dataSource" ref = "ds" />
		<property name = "mapperLocations" value = "classpath:/mappers/**/*Mapper.xml" />
	</bean>
	
	<!--  interface가 namespace로 구현된 마이바티스 xml 파일(class역할)을 빈 객체로 등록하기 위한 스캔 설정 -->
	<mybatis-spring:scan base-package="com.spring.database.mybatis.score.repository"/>



	<mybatis-spring:scan base-package="com.spring.database.jdbc.board.repository"/>
</beans>

































































































































































21.02.17.11회차
===============================================================================
*db연동테스트(커넥션, mapper단위테스트)
===============================================================================

































































































































































##############################################################################
44)환경설정, 벡엔드구조설계

1)환경설정
SpringWebMvcProject

com.spring.mvc(gid + artifact id)

<제일처음 project에 관한것>
	-자바버전 1.8
	-springframe 5.1.5
	-servlet에 3.1.0, javax.

<test>
	-junit의 4.12로 업그레이드
		7보다 12가 크니까 업그레이드임

<mavencompiler>
	-3.5.1
	-1.8, 1.8

<AspectJ 위에 jdbc, mybatis, mybatis와 spring 연동해주는라이브러리, Mysql connector, hikariCP 5개 다가져와라>

pom.xml 저장 후 메이븐등록

톰켓설정파일 열어서 포트를 실제배포를 위해 80번으로 변경(도메인주소 뒤에 8080안나오게하려면 기본주소인 80으로해야함)
	-저장 후 적용아이콘클릭

<톰켓server.xml>
컨텍스트루트없애기
<Context docBase="SpringWebMvcProject" path="/mvc" reloadable="true" source="org.eclipse.jst.jee.server:SpringWebMvcProject"/></Host>
/mvc를 /로 변경

저장후 적용하기누르면 No!!! 눌러야 적용이됨 yes 아님

그후서버키고 http://localhost 만 입력해도되는가봐라


<web.xml> : 한글깨지는거 막아라

servlet-context.xml을 app폴더에서 빼고 app폴더삭제해라

root-context -> mvc-config.xml
servlet-context.xml -> servlet-config.xml

*이제 이름 바꿨으니 변화된거 설정해야함
servlet-context, root-context관련된건 web.xml에서 해야함
	-23번라인쯤에 appServlet 경로 지우고<param-value>
		<param-value>/WEB-INF/spring/appServlet/servlet-context.xml</param-value>
			<param-value>/WEB-INF/spring/servlet-config.xml</param-value>

		<param-value>/WEB-INF/spring/root-context.xml</param-value>
			<param-value>/WEB-INF/spring/mvc-config.xml</param-value>


2)벡엔드 구조 설계
<resource/sql폴더만들고>
	-mvc_board.sql 만들기
	-아래 코드를 여기에 넣고 복사붙여넣기해서 워크벤치에서 실행

CREATE TABLE mvc_board (
	board_no INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255) NOT NULL,
    content TEXT NULL,
    writer VARCHAR(50) NOT NULL,
    reg_date TIMESTAMP DEFAULT NOW(),
    view_cnt INT DEFAULT 0
);


com.spring.mvc.board.model
	-BoardVO
com.spring.mvc.board.repository
	-IBoardMapper

#IBoardMapper.java
package com.spring.mvc.board.repository;

import java.util.List;

import com.spring.mvc.board.model.BoardVO;

//게시판 관련 CRUD 추상 메서드 선언
public interface IBoardMapper {
	// 게시글 등록 기능
	void insert(BoardVO article);
	
	// 게시글 목록 조회
	List<BoardVO> getArticleList();
	
	// 게시글 상세 조회기능
	BoardVO getArticle(Integer boardNo);
	
	// 게시글 수정 기능
	void update(BoardVO article);
	
	// 게시글 삭제 기능
	void delete(Integer boardNo);
	
}



-mvc-config.xml에 빈객체 등록
	-메퍼 인터페이스 스캔설정까지

-mappers 폴더 안에 board 폴더 안에 BoardMapper 생성
	-BoardMapper에서 최소한의 서버동작을 확인하기위한 소스작성까지만 해라

-서버동작 -> 헬로나오는지 확인


##############################################################################


답: 그냥 하면됨 다나와있고 복붙도해줬음 정모르겠으면 이전 프로젝트 확인ㄱㄱ



















##############################################################################
45)db연동테스트(커넥션,단위테스트1)


3)db연동테스트
3-1)커넥션 테스트
com.spring.mvc.board.test
	-DbConnectTest
		-아래코드 복붙
		-우클릭 -> run as->junit ~~ 하면 초록색나오고 출력잘나오면 잘된거

	private static final String DRIVER
	= "com.mysql.cj.jdbc.Driver";
	private static final String URL 
	= "jdbc:mysql://localhost:3306/spring?serverTimezone=Asia/Seoul";
	private static final String UID = "root";
	private static final String UPW = "mysql";

	//커넥션 테스트
	@Test
	public void connectTest() {

		Connection conn = null;

		try {
			Class.forName(DRIVER);

			conn = DriverManager.getConnection(URL, UID, UPW);
			System.out.println("DB 커넥션 성공!");
			System.out.println("conn: " + conn);

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			try {
				conn.close();
			} catch (Exception e2) {
				e2.printStackTrace();
			}
		}

	}

3-2)게시글 등록 단위 테스트(junit을 사용한 단위 테스트)
	-먼저 BoardMapper.xml에 insert메소드에 관한거 작성하라
	-그다음 BoardMapper가 잘 연동되는지확인하기 위해서 BoardMapperTest 생성
		-package com.spring.mvc.board.test
	-근데 위에서 다른것들 테스트할때는 자동으로 객체 만들어서 하는데 이건 그객체안에 자동주입해야할 객체가 또있다.
		딴건 자동주입이 없어서 상관없었지만 이놈은 자동주입을 해야해서 특정 파일을 실행시키는 클래스가 
		필요하다. 그래서 아래처럼
		@RunWith(springJUnit4ClassRunner.class)
		를 추가해야하는데 이 springJUnit4ClassRunner.class를
		 사용하려면 또다른 라이브러리를 설치해야한다.(pom.xml에서 설치해야함)
		<!--  Spring Test 모듈 -->
		<dependency>
		    <groupId>org.springframework</groupId>
		    <artifactId>spring-test</artifactId>
		    <version>${org.springframework-version}</version>
		</dependency>
	-@ContextConfiguration(locations = {"file:src/main/webapp/WEB-INF/spring/mvc-config.xml"})
		-원래는 시작하면서 자동으로 저 파일경로의 mvc-config.xml을 보고 자동등록을 해서 찾으러다니지만 지금은 테스트라서
			저 문서가 실행되지 않는다. 그럼으로 빈 자동등록과 스캔설정(자동주입설정)이 되어있는 곳의 위치를 알려주어야한다.
		-이걸하기 위해서 위에 @RunWith() 한거임 
		-@ContextConfiguration : @Autowired가 작동되려면 자동주입설정을 해놓은 설정파일의 소스코드가 있어야한다.
			해당 파일의 위치를 알려줘서 파일을 임의로 동작시키는 아노테이션
	
	-실행해보라

##############################################################################


답:

#BoardMapper.xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    
    
<mapper namespace="com.spring.mvc.board.repository.IBoardMapper">
	<insert id = "insert">
		INSERT INTO mvc_board 
			(title, content, writer)
		VALUES (#{title}, #{content}, #{writer})
	</insert>
</mapper>




#src/test/java/com.spring.mvc.board.test.BoardMapperTest.java

package com.spring.mvc.board.test;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import com.spring.mvc.board.model.BoardVO;
import com.spring.mvc.board.repository.IBoardMapper;

@ContextConfiguration(locations = {"file:src/main/webapp/WEB-INF/spring/mvc-config.xml"})
@RunWith(SpringJUnit4ClassRunner.class)

public class BoardMapperTest {
	@Autowired
	private IBoardMapper mapper;
	
	//게시글 등록 단위 테스트(junit을 사용한 단위 테스트)
	@Test
	public void insertTest() {
		BoardVO article = new BoardVO();
		article.setTitle("테스트 제목입니다.");
		article.setWriter("김테스트");
		article.setContent("테스트 중이니까 말시키지 마시오!");
		mapper.insert(article);
		System.out.println("게시물 등록 성공!");
	}
	
	
}














##############################################################################
46)db연동테스트(단위테스트2)

1)위에 insertTest() 메소드내부에 코드를 for문에 넣어서 320개를 추가로 더넣어라 각 필드의 벨류값 끝에
	+ i를 해서 1~ 320 이 들어가게해서 식별가능하도록해라 마지막엔 게시물등록성공!나오게하고
	잘들어왔나 확인하라

2)게시글 목록조회 단위 테스트 해봐라
	-outline을 이용하는게 단위 테스트다 
	-람다를 이용해서도 해봐라

3)게시글 단일 조회 테스트

4)게시글 수정 테스트

5)게시글 삭제 테스트
##############################################################################


답: 나머지 전체코드는 깃허브 22.02.17의 workspace를 봐라



#BoardMapper.xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    
    
<mapper namespace="com.spring.mvc.board.repository.IBoardMapper">

	<resultMap id = "BoardMap" type="com.spring.mvc.board.model.BoardVO" >
		<id property="boardNo" column="board_no" />
		<result property="title" column = "title" />
		<result property="content" column = "content" />
		<result property="writer" column = "writer" />
		<result property="regDate" column = "reg_date" />
		<result property="viewCnt" column = "view_cnt" />
	</resultMap>

	<insert id = "insert">
		INSERT INTO mvc_board 
			(title, content, writer)
		VALUES (#{title}, #{content}, #{writer})
	</insert>
	
	<select id = "getArticleList" resultMap = "BoardMap">
		SELECT * 
		FROM mvc_board
		ORDER BY board_no DESC
	</select> 
	
	<select id = "getArticle" resultMap = "BoardMap">
		SELECT * 
		FROM mvc_board
		WHERE board_no = #{boardNo}
	</select>
	
	<update id = "update">
		UPDATE mvc_board
		SET writer = #{writer}, title = #{title}, content = #{content}
		WHERE board_no = #{boardNo}
	</update>
	
	<delete id = "delete">
		DELETE FROM mvc_board
		WHERE board_no = #{boardNo}
	</delete>
</mapper>






#BoardMapperTest.java

package com.spring.mvc.board.test;

import java.util.List;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import com.spring.mvc.board.model.BoardVO;
import com.spring.mvc.board.repository.IBoardMapper;

@ContextConfiguration(locations = {"file:src/main/webapp/WEB-INF/spring/mvc-config.xml"})
@RunWith(SpringJUnit4ClassRunner.class)

public class BoardMapperTest {
	@Autowired
	private IBoardMapper mapper;
	
	//게시글 등록 단위 테스트(junit을 사용한 단위 테스트)
	@Test
	public void insertTest() {
		
		for (int i = 1; i <= 320; i++) {
			BoardVO article = new BoardVO();
			article.setTitle("테스트 제목입니다." + i);
			article.setWriter("김테스트" + i);
			article.setContent("테스트 중이니까 말시키지 마시오!" + i);
			mapper.insert(article);			
		}
		
		System.out.println("게시물 등록 성공!");
	}
	
	
	//게시글 목록 조회 테스트
	@Test
	public void getListTest() {
//		List<BoardVO> list = mapper.getArticleList();
//		for (BoardVO vo : list) {
//			System.out.println(vo);
//		}
		
		mapper.getArticleList().forEach(vo -> System.out.println(vo));
	}
	
	//게시글 단일 조회 테스트
	@Test
	public void getArticleTest() {
		System.out.println(mapper.getArticle(4));
	}
	


	
	//게시글 수정 테스트 :
	//vo의 세터를 사용하여 수정 내용(글제목, 글내용)을 입력하고
	//수정을 테스트해보세요.
	
	@Test
	public void updateTest() {
		BoardVO vo = new BoardVO();
		vo.setBoardNo(4);
		vo.setWriter("김테스트5");
		vo.setTitle("테스트제목입니다.5");
		vo.setContent("테스트 중이니까 말시키지 마시오!4");
		
		mapper.update(vo);
		System.out.println("변경 완료!");
//		getArticleTest();
		System.out.println("수정된 후 정보 : " + mapper.getArticle(4));
		
	}
	
	//게시글 삭제 테스트 : 게시글 번호를 통한 삭제를 확인
	@Test
	public void deleteTest() {
		mapper.delete(6);
		BoardVO vo = mapper.getArticle(6);
		if (vo == null) {
			System.out.println("# 게시물이 없습니다!");
		} else {
			System.out.println("# 게시물 정보 : " + vo);
		}
//		getListTest();
		
	}

	
}













































































































22.02.18.12회차
===============================================================================
*외부템플릿을 적용시켜서 게시판만들기(service,controller,jsp)
===============================================================================



























































































##############################################################################
47)벡엔드 구조 설계 및 게시글 목록불러오기 준비운동

com.spring.mvc.board.service.IBoardService
com.spring.mvc.board.service.BoardService
com.spring.mvc.board.controller.BoardController


1)게시글 목록 불러오기 요청
	-console : 
		-URL : /board/list GET -> result : 320
		-list의 객체들의 .toString() 정보 출력(람다를 이용해서 해라)
	-웹브라우저 응답 : 
		-list의 객체들의 .toString() 정보 출력
	

*아래 list.jsp를 이용하여 풀어라
#list.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
    
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core"  %>    
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>게시판 목록보기</h2>



</body>
</html>	
##############################################################################


답: 


#BoardController


package com.spring.mvc.board.controller;

import java.util.List;

import javax.inject.Inject;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import com.spring.mvc.board.model.BoardVO;
import com.spring.mvc.board.service.IBoardService;

@Controller
@RequestMapping("/board")
public class BoardController {
	@Inject
	private IBoardService service;
	
	//게시글 목록 불러오기 요청
	@GetMapping("/list")
	public String list(Model model) {
		List<BoardVO> list = service.getArticleList();
		System.out.println("URL : /board/list GET -> result : " + list.size());
//		list.forEach(article -> System.out.println(article));
		
		model.addAttribute("articles", list);
		return "board/list";
	}
}



#list.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
    
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core"  %>    
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>게시판 목록보기</h2>
<c:forEach var = "b" items = "${articles}">
	<p>${b}</p>
</c:forEach>


</body>
</html>






















##############################################################################
48)외부 ui 템플릿 사용, jsp에서 보안상 좋은 절대경로를 사용시 파일위치 매핑처리

1)템플릿 적용 및 절대경로 매핑처리
-views의 board폴더 및 home.jsp 삭제 흐 강의 자료 외부템플릿의 views의 내부 6가지자료(home + 5개폴더)
	 전부 복사붙여넣기(12일차 자료)
-webapp/resources에 강의자료 외부템플릿의 resources 내부 5개자료 복붙
	-위 두개의 외부템플릿은 깃허브에 22.02.18_외부템플릿(resouces,views) 커밋으로 저장해놓음

-서버구동
	-css 깨져있는 불안정한 페이지나오는게 맞다
	-f12 누르면 404 에러 엄청많다. 그거 경로를 못찾는거다

-절대경로로 사용하기위한 매핑처리를 servlet-config.xml에서 처리하고 다시돌려바라
	-이때 location은 webapp/까지만 자동으로 처리해준다는 것을 명심하자


2)localhost/에서(웹브라우저) 메뉴에 introduce를 누르면 404가 뜨는데 이게 안되도록 고쳐라
	-header에서 introduce를 클릭했을때 어디로 보내는지보고 그거에 맞게 HomeController에서
		해결해라
##############################################################################

nhn soft 자회사

nhn 계열사

명칭 : nhn nhn payco 빅풋 에듀 등 명함
	nhn

관계사, 계열사(nhn 



답:

1)템플릿 적용 및 절대경로 매핑처리
#src/main/webapp/WEB-INF/spring/servlet-config.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/mvc"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:beans="http://www.springframework.org/schema/beans"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd
		http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

	<!-- DispatcherServlet Context: defines this servlet's request-processing infrastructure -->
	
	<!-- Enables the Spring MVC @Controller programming model -->
	<annotation-driven />

	<!-- 정적자원 (html, css, img, js)등을 URI 절대 경로로 사용하기 위한 매핑처리 -->
	
	<resources mapping="/resources/**" location="/resources/" />
	<resources mapping = "/css/**" location = "/resources/css/"/>
	<resources mapping = "/js/**" location = "/resources/js/"/>
	<resources mapping = "/img/**" location = "/resources/img/"/>
	<resources mapping = "/scss/**" location = "/resources/scss/"/>
	<resources mapping = "/vendor/**" location = "/resources/vendor/"/>
	
	<!-- Resolves views selected for rendering by @Controllers to .jsp resources in the /WEB-INF/views directory -->
	<beans:bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<beans:property name="prefix" value="/WEB-INF/views/" />
		<beans:property name="suffix" value=".jsp" />
	</beans:bean>
	
	<context:component-scan base-package="com.spring.mvc" />
	
	
	
</beans:beans>






2)localhost/에서(웹브라우저) 메뉴에 introduce를 누르면 404가 뜨는데 이게 안되도록 고쳐라


package com.spring.mvc;

import java.util.Locale;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

/**
 * Handles requests for the application home page.
 */
@Controller
public class HomeController {
	
	private static final Logger logger = LoggerFactory.getLogger(HomeController.class);
	
	/**
	 * Simply selects the home view to render by returning its name.
	 */
	@RequestMapping(value = "/", method = RequestMethod.GET)
	public String home(Locale locale, Model model) {
		logger.info("Welcome home! The client locale is {}.", locale);
		
	
		
		return "home";
	}
	
	@GetMapping("/introduce")
	public String introduce() {
		return "introduce/introduce";
	}
	
}








##############################################################################
49)게시판(insert, select, delete) 만들기(service, controller, jsp)

1-1)메뉴에서 board를 클릭하면 게시글 목록이 뜨게 해라
	-현재 list.jsp도 있고 list를 처리할 컨트롤러도 만들어져있다.
	이경우에 localhost/들어갔을때 메뉴에서 board를 클릭하면 list.jsp가 열려야하는데 열리지 않는다 해당문제를 해결하라

1-2)현제 게시글이 하나도 없는데 db에 넣었던 데이터 300개를 집어넣어라.	
	list.jsp에 아래 테그가 있는곳에서 처리하면됨
	<!-- 게시물이 들어갈 공간 -->

1-2-1)처음에 이렇게 refDate나옴 Thu Feb 17 14:51:01 KST 2022
1-2-2)이번엔 2022년 02월 17일 오후 02:51 형태로 변경해라


2)글쓰기 버튼이 가능하도록해라
	-tip: 리스트에 글쓰기 관련 태그를 찾아야하는데 그러려면 브라우저에서 f12해서 엘리먼트 클릭해서 위치볼수있는거해서
		글쓰기에 가져다놓으면 해당 태그가 나옴 그거보고 list에서 ctrl f12해서 찾으면 됨
	3-1)게시글 작성 페이지 요청
		-게시글 작성페이지에서는 placeholder를 이용해서 힌트를 입력하라
	3-2)등록누르면 게시글이 디비에 등록되면서 글쓰기 완료시 띄울 알림창처리
		-javascript로하라
		-inclue ... footer 위에 해야함
		-이때 list.jsp까지 넘겨주어야할 데이터의 식별자는 msg로 하고(result로 jsp에서 받아라)
			msg를 받은 result와 비교할 문자열은 "regSuccess"로 하라
	3-3)알림창 확인을 누르면 list.jsp가 바로 응답되게 해라
	
	

3)게시글 제목을 클릭하면상세보기 할수있도록하라
	이때 board/content uri로 controller에 이동하기전에 list에서는 boardNo를 보내주어야하는데
	그걸 아래처럼이 아닌 다른방식으로 하라
		localhost/board/content?boardNo=3
			->localhost/board/content/139
				*즉 파라미터를 ?를 이용해서 보내지 않고 경로로 보내는 것이다.

4)삭제기능
	-겟방식으로 먼저 해보고 post 방식으로 바꿔바라
		-태그에 대한 이해가 있어야 겟방식이든 포스트방식이든실행가능하다.

			
	-현제 content.jsp에 가면 삭제를 처리하기위한 페이지로 이동하는 방식을 a태그를 사용한 GET방식이다.
		그럼 삭제는 내글도 아닌데 뒤에 get으로 uri에 뭍히면 다 되겠네? 그럼 안되지~~!
		그래서 post방식으로 보낼 방법을 잘생각해라
		-a태그 이상한게 있으면 알아서 바꿔라 그리고 form내에 구조이상한건 위로 올려라 
		-post방식으로 하려면 싹다 바꿔야함;;;; 

          <input type= "button" value = "목록" class="btn" onclick = "location.href='/board/list'"  
		style="background-color: #ff52a0; margin-top: 0; height: 40px; color: white; border: 0px solid #388E3C; opacity: 0.8">&nbsp;&nbsp;
		-location.herf는 js 함수로서 해당 버튼을 클릭했을시에 get방식으로 해당 유알엘에 컨텍스트루트붙이고 보내겠단소리

          <input type = "button" value = "수정" class="btn btn-warning" onclick = "" style="color: white;">&nbsp;&nbsp;
		-이건 일단 이문제에서 풀거아니니까 이렇게 복붙만해라

          <input type = "submit" value = "삭제" class="btn btn-warning" onclick = "return confirm('정말로 삭제하시겠습니까?')">&nbsp;&nbsp;
		-onclick의 confirm: 해당버튼을 클릭했을시에 js 함수인 confirm이 동작한다.
				-confirm(""):내부 전달인자를 팝업내부 메시지로하여 예 아니오를 팝업으로 띄우는데
					예이면 true를 반환하고 아니오면 false를 반환한다
		-onclick의 return: 저기서 또 return이 있는데 그건 이 버튼을 클릭하고 confirm 함수가 true를 리턴한다면
				(사용자가 예를 눌렀다면)
			submit(제출) 되고 아니오를 눌렀다면 제출되지 않아서 form이 동작하지 않는 방식이다.

		
##############################################################################


답:

1)header.jsp에서 board를 ctrl f 해서 찾아서 value에 #이라 되어있는데 그걸 /board/list로 고치면 됨
            <a class="nav-link js-scroll-trigger" href="<c:url value='/board/list'/>">BOARD</a>


5)겟방식 (포스트방식은 깃헙참조)

#content.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri="http://java.sun.com/jsp/jstl/core"%>
    
    
<jsp:include page="../include/header.jsp" />
<style>
header.masthead {
	
	display: none;
}	
</style>
<br/><br/>
<div class="container">

<div class="row">
  <div class="col-lg-12">
    <div class="card">
      <div class="card-header text-white" style="background-color: #ff52a0;">${article.boardNo}번 게시물 내용</div>
      <div class="card-body">


          <div class="form-group">
            <label>작성자</label>
            <input type="text" class="form-control" name='writer' value="${article.writer}" readonly>
          </div>
          
          <div class="form-group">
            <label>제목</label>
            <input type="text" class="form-control" name='title' value="${article.title}" readonly>
          </div>

          <div class="form-group">
            <label>내용</label>
            <textarea class="form-control" rows="5" name='content' readonly>${article.content}</textarea>
          </div>
          
        <!--   
        <form role="form" action="#" method="post">
         -->
         
          <a class="btn" href="<c:url value = '/board/list' />"
		style="background-color: #ff52a0; margin-top: 0; height: 40px; color: white; border: 0px solid #388E3C; opacity: 0.8">목록</a>&nbsp;&nbsp;
          <a class="btn" href="#"
		style="background-color: orange; margin-top: 0; height: 40px; color: white; border: 0px solid #388E3C; opacity: 0.8">수정</a>&nbsp;&nbsp;
          <a class="btn" href="<c:url value = '/board/delete?boardNo=${article.boardNo}'/>" onclick="return confirm('정말로 삭제하시겠습니까?')"
		style="background-color: red; margin-top: 0; height: 40px; color: white; border: 0px solid #388E3C; opacity: 0.8">삭제</a>&nbsp;&nbsp;
        <!--
        </form>
		-->


      </div>
    </div>
  </div>
</div>
</div>
<jsp:include page="../include/footer.jsp" />


















































































































22.02.19.13회차
===============================================================================
*수정기능(jQuery로 클릭시 Form요소의 속성변화), 페이징처리(jQuery로 클릭한 버튼객체의 value값수신)
===============================================================================

































































































##############################################################################
50)게시물 수정기능 


1)게시물 수정페이지 요청처리
	-문제해결방식 2가지
		-input에서 onclick이용하여 해결
			-location과 get방식 boardNo 던져서 하는방식
		-input에서 onclick지우고 jquery에서 클릭시 어떻게할지 정하기

-modify 관련 controller처리 (get방식)

-jquery
	-jquery cdn서버에서 다운받게하는 방식
		-다운받아서 사용하는 방식도있다.(사실 외부템플릿 넣을때 리소스에 jquery를 이방식으로 넣긴했다)
				-header.jsp의 31번라인에 다운받은걸 올려놓음
				-그래서 아래 행위를 안해도 되긴 하다.
				-다운받는게 번거로우면 아래처럼 하라는거다.
				-그래서 다운받아서 붙여넣기만 해보고 앞으로는 script만 이용해서할거다
	-jQuery Core 3.4.1 - uncompressed, minified, slim, slim minified
		-minified(축약형)
	-content에 복사해서 붙여넣기해라
-수정button에 id 넣어라 modBtn (수정button을 객체화해서 jquery로 사용하기위함임)
-form에도 id넣어라 formObj (폼을 객체화해서 js로 사용하기위함임)
	-요소 : 태그제목
	-속성 : name, id, property 등
	-속성을 변경하는 걸이용해서 modBtn 객체가 클릭되었을때 브라우저 f12 콘솔창에 "수정버튼이 클릭됨!"이 나오게하고
		이게 클릭되었을때만 action이 /board/modify로 변경되게하고 mehod는 get방식이 되도록하게해서
		controller로 잘가게하고 이때 javascript를(jequery)를 잘 이용해서 수정버튼 클릭이벤트 처리를 해야함

2)게시물 수정 요청
-같은 url인경우 get에 hidden으로 들어오면 post에도 hidden이 따라서 들어온다. 그래서 post에서 수정눌렀을때
	boardNo까지 따라오는 것이다.
	-그래서 따로 post방식으로 넘길 form에서 다시 hidden으로 form 넘길필요없지만 확실하게하기위해서
		form에 히든다시넣어라


##############################################################################



답:

#BoardController의 수정관련 메소드
	@GetMapping("/modify")
	public String modify(Integer boardNo, Model model) {
		System.out.println("URL: /board/modify => GET");
		System.out.println("Parameter(글 번호) : " + boardNo);
		model.addAttribute("article", service.getArticle(boardNo));
		
		return "board/modify";
	}
	
	//게시물 수정 요청
	@PostMapping("/modify")
	public String modify(BoardVO article, RedirectAttributes ra) {
		System.out.println("URL: /board/modify => POST");
		System.out.println("parameter(게시글): " + article);
		
		service.update(article);
		
		ra.addFlashAttribute("msg", "modSuccess");
		
		return "redirect:/board/content/" + article.getBoardNo();
	}


#modify.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core"%>    
<jsp:include page="../include/header.jsp" />
<style>
header.masthead {
	
	display: none;
}	
</style>
<br/><br/>
<div class="container">

<div class="row">
  <div class="col-lg-12">
    <div class="card">
      <div class="card-header text-white" style="background-color: #ff52a0;">${article.boardNo}번 게시물 수정</div>
      <div class="card-body">

        <form role="form" method="post">
        	<input type = "hidden" name = "boardNo" value = "${article.boardNo}">
        
          <div class="form-group">
            <label>작성자</label>
            <input type="text" class="form-control" name='writer' value="${article.writer}">
          </div>
          
          <div class="form-group">
            <label>제목</label>
            <input type="text" class="form-control" name='title' value="${article.title}">
          </div>

          <div class="form-group">
            <label>내용</label>
            <textarea class="form-control" rows="5" name='content'>${article.content}</textarea>
          </div>

          
          <input class="btn" type="submit" value="수정" style="background-color: orange; margin-top: 0; height: 40px; color: white; border: 0px solid #388E3C; opacity: 0.8"/>
          <a class="btn" href="<c:url value = '/board/list'/>"
		style="background-color: #ff52a0; margin-top: 0; height: 40px; color: white; border: 0px solid #388E3C; opacity: 0.8">목록</a>&nbsp;&nbsp;
          
        </form>



      </div>
    </div>
  </div>
</div>
</div>
<jsp:include page="../include/footer.jsp" />







#content.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix = "c" uri="http://java.sun.com/jsp/jstl/core"%>
    
    
<jsp:include page="../include/header.jsp" />
<style>
header.masthead {
	
	display: none;
}	
</style>
<br/><br/>
<div class="container">

<div class="row">
  <div class="col-lg-12">
    <div class="card">
      <div class="card-header text-white" style="background-color: #ff52a0;">${article.boardNo}번 게시물 내용</div>
      <div class="card-body">


          <div class="form-group">
            <label>작성자</label>
            <input type="text" class="form-control" name='writer' value="${article.writer}" readonly>
          </div>
          
          <div class="form-group">
            <label>제목</label>
            <input type="text" class="form-control" name='title' value="${article.title}" readonly>
          </div>

          <div class="form-group">
            <label>내용</label>
            <textarea class="form-control" rows="5" name='content' readonly>${article.content}</textarea>
          </div>
          
           
        <form id = "formObj" role="form" action="<c:url value = '/board/delete'/>" method="post">
	      <input type="hidden" name="boardNo" value="${article.boardNo}">	
        
          <input type= "button" value = "목록" class="btn" onclick = "location.href='/board/list'"  
				style="background-color: #ff52a0; margin-top: 0; height: 40px; color: white; border: 0px solid #388E3C; opacity: 0.8">&nbsp;&nbsp;
          <input id = "modBtn" type = "button" value = "수정" class="btn btn-warning"  style="color: white;">&nbsp;&nbsp;
          <input type = "submit" value = "삭제" class="btn btn-warning" onclick = "return confirm('정말로 삭제하시겠습니까?')">&nbsp;&nbsp;
        </form>
		


      </div>
    </div>
  </div>
</div>
</div>



<script>
	const result = "${msg}";
	if (result === "modSuccess") {
		alert("게시물 수정 완료!");
	}

//jquery의 시작
$(function() {
	//변수는 let, 상수는 const로 선언 2015에 개선된문법(ES2015문법) var를 쓰지말란얘기임 혼용은 됨
	const formElement = $("#formObj");
	
	//수정 버튼 클릭 이벤트 처리
	//var modifyBtn = document.getElementById("modBtn"); // vanila js 원형, 원래문법임
	var modifyBtn = $("#modBtn");
	modifyBtn.click(function() {
		console.log("수정 버튼이 클릭됨!");
		formElement.attr("action", "/board/modify");
		formElement.attr("method", "get");
		formElement.submit();
	});
	
	
	
}); //익명함수, jquery의 끝
	
</script>
<jsp:include page="../include/footer.jsp" />


















##############################################################################
51)페이징처리

1)각페이지당 순차적이고 중복적이지 않은 10개의 게시물이 나오도록 페이징처리를 해보시오
	-메소드명 : getArticleListPaging(int page)
	-일단 여기서 list.jsp까지 변경하면 너무 복잡해지니까 주소창에
	http://localhost/board/list?page=7 이런식으로 쳐서 page=1부터 10개식 내림차순으로 나오는지 확인해라
	직접 page 파라미터를 주는방식으로

2)PageVO를 만들고 controller, service, repository에서 이런 변화에 적응하도록처리하며
	단위테스트로 BoardMapperTest에서 잘되는지 setter로 두 변수에 값을 주입한뒤 해보아라
					-BoardMapper.xml은 변경할 필요없음 어차피 객체로 바꼈다해도 getter로 뽑으니까
						PageVO에 getter만 잘 만들어져 있으면 됨
	-page
	-countPerPage
	-com.spring.mvc.commons.PageVO;

3)getPageStart()를 만들고 BoardMapper.xml에서 ${}했을때 getter를 불러오는 규칙을 이해하고서
	getPage()가 호출되는 것이 아닌 getPageStart()가 호출되도록하라
	-getPageStart()에는 입력된 페이지 번호에 따라서 몇번째 인덱스부터 가져올건지를 반환하는 기능을 한다.
	-아래처럼 검색해야함 아직은 jsp에서 버튼을 눌렀을때 값을 전달하는 로직을 안짰기 때문임
		http://localhost/board/list?page=2&countPerPage=20


4)유효성검증: 아래 예시가 들어갔을때 유효성검증한값대로 처리되도록 만드시오
	-page <= 0 경우 : 1page 응답(db 테이블의 행중 0번인덱스부터 가져오는 것을 뜻함)
	-countPerPage <= 0 || > 50 경우 : 한페이지당 10개 응답
		http://localhost/board/list?page=2&countPerPage=3000
		http://localhost/board/list?page=-1090&countPerPage=3000
		http://localhost/board/list?page=-10&countPerPage=51

5)페이지 버튼 1~10까지 만들고 1누르면 1로 가고 2 누르면 2로가게해라
	-이때 각 페이지는 1~10사이로 당연히 가는거고 한페이지당 보여줘야할놈은 기본 세팅된대로만 나오게(한페이지당 10개식) 해라
	-list.jsp만 만지면 된다.

6)10, 20, 30 눌렀을때 해당 갯수만큼 1페이지가 열리게하라
	-아직 누른채로 2페이지 3페이지 이동은 안됨 지금하는거까지만해라
##############################################################################



답:

3)
#PageVO
	public Integer getPageStart() {
		return (this.page - 1) * this.countPerPage;
	}
	
#BoardMapper.xml
	<select id = "getArticleListPaging" resultMap = "BoardMap">
		SELECT * 
		FROM mvc_board
		ORDER BY board_no DESC
		LIMIT #{pageStart}, #{countPerPage}
	</select> 





5)

#list.jsp
					<!-- 페이징 처리 부분  -->
					<ul class="pagination justify-content-center">
						<!-- 이전 버튼 -->
                       	<li class="page-item">
							<a class="page-link" href="#" 
							style="background-color: #ff52a0; margin-top: 0; height: 40px; color: white; border: 0px solid #f78f24; opacity: 0.8">이전</a>
						</li>
						
						<!-- 페이지 버튼 -->
						<c:forEach var = "pageNum" begin = "1" end = "10">
							<li class="page-item">
							   <a href="<c:url value = '/board/list?page=${pageNum}'/>" class="page-link" style="margin-top: 0; height: 40px; color: pink; border: 1px solid pink;">${pageNum}</a>
							</li>
					   </c:forEach>





6)

<script type="text/javascript">
	//글쓰기 완료시 띄울 알림창처리
	const result = "${msg}";
	
	if (result === "regSuccess") {
		alert("게시글 등록이 완료되었습니다.");
	} else if (result === "delSuccess") {
		alert("게시글 삭제가 완료되었습니다.");
	}
	
	//start jQuery
	$(function() {
		//목록 개수가 변동하는 이벤트 처리
		$("#count-per-page .btn-izone").click(function() {
			//console.log("목록 버튼이 클릭됨!");
			//console.log($(this).val());
			let count = $(this).val();
			location.href = "/board/list?countPerPage=" + count;
		});
	});
</script>





















































































22.02.20.14회차
===============================================================================
*페이징처리알고리즘
===============================================================================









































































































































##############################################################################
52)페이징 처리 알고리즘 개념정리 및 실습

클래스생성
package com.spring.mvc.board.test.PagingAlgorithmTest;


SELECT COUNT(*)
FROM mvc_board;

package com.spring.mvc.board.test;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import com.spring.mvc.board.repository.IBoardMapper;
import com.spring.mvc.commons.PageVO;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {"file:src/main/webapp/WEB-INF/spring/mvc-config.xml"})

public class PagingAlgorithmTest {
	/*
	 	# 페이징 알고리즘 만들기
	 	* 사용자가 보게 될 페이지 화면
	  		-한 화면에 페이지를 10개식 끊어서 보여준다면?
	  		ex)1 2 3 4 ... 9 10 [다음] // [이전] 31 32 33 ... 39 40[다음]
	  		
	  			-만약에 총 게시물의 수가 67개라면? 이전, 다음버튼 두개다 없어야함
	  			ex) 1 2 3 4 5 6 7
	  		
	  			-총 게시물 수가 142개이고 현재 12페이지에 사용자가 머물러 있다면? 다음은 없다
	  			ex) [이전] 11 12 13 14 15
	  	
	  	* 위 화면을 구성하는 알고리즘 방법
	  	1. 우선 총 게시물의 수를 조회해야한다.
	  		-총 게시물 수는 DB로부터 수를 조회하는 SQL을 작성
	  	2. 사용자가 현재 위치한 페이지를 기준으로 
	  	끝 페이지 번호를 계산하는 로직 작성
	  		ex)만약 현재 사용자가 보고 있는 페이지가 3페이지고 한 화면에 보여줄 페이지가 10페이지씩이라면
	  			-> 끝페이지 번호는? 10page
	  		      만약 현재 페이지가 37페이지고 한 화면에 보여줄 페이지가 20페이지식이라면 
	  		   	-> 끝페이지 번호는 ?? 40page
	  		   
	  		-끝페이지번호공식: 
	  			Math.ceil(현재위치한 페이지번호 / 한 화면당 보여질 페이지의 수) * 한 화면당 보여질 페이지수
	  			Math.ceil :올림함수
	  	
	   3.시작페이지 번호 계산하기
	   		-현재 위치한 페이지가 15페이지이고, 한 화면에 보여줄 페이지가 10페이지씩이라면??
	   			-> 시작페이지번호는? 11페이지
	   		-현재 위치한 페이지가 73페이지이고, 한 화면에 보여줄 페이지가 20페이지씩이라면??
	   			-> 시작페이지번호는? 61페이지
	   		-공식:
	   			(끝페이지 번호 - 한 화면에 보여줄 페이지의 수) + 1;
	   4. 끝 페이지  보정
	   		- 총 게시물 수가 324개이고 한 페이지당 10개의 게시물을 보여준다
	   		- 그리고 현재 이사람은 31페이지를 보고 있다.
	   		- 그리고 한 화면당 10개씩의 페이지를 보여준다.
	   		- 그렇다면 위 공식에 의한 끝페이지는 어덯게 계산되는가?
				-> 40page
			- 하지만 실제 끝페이지는 몇번이어야 하는가?? 33페이지 
			
			4-1. 이전버튼 활성 여부 설정
				-시작페이지가 1인 화면을 제외한 모든 화면에서 이전이 있어야함
				-공식: 시작페이지 번호가 1로 구해진 시점에서 비활성처리. 나머지는 활성
			4-2. 다음버튼 활성 여부 설정
				-언제 다음버튼을 비활성화 할 것인가??
					-공식:
						보정전 끝페이지번호 x 한 페이지에 들어갈 게시물 수 >= 총게시물수 -> 비활성
						
			4-3. 끝페이지 값 보정
			-다음 버튼이 비활성화 되었을때 총 게시물수에 맞춰 끝페이지 번호를 재보정한다.
			-공식: Math.ceil(총게시물의 수 / 한 페이지에 보여줄 게시물 수)
			
			 
	 */
	
	@Autowired
	private IBoardMapper mapper;
	
	@Test
	public void pagingAlgolithmTest() {
		// 1.총 게시물 수 구하는 테스트
		System.out.println("=============================");
		System.out.println(" # 총 게시물 수 : " + mapper.countArticles());
		System.out.println("=============================");
		
		
		// 2.끝페이지 번호 계산 테스트
		PageVO paging = new PageVO();
		
		paging.setPage(32);
		paging.setCountPerPage(10); // 기본값이 10 되어있어서 사실 setter 안넣어줘도됨
		int displayPage = 20;
		
		int endPage = (int) (Math.ceil(paging.getPage() / (double) displayPage)) * displayPage;
//		System.out.println(Math.ceil(30.0)); // 끝자리가 0 즉 0으로 나누어떨어진 경우엔 올림하지않는다.
		System.out.println("끝페이지지 번호: " + endPage); // 90 나와야함
		
		// 3.시작페이지 번호 계산 테스트
		int beginPage = (endPage - displayPage) + 1;
		
		
		System.out.println("시작페이지 번호 : " + beginPage);
		
		boolean isPrev = (beginPage == 1) ? false : true;
		// 도대체 왜 위에처럼 굳이 삼항쓰는거지
		System.out.println("이전버튼 활성화 여부 : " + isPrev); 
//		System.out.println("isperv : " + !(beginPage == 1));
//		System.out.println("isperv : " + (beginPage != 1));
		
		
		boolean isNext = (mapper.countArticles() <= (endPage * paging.getCountPerPage())) ? false : true;
		
		System.out.println("다음버튼 활성화 여부 : " + isNext);
		
		
		// 끝페이지 보정
		if (!isNext) {
			endPage = (int) Math.ceil(mapper.countArticles() / (double) paging.getCountPerPage());
		}
		
		System.out.println("보정 후 끝페이지 번호 : " + endPage);
		System.out.println("=============================");
		
		
	}
}

##############################################################################



답: 실습해봐라





























##############################################################################
53)페이징 알고리즘을 위한 클래스작성
	-toString도 넣어라

package com.spring.mvc.commons;

public class PageCreator {
	//페이지 번호와 한 페이지당 들어갈 게시물 수를 갖고 있는 객체
	private PageVO paging;
	private Integer articleTotalCount; // 게시판의 총 게시물 수
	
	private Integer beginPage; // 시작페이지번호
	private Integer endPage; // 끝페이지번호
	private boolean prev; // 이전버튼 활성화 여부
	private boolean next; // 다음버튼 활성화 여부
	
	//한 화면에 보여질 페이지 수
	private final Integer displayPageNum = 10;

	//페이징 알고리즘을 수행할 메서드 선언
	private void calcDataOfPage() {
		// 보정 전 끝 페이지 구하기
		
		
		// 시작 페이지 번호 구하기
		
		// 현재 시작 페이지가 1이라면 이전 버튼 활성화 여부를 false로 지정
		
		// 마지막 페이지인지 여부 확인 후 다음 버튼 비활성
		
		// 재보정 여부 판단하기
		
		// 끝 페이지 재보정하기
	}
	
	public PageVO getPaging() {
		return paging;
	}

	public void setPaging(PageVO paging) {
		this.paging = paging;
	}

	public Integer getArticleTotalCount() {
		return articleTotalCount;
	}

	public void setArticleTotalCount(Integer articleTotalCount) {
		this.articleTotalCount = articleTotalCount;
	}

	public Integer getBeginPage() {
		return beginPage;
	}

	public void setBeginPage(Integer beginPage) {
		this.beginPage = beginPage;
	}

	public Integer getEndPage() {
		return endPage;
	}

	public void setEndPage(Integer endPage) {
		this.endPage = endPage;
	}

	public boolean isPrev() {
		return prev;
	}

	public void setPrev(boolean prev) {
		this.prev = prev;
	}

	public boolean isNext() {
		return next;
	}

	public void setNext(boolean next) {
		this.next = next;
	}

	public Integer getDisplayPageNum() {
		return displayPageNum;
	}
	
	
}

##############################################################################



답:

package com.spring.mvc.commons;

public class PageCreator {
	//페이지 번호와 한 페이지당 들어갈 게시물 수를 갖고 있는 객체
	private PageVO paging;
	private Integer articleTotalCount; // 게시판의 총 게시물 수
	
	private Integer beginPage; // 시작페이지번호
	private Integer endPage; // 끝페이지번호
	private boolean prev; // 이전버튼 활성화 여부
	private boolean next; // 다음버튼 활성화 여부
	
	//한 화면에 보여질 페이지 수
	private final Integer displayPageNum = 10;
	
	
	//페이징 알고리즘을 수행할 메서드 선언
	private void calcDataOfPage() {
		// 보정 전 끝 페이지 구하기
		endPage = (int) Math.ceil(paging.getPage() / (double) displayPageNum) 
				* displayPageNum;
		
		
		// 시작 페이지 번호 구하기
		beginPage = (endPage - displayPageNum) + 1;
		
		
		
		// 현재 시작 페이지가 1이라면 이전 버튼 활성화 여부를 false로 지정
		prev = (beginPage != 1);
		
		// 마지막 페이지인지 여부 확인 후 다음 버튼 비활성
		next = !(articleTotalCount <= (endPage * paging.getCountPerPage()));
		
		// 재보정 여부 판단하기
		if (!next 
				&& articleTotalCount < (endPage * paging.getCountPerPage())) { // 랑 같은말임
			// 끝 페이지 재보정하기
			endPage = (int) Math.ceil(articleTotalCount / (double)paging.getCountPerPage());
		}			
	}
	
	public PageVO getPaging() {
		return paging;
	}

	public void setPaging(PageVO paging) {
		this.paging = paging;
	}

	public Integer getArticleTotalCount() {
		return articleTotalCount;
	}

	public void setArticleTotalCount(Integer articleTotalCount) {
		this.articleTotalCount = articleTotalCount;
		calcDataOfPage();
	}

	public Integer getBeginPage() {
		return beginPage;
	}

	public void setBeginPage(Integer beginPage) {
		this.beginPage = beginPage;
	}

	public Integer getEndPage() {
		return endPage;
	}

	public void setEndPage(Integer endPage) {
		this.endPage = endPage;
	}

	public boolean isPrev() {
		return prev;
	}

	public void setPrev(boolean prev) {
		this.prev = prev;
	}

	public boolean isNext() {
		return next;
	}

	public void setNext(boolean next) {
		this.next = next;
	}

	public Integer getDisplayPageNum() {
		return displayPageNum;
	}

	@Override
	public String toString() {
		return "PageCreator [paging=" + paging + ", articleTotalCount=" + articleTotalCount + ", beginPage=" + beginPage
				+ ", endPage=" + endPage + ", prev=" + prev + ", next=" + next + ", displayPageNum=" + displayPageNum
				+ "]";
	}
	
	
	
}




























##############################################################################
54)페이징알고리즘이 get방식으로 page를 넘겼을때 controller에 잘 넘어와서 원하는 pageCreator 값이 나오는지 콘솔(이클립스)에서 확인하기
	-BoardController.java 만 손보면 됨 앞문제 pageCreator 잘짰으면 집어넣고 로그로직만 넣은채 실행하면됨
		-list.jsp 아직 쓰기 전임
		-setter로 pageCreator 넣어보기도하고 추가 코드를 작성해서 생성자를 통해 한줄로 되게도 해바라

PageVo에 디버깅용으로 toString() 만들어라


URL : /board/list GET -> result : 10
parameter(페이지번호) : 1번
pc : PageCreator [paging=PageVO [page=1, countPerPage=10], articleTotalCount=323, beginPage=1, endPage=10, prev=false, next=true, displayPageNum=10]
URL : /board/list GET -> result : 10
parameter(페이지번호) : 11번
pc : PageCreator [paging=PageVO [page=11, countPerPage=10], articleTotalCount=323, beginPage=11, endPage=20, prev=true, next=true, displayPageNum=10]
URL : /board/list GET -> result : 10
parameter(페이지번호) : 31번
pc : PageCreator [paging=PageVO [page=31, countPerPage=10], articleTotalCount=323, beginPage=31, endPage=33, prev=true, next=false, displayPageNum=10]
URL : /board/list GET -> result : 3
parameter(페이지번호) : 33번
pc : PageCreator [paging=PageVO [page=33, countPerPage=10], articleTotalCount=323, beginPage=31, endPage=33, prev=true, next=false, displayPageNum=10]

##############################################################################



답: 







package com.spring.mvc.board.controller;

import java.util.List;

import javax.inject.Inject;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.spring.mvc.board.model.BoardVO;
import com.spring.mvc.board.service.IBoardService;
import com.spring.mvc.commons.PageCreator;
import com.spring.mvc.commons.PageVO;

@Controller
@RequestMapping("/board")
public class BoardController {
	@Inject
	private IBoardService service;
	
	//게시글 목록 불러오기 요청
	/*
	@GetMapping("/list")
	public void list(Model model) {
		List<BoardVO> list = service.getArticleList();
		System.out.println("URL : /board/list GET -> result : " + list.size());
//		list.forEach(article -> System.out.println(article));
		
		model.addAttribute("articles", list);
//		return "board/list";
	}
	*/
	
	//페이징 처리 이후 게시글 목록 불러오기 요청
	@GetMapping("/list")
	public void list(PageVO paging, Model model) {
		List<BoardVO> list = service.getArticleListPaging(paging);
		
		System.out.println("URL : /board/list GET -> result : " + list.size());
		System.out.println("parameter(페이지번호) : " + paging.getPage() + "번");
//		list.forEach(article -> System.out.println(article));
		
		PageCreator pc = new PageCreator();
		
		pc.setPaging(paging);
		pc.setArticleTotalCount(service.countArticles());
		System.out.println("pc : " + pc);
		
		model.addAttribute("articles", list);
		model.addAttribute("pc", pc);
		
//		return "board/list";
	}
	
	//게시글 작성 페이지 요청
	@GetMapping("/write")
	public void write() {
		System.out.println("URL : /board/write => GET");
	}
	
	//게시글 등록 요청
	@PostMapping("/write")
	public String write(BoardVO article, RedirectAttributes ra) {
		System.out.println("URL : /board/write => POST");
		System.out.println("Controller parameter : " + article);
		service.insert(article);
		ra.addFlashAttribute("msg", "regSuccess");
		
		return "redirect:/board/list";
	}
	
	
	//게시물 상세 조회 요청
	@GetMapping("/content/{boardNo}")
	//public String content(@PathVariable("boardNo") Integer boardNo, Model model) {
							//PathVariable로 경로에서 받은 놈 필드명을 가져오고 그 필드명이
					//Integer boardNo와 같으면 PathVariable뒤에 전달인자를 줄 필요 없다.
	public String content(@PathVariable Integer boardNo, Model model) {
		System.out.println("URL: /board/content => GET");
		BoardVO article = service.getArticle(boardNo);
		System.out.println("result data: " + article);
		model.addAttribute("article", article);
		return "board/content";
	}
	
	//게시물 삭제 요청
	/*
	@GetMapping("/delete")
	public String delete(Integer boardNo, RedirectAttributes ra) {
		service.delete(boardNo);
		ra.addFlashAttribute("msg", "delSuccess");
		return "redirect:/board/list";
	}
	*/
	
	@PostMapping("/delete")
	public String delete(Integer boardNo, RedirectAttributes ra) {
		System.out.println("URL: /board/delete => POST");
		System.out.println("Controller Paramerter : " + boardNo);
		service.delete(boardNo);
		ra.addFlashAttribute("msg", "delSuccess");
		return "redirect:/board/list";
	}
	
	@GetMapping("/modify")
	public String modify(Integer boardNo, Model model) {
		System.out.println("URL: /board/modify => GET");
		System.out.println("Parameter(글 번호) : " + boardNo);
		model.addAttribute("article", service.getArticle(boardNo));
		
		return "board/modify";
	}
	
	//게시물 수정 요청
	@PostMapping("/modify")
	public String modify(BoardVO article, RedirectAttributes ra) {
		System.out.println("URL: /board/modify => POST");
		System.out.println("parameter(게시글): " + article);
		
		service.update(article);
		
		ra.addFlashAttribute("msg", "modSuccess");
		
		return "redirect:/board/content/" + article.getBoardNo();
	}
	
}























##############################################################################
55)페이징알고리즘 한 내용을 list.jsp에 적용하기
	-list.jsp만 만지면 됨
1)페이지버튼, 이전버튼, 다음버튼

2)내가 몇페이지에 있는지 ui로 나타내기(CSS쪽임)
	page-active 속성추가(띄어쓰기하고 넣으면 속성이됨)
	background-color: #ff52a0;
	el에서는 문자열을 홀따옴표로 쓴다는것을 명심하라

3)10, 20, 30을 누르는 순간 1페이지로 돌아가지만 한페이지당 보일 게시글수는 누른 value만큼 다음페이지로 이동할때마다 항상 유지되게해라 
	-20으로 하면 원래 10일때 30정도 페이지까지있던게 17페이지정도로 바뀐다.
##############################################################################



답:

#list.jsp

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
<!-- 포매팅 관련 태그라이브러리 -->
<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt"%>
<jsp:include page="../include/header.jsp" />
<style>
header.masthead {
	
	display: none;
}	
.btn-orange {
	background-color: orange;
	color: white;
}
.btn-izone {
	background-color: #ff52a0;
	color: white;
}

.page-active {
	background-color: #ff52a0;
}

</style>

<br><br> 
 
    <!-- Begin Page Content -->
	

	<div class="container">
		<div class="row">
			<div class="col-lg-2">
			</div>
			<div class="col-lg-8">
				<div class="panel-body">
				<h2 class="page-header"><span style="color: #ff52a0;">IZONE</span> 자유 게시판
					<span id="count-per-page" style="float: right;">
	                     <input class="btn btn-izone" type="button" value="10">  
	                     <input class="btn btn-izone" type="button" value="20">   
	                     <input class="btn btn-izone" type="button" value="30">
                     </span>
					
				</h2>
					<table class="table table-bordered table-hover">
						<thead>
							<tr style="background-color: #ff52a0; margin-top: 0; height: 40px; color: white; border: 0px solid #f78f24; opacity: 0.8">
								<th>#번호</th>
								<th>작성자</th>
								<th>제목</th>
								<th>작성일</th>
								<th>조회수</th>
							</tr>
						</thead>

						<!-- 게시물이 들어갈 공간 -->
						<c:if test = "${articles.size() <= 0}">
							<h2>게시물이 없습니다.</h2>
						</c:if>
						<c:if test = "${articles.size() > 0}">						
							<c:forEach var = "article" items = "${articles}">
								<tr style="color: #ff52a0;">
									<td>${article.boardNo}</td>
									<td>${article.writer}</td>
	
									<td><a style="margin-top: 0; height: 40px; color: orange;" href="<c:url value = '/board/content/${article.boardNo}'/>">
											${article.title}
										</a>
									</td>
	
									<!-- 이방식은 날짜시간이 드릅게 나온다
									<td>${article.regDate}</td>
									 -->
									<td>
										<fmt:formatDate value="${article.regDate}" pattern = "yyyy년 MM월 dd일 a hh:mm"/>
									</td>
									<td>${article.viewCnt}</td>
								</tr>
							</c:forEach>
						</c:if>
					</table>
					
					<!-- 페이징 처리 부분  -->
					<ul class="pagination justify-content-center">
						<!-- 이전 버튼 -->
						<c:if test = "${pc.prev}">
	                       	<li class="page-item">
								<a class="page-link" href="<c:url value = '/board/list?page=${pc.beginPage - 1}&&countPerPage=${pc.paging.countPerPage}'/>" 
								style="background-color: #ff52a0; margin-top: 0; height: 40px; color: white; border: 0px solid #f78f24; opacity: 0.8">이전</a>
							</li>
						</c:if>
						
						<!-- 페이지 버튼 -->
						<c:forEach var = "pageNum" begin = "${pc.beginPage}" end = "${pc.endPage}">
							<li class="page-item">
							   <a href="<c:url value = '/board/list?page=${pageNum}&&countPerPage=${pc.paging.countPerPage}'/>" class="page-link ${(pc.paging.page == pageNum) ? 'page-active' : ''}" style="margin-top: 0; height: 40px; color: pink; border: 1px solid pink;">${pageNum}</a>
							</li>
					   </c:forEach>
					   <!-- 다음 버튼 -->
					   <c:if test = "${pc.next}">
						    <li class="page-item">
						      <a class="page-link" href="<c:url value = '/board/list?page=${pc.endPage + 1}&&countPerPage=${pc.paging.countPerPage}'/>" 
						      style="background-color: #ff52a0; margin-top: 0; height: 40px; color: white; border: 0px solid #f78f24; opacity: 0.8">다음</a>
						    </li>
					    </c:if>
				    </ul>
					<!-- 페이징 처리 끝 -->
					</div>
				</div>
			</div>
					<!-- 검색 버튼 -->
					<div class="row">
						<div class="col-sm-2"></div>
	                    <div class="form-group col-sm-2">
	                        <select id="condition" class="form-control" name="condition">                            	
	                            <option value="title">제목</option>
	                            <option value="content">내용</option>
	                            <option value="writer">작성자</option>
	                            <option value="titleContent">제목+내용</option>
	                        </select>
	                    </div>
	                    <div class="form-group col-sm-4">
	                        <div class="input-group">
	                            <input type="text" class="form-control" name="keyword" id="keywordInput" placeholder="검색어">
	                            <span class="input-group-btn">
	                                <input type="button" value="검색" class="btn btn-izone btn-flat" id="searchBtn">                                       
	                            </span>
	                        </div>
	                    </div>
	                    <div class="col-sm-2">
							<a href="<c:url value = '/board/write'/>" class="btn btn-izone float-right">글쓰기</a>
						</div>
						<div class="col-sm-2"></div>
					</div>
					
		
	</div>
	
<script type="text/javascript">
	//글쓰기 완료시 띄울 알림창처리
	const result = "${msg}";
	
	if (result === "regSuccess") {
		alert("게시글 등록이 완료되었습니다.");
	} else if (result === "delSuccess") {
		alert("게시글 삭제가 완료되었습니다.");
	}
	
	//start jQuery
	$(function() {
		//목록 개수가 변동하는 이벤트 처리
		$("#count-per-page .btn-izone").click(function() {
			//console.log("목록 버튼이 클릭됨!");
			//console.log($(this).val());
			let count = $(this).val();
			location.href = "/board/list?countPerPage=" + count;
		});
	});
</script>
<jsp:include page="../include/footer.jsp" />






























































































































































































22.02.21.15회차
===============================================================================
*페이징을 이용한 검색기능 추가(SearchVO)
===============================================================================


















































































































































































##############################################################################
56)페이징처리(page, countPerPage 유지한채로 목록돌아가기)

1)20페이지에서 20줄짜리 에서 제목눌러서 보고있다가 목록눌렀을때 1페이지 10줄짜리로 가는데 이게 20페이지 20줄짜리로 다시가도록해라
content의 목록의 onclick 부분 싹다 지우고 id = "list-btn"
// 목록버튼 클릭 이벤트 처리

2)제목클릭->수정->목록해도 이전 페이지와 글수를 유지하도록 만들어라


3)삭제후에도 리스트갈때 원래 페이지와 페이지당글수를 유지하게해라
	-원시적방법:리턴에뭍히기
	-RedirectAttributes 이용
		-addAttribute는 get방식으로 파라미터를 뭍혀서 보낸다.
			-addFlash아님
		-이걸 또 간결하게 표현도 해봐라 체인방식

##############################################################################














##############################################################################
57)페이징처리(제목검색했을대 제목중에 검색내용에 해당하는 값을 가져와서 출력하는 페이징)

//제목으로 검색기능(페이징)
	List<BoardVO> getArticleListByTitle();
			-이거 제목뿐만아니라 다른거도 다할수있으면 getArticleList()와 
				getArticleListPaging()을 삭제해도 되긴함 교육차원에서 남겨둠

com.spring.mvc.commons.SearchVO
	-PageVO 상속

*검색처리 이후 게시물 목록 불러오기 요청(list를 controller에 이전 list 복사해서 다시 만들어라 이전 껀 주석두고)
	-list를 controller에 다시 만들어란거다. 기능을 추가하란게아님

//제목으로 검색 이후 게시물 수 조회기능
	Integer countArticleByTitle(SearchVO search);

//검색 버튼 이벤트처리
	-검색누를시 text로 친 벨류값을 받아서 그걸 list에 보내서 db로 보내라

//엔터키 입력 이벤트
	-검색키를 마우스로 클릭하는거 뿐만 아니라 엔터쳐도 넘어가게 하라
##############################################################################



















##############################################################################
58)검색기능추가

제목뿐만아닌 내용, 제목 + 내용으로도 검색가능하게만들어라
방법은 if else로 controller에 넘어온녀석의 이름이 title이면 title관련 기능메서드 동작시키고
wirter면 writer관련 동작 content면 content 형식으로
	-method이름
		.getArticleListByTitleContent()
		.countArticleByTitleContent()
	-sql
		제목에도 내용에도 같은내용이 동일하게 들어가는경우(또는이아님)



##############################################################################


















